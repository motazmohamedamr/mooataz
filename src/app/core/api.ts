//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.7.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import {
  mergeMap as _observableMergeMap,
  catchError as _observableCatch,
} from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import {
  HttpClient,
  HttpHeaders,
  HttpResponse,
  HttpResponseBase,
} from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IAccountsClient {
  getAdminsPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfAdminVm>;
  getList(apiVersion: string): Observable<AccountListVm[]>;
  getUser(id: string, apiVersion: string): Observable<AccountDetailsDashboardVm>;
  getBulk(
    search: string | null | undefined,
    apiVersion: string,
    ids: string[]
  ): Observable<AccountListVm[]>;
  post(apiVersion: string, command: AccountsPostCommand): Observable<AccountResult>;
  put(apiVersion: string, command: AccountsPutCommand): Observable<void>;
  enableTwoFactorAuthentication(
    apiVersion: string,
    command: EnableTwoFactorAuthenticationCommand
  ): Observable<QrImage>;
  verifyOtpOfTwoFactorAuthentication(
    apiVersion: string,
    request: OtpVerificationDTO
  ): Observable<HttpResultOfBoolean>;
  disableTwoFactorAuthentication(
    apiVersion: string,
    command: DisableTwoFactorAuthenticationCommand
  ): Observable<void>;
  resetTwoFactorAuthentication(
    apiVersion: string,
    command: AccountsResetTwoFACommand
  ): Observable<void>;
  resetUserPassword(
    apiVersion: string,
    command: ResetUserPasswordCommand
  ): Observable<void>;
  endLockout(apiVersion: string, command: AccountsEndLockoutCommand): Observable<void>;
  activate(apiVersion: string, command: AccountsActivateCommand): Observable<void>;
  deactivate(apiVersion: string, command: AccountsDeactivateCommand): Observable<void>;
  delete(id: string | null | undefined, apiVersion: string): Observable<FileResponse>;
}

@Injectable({
  providedIn: 'root',
})
export class AccountsClient implements IAccountsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? '';
  }

  getAdminsPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfAdminVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/accounts/admins-page?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAdminsPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAdminsPage(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<PaginatedListOfAdminVm>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PaginatedListOfAdminVm>;
        })
      );
  }

  protected processGetAdminsPage(
    response: HttpResponseBase
  ): Observable<PaginatedListOfAdminVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfAdminVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getList(apiVersion: string): Observable<AccountListVm[]> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/accounts/list';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetList(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetList(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<AccountListVm[]>;
            }
          } else return _observableThrow(response_) as any as Observable<AccountListVm[]>;
        })
      );
  }

  protected processGetList(response: HttpResponseBase): Observable<AccountListVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(AccountListVm.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getUser(id: string, apiVersion: string): Observable<AccountDetailsDashboardVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/accounts/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetUser(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetUser(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<AccountDetailsDashboardVm>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<AccountDetailsDashboardVm>;
        })
      );
  }

  protected processGetUser(
    response: HttpResponseBase
  ): Observable<AccountDetailsDashboardVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AccountDetailsDashboardVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getBulk(
    search: string | null | undefined,
    apiVersion: string,
    ids: string[]
  ): Observable<AccountListVm[]> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/accounts/bulk?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (search !== undefined && search !== null)
      url_ += 'search=' + encodeURIComponent('' + search) + '&';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(ids);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetBulk(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetBulk(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<AccountListVm[]>;
            }
          } else return _observableThrow(response_) as any as Observable<AccountListVm[]>;
        })
      );
  }

  protected processGetBulk(response: HttpResponseBase): Observable<AccountListVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(AccountListVm.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  post(apiVersion: string, command: AccountsPostCommand): Observable<AccountResult> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/accounts';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPost(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPost(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<AccountResult>;
            }
          } else return _observableThrow(response_) as any as Observable<AccountResult>;
        })
      );
  }

  protected processPost(response: HttpResponseBase): Observable<AccountResult> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AccountResult.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  put(apiVersion: string, command: AccountsPutCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/accounts';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processPut(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processPut(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processPut(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  enableTwoFactorAuthentication(
    apiVersion: string,
    command: EnableTwoFactorAuthenticationCommand
  ): Observable<QrImage> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/accounts/enable-2fa';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processEnableTwoFactorAuthentication(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processEnableTwoFactorAuthentication(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<QrImage>;
            }
          } else return _observableThrow(response_) as any as Observable<QrImage>;
        })
      );
  }

  protected processEnableTwoFactorAuthentication(
    response: HttpResponseBase
  ): Observable<QrImage> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = QrImage.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  verifyOtpOfTwoFactorAuthentication(
    apiVersion: string,
    request: OtpVerificationDTO
  ): Observable<HttpResultOfBoolean> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/accounts/verify-otp';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processVerifyOtpOfTwoFactorAuthentication(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processVerifyOtpOfTwoFactorAuthentication(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<HttpResultOfBoolean>;
            }
          } else
            return _observableThrow(response_) as any as Observable<HttpResultOfBoolean>;
        })
      );
  }

  protected processVerifyOtpOfTwoFactorAuthentication(
    response: HttpResponseBase
  ): Observable<HttpResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  disableTwoFactorAuthentication(
    apiVersion: string,
    command: DisableTwoFactorAuthenticationCommand
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/accounts/disable-2fa';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDisableTwoFactorAuthentication(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDisableTwoFactorAuthentication(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDisableTwoFactorAuthentication(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  resetTwoFactorAuthentication(
    apiVersion: string,
    command: AccountsResetTwoFACommand
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/accounts/reset-2fa';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processResetTwoFactorAuthentication(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processResetTwoFactorAuthentication(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processResetTwoFactorAuthentication(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  resetUserPassword(
    apiVersion: string,
    command: ResetUserPasswordCommand
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/accounts/reset-credentials';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processResetUserPassword(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processResetUserPassword(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processResetUserPassword(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  endLockout(apiVersion: string, command: AccountsEndLockoutCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/accounts/end-lockout';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processEndLockout(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processEndLockout(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processEndLockout(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  activate(apiVersion: string, command: AccountsActivateCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/accounts/activate';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processActivate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processActivate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processActivate(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  deactivate(apiVersion: string, command: AccountsDeactivateCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/accounts/deactivate';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeactivate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeactivate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDeactivate(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  delete(id: string | null | undefined, apiVersion: string): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/accounts/delete?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (id !== undefined && id !== null)
      url_ += 'Id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

export interface IActivitiesClient {
  getActivities(
    from: Date | null | undefined,
    to: Date | null | undefined,
    projectId: string | null | undefined,
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfRequestActivityViewVM>;
  getProjectActivities(
    from: Date | null | undefined,
    to: Date | null | undefined,
    projectId: string | null | undefined,
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfRequestActivityViewVM>;
}

@Injectable({
  providedIn: 'root',
})
export class ActivitiesClient implements IActivitiesClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? '';
  }

  getActivities(
    from: Date | null | undefined,
    to: Date | null | undefined,
    projectId: string | null | undefined,
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfRequestActivityViewVM> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/activities?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (from !== undefined && from !== null)
      url_ += 'From=' + encodeURIComponent(from ? '' + from.toISOString() : '') + '&';
    if (to !== undefined && to !== null)
      url_ += 'To=' + encodeURIComponent(to ? '' + to.toISOString() : '') + '&';
    if (projectId !== undefined && projectId !== null)
      url_ += 'ProjectId=' + encodeURIComponent('' + projectId) + '&';
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetActivities(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetActivities(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<PaginatedListOfRequestActivityViewVM>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PaginatedListOfRequestActivityViewVM>;
        })
      );
  }

  protected processGetActivities(
    response: HttpResponseBase
  ): Observable<PaginatedListOfRequestActivityViewVM> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfRequestActivityViewVM.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getProjectActivities(
    from: Date | null | undefined,
    to: Date | null | undefined,
    projectId: string | null | undefined,
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfRequestActivityViewVM> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/activities/GetProjectActivity?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (from !== undefined && from !== null)
      url_ += 'From=' + encodeURIComponent(from ? '' + from.toISOString() : '') + '&';
    if (to !== undefined && to !== null)
      url_ += 'To=' + encodeURIComponent(to ? '' + to.toISOString() : '') + '&';
    if (projectId !== undefined && projectId !== null)
      url_ += 'ProjectId=' + encodeURIComponent('' + projectId) + '&';
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetProjectActivities(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetProjectActivities(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<PaginatedListOfRequestActivityViewVM>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PaginatedListOfRequestActivityViewVM>;
        })
      );
  }

  protected processGetProjectActivities(
    response: HttpResponseBase
  ): Observable<PaginatedListOfRequestActivityViewVM> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfRequestActivityViewVM.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface IAuditLogsClient {
  getPage(
    entityId: string | null | undefined,
    entityType: string | null | undefined,
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfAuditLogVm>;
}

@Injectable({
  providedIn: 'root',
})
export class AuditLogsClient implements IAuditLogsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? '';
  }

  getPage(
    entityId: string | null | undefined,
    entityType: string | null | undefined,
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfAuditLogVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/audit-logs/page?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (entityId !== undefined && entityId !== null)
      url_ += 'entityId=' + encodeURIComponent('' + entityId) + '&';
    if (entityType !== undefined && entityType !== null)
      url_ += 'entityType=' + encodeURIComponent('' + entityType) + '&';
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPage(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<PaginatedListOfAuditLogVm>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PaginatedListOfAuditLogVm>;
        })
      );
  }

  protected processGetPage(
    response: HttpResponseBase
  ): Observable<PaginatedListOfAuditLogVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfAuditLogVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

export interface IBanksClient {
  getBanksAll(apiVersion: string): Observable<BanksDTO[]>;
  getBanks(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfBanksDTO>;
  create(apiVersion: string, data: CreateBankDTO): Observable<HttpResultOfString>;
  update(
    id: string | null | undefined,
    apiVersion: string,
    data: CreateBankDTO
  ): Observable<void>;
  delete(id: string | null | undefined, apiVersion: string): Observable<void>;
  get(id: string, apiVersion: string): Observable<BanksDTO>;
}

@Injectable({
  providedIn: 'root',
})
export class BanksClient implements IBanksClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? '';
  }

  getBanksAll(apiVersion: string): Observable<BanksDTO[]> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/Banks/all';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetBanksAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetBanksAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<BanksDTO[]>;
            }
          } else return _observableThrow(response_) as any as Observable<BanksDTO[]>;
        })
      );
  }

  protected processGetBanksAll(response: HttpResponseBase): Observable<BanksDTO[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(BanksDTO.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getBanks(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfBanksDTO> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/Banks?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetBanks(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetBanks(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<PaginatedListOfBanksDTO>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PaginatedListOfBanksDTO>;
        })
      );
  }

  protected processGetBanks(
    response: HttpResponseBase
  ): Observable<PaginatedListOfBanksDTO> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfBanksDTO.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  create(apiVersion: string, data: CreateBankDTO): Observable<HttpResultOfString> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/Banks';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(data);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<HttpResultOfString>;
            }
          } else
            return _observableThrow(response_) as any as Observable<HttpResultOfString>;
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<HttpResultOfString> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfString.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  update(
    id: string | null | undefined,
    apiVersion: string,
    data: CreateBankDTO
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/Banks?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (id !== undefined && id !== null)
      url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(data);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  delete(id: string | null | undefined, apiVersion: string): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/Banks?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (id !== undefined && id !== null)
      url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  get(id: string, apiVersion: string): Observable<BanksDTO> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/Banks/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<BanksDTO>;
            }
          } else return _observableThrow(response_) as any as Observable<BanksDTO>;
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<BanksDTO> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = BanksDTO.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface IBranchesClient {
  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfBranchPageVm>;
  get(branchId: string, apiVersion: string): Observable<BranchDetailsVm>;
  update(branchId: string, apiVersion: string, request: BranchDto): Observable<void>;
  delete(branchId: string, apiVersion: string): Observable<void>;
  create(apiVersion: string, request: BranchDto): Observable<HttpResultOfString>;
}

@Injectable({
  providedIn: 'root',
})
export class BranchesClient implements IBranchesClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? '';
  }

  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfBranchPageVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/branches/page?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPage(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<PaginatedListOfBranchPageVm>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PaginatedListOfBranchPageVm>;
        })
      );
  }

  protected processGetPage(
    response: HttpResponseBase
  ): Observable<PaginatedListOfBranchPageVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfBranchPageVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  get(branchId: string, apiVersion: string): Observable<BranchDetailsVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/branches/{branchId}';
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace('{branchId}', encodeURIComponent('' + branchId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<BranchDetailsVm>;
            }
          } else return _observableThrow(response_) as any as Observable<BranchDetailsVm>;
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<BranchDetailsVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = BranchDetailsVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  update(branchId: string, apiVersion: string, request: BranchDto): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/branches/{branchId}';
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace('{branchId}', encodeURIComponent('' + branchId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  delete(branchId: string, apiVersion: string): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/branches/{branchId}';
    if (branchId === undefined || branchId === null)
      throw new Error("The parameter 'branchId' must be defined.");
    url_ = url_.replace('{branchId}', encodeURIComponent('' + branchId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  create(apiVersion: string, request: BranchDto): Observable<HttpResultOfString> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/branches';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<HttpResultOfString>;
            }
          } else
            return _observableThrow(response_) as any as Observable<HttpResultOfString>;
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<HttpResultOfString> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfString.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface ICitiesClient {
  getCitiesAll(apiVersion: string): Observable<CityVm[]>;
  getCities(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfCityVm>;
  create(apiVersion: string, data: CityDto): Observable<HttpResultOfString>;
  update(
    id: string | null | undefined,
    apiVersion: string,
    data: CityDto
  ): Observable<void>;
  delete(id: string | null | undefined, apiVersion: string): Observable<void>;
  get(id: string, apiVersion: string): Observable<CityVm>;
}

@Injectable({
  providedIn: 'root',
})
export class CitiesClient implements ICitiesClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? '';
  }

  getCitiesAll(apiVersion: string): Observable<CityVm[]> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/Cities/all';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCitiesAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCitiesAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<CityVm[]>;
            }
          } else return _observableThrow(response_) as any as Observable<CityVm[]>;
        })
      );
  }

  protected processGetCitiesAll(response: HttpResponseBase): Observable<CityVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(CityVm.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getCities(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfCityVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/Cities?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCities(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCities(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<PaginatedListOfCityVm>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PaginatedListOfCityVm>;
        })
      );
  }

  protected processGetCities(
    response: HttpResponseBase
  ): Observable<PaginatedListOfCityVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfCityVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  create(apiVersion: string, data: CityDto): Observable<HttpResultOfString> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/Cities';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(data);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<HttpResultOfString>;
            }
          } else
            return _observableThrow(response_) as any as Observable<HttpResultOfString>;
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<HttpResultOfString> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfString.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  update(
    id: string | null | undefined,
    apiVersion: string,
    data: CityDto
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/Cities?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (id !== undefined && id !== null)
      url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(data);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  delete(id: string | null | undefined, apiVersion: string): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/Cities?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (id !== undefined && id !== null)
      url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  get(id: string, apiVersion: string): Observable<CityVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/Cities/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<CityVm>;
            }
          } else return _observableThrow(response_) as any as Observable<CityVm>;
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<CityVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = CityVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface IClientsClient {
  createClient(apiVersion: string, data: ClientDto): Observable<HttpResultOfString>;
  getClients(
    clientType: ClientType | null | undefined,
    isActive: boolean | null | undefined,
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfClientVm>;
  deleteClient(id: string | null | undefined, apiVersion: string): Observable<string[]>;
  updateClient(id: string, apiVersion: string, data: ClientDto): Observable<FileResponse>;
  getClient(id: string, apiVersion: string): Observable<ClientVm>;
  activateClient(id: string, apiVersion: string): Observable<FileResponse>;
  deactivateClient(id: string, apiVersion: string): Observable<FileResponse>;
  getAllClients(apiVersion: string): Observable<ClientVm[]>;
  getActiveClients(apiVersion: string): Observable<ClientVm[]>;
}

@Injectable({
  providedIn: 'root',
})
export class ClientsClient implements IClientsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? '';
  }

  createClient(apiVersion: string, data: ClientDto): Observable<HttpResultOfString> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/clients';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(data);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateClient(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateClient(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<HttpResultOfString>;
            }
          } else
            return _observableThrow(response_) as any as Observable<HttpResultOfString>;
        })
      );
  }

  protected processCreateClient(
    response: HttpResponseBase
  ): Observable<HttpResultOfString> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfString.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getClients(
    clientType: ClientType | null | undefined,
    isActive: boolean | null | undefined,
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfClientVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/clients?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (clientType !== undefined && clientType !== null)
      url_ += 'ClientType=' + encodeURIComponent('' + clientType) + '&';
    if (isActive !== undefined && isActive !== null)
      url_ += 'IsActive=' + encodeURIComponent('' + isActive) + '&';
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetClients(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetClients(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<PaginatedListOfClientVm>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PaginatedListOfClientVm>;
        })
      );
  }

  protected processGetClients(
    response: HttpResponseBase
  ): Observable<PaginatedListOfClientVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfClientVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  deleteClient(id: string | null | undefined, apiVersion: string): Observable<string[]> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/clients?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (id !== undefined && id !== null)
      url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteClient(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteClient(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<string[]>;
            }
          } else return _observableThrow(response_) as any as Observable<string[]>;
        })
      );
  }

  protected processDeleteClient(response: HttpResponseBase): Observable<string[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(item);
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  updateClient(
    id: string,
    apiVersion: string,
    data: ClientDto
  ): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/clients/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(data);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateClient(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateClient(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processUpdateClient(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getClient(id: string, apiVersion: string): Observable<ClientVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/clients/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetClient(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetClient(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ClientVm>;
            }
          } else return _observableThrow(response_) as any as Observable<ClientVm>;
        })
      );
  }

  protected processGetClient(response: HttpResponseBase): Observable<ClientVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ClientVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  activateClient(id: string, apiVersion: string): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/clients/activate/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processActivateClient(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processActivateClient(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processActivateClient(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  deactivateClient(id: string, apiVersion: string): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/clients/deactivate/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeactivateClient(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeactivateClient(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processDeactivateClient(
    response: HttpResponseBase
  ): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getAllClients(apiVersion: string): Observable<ClientVm[]> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/clients/all';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllClients(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllClients(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ClientVm[]>;
            }
          } else return _observableThrow(response_) as any as Observable<ClientVm[]>;
        })
      );
  }

  protected processGetAllClients(response: HttpResponseBase): Observable<ClientVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ClientVm.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getActiveClients(apiVersion: string): Observable<ClientVm[]> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/clients/active';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetActiveClients(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetActiveClients(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ClientVm[]>;
            }
          } else return _observableThrow(response_) as any as Observable<ClientVm[]>;
        })
      );
  }

  protected processGetActiveClients(response: HttpResponseBase): Observable<ClientVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ClientVm.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface ICommerceChambersClient {
  getAll(apiVersion: string): Observable<CommerceChamberVm[]>;
  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfCommerceChamberVm>;
  create(
    apiVersion: string,
    data: CommerceChamberCreateDto
  ): Observable<HttpResultOfString>;
  update(
    id: string | null | undefined,
    apiVersion: string,
    data: CommerceChamberUpdateDto
  ): Observable<HttpResultOfBoolean>;
  delete(
    id: string | null | undefined,
    apiVersion: string
  ): Observable<HttpResultOfBoolean>;
  get(id: string, apiVersion: string): Observable<CommerceChamberDetailsVm>;
}

@Injectable({
  providedIn: 'root',
})
export class CommerceChambersClient implements ICommerceChambersClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? '';
  }

  getAll(apiVersion: string): Observable<CommerceChamberVm[]> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/commerce-chambers/all';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<CommerceChamberVm[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<CommerceChamberVm[]>;
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<CommerceChamberVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(CommerceChamberVm.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfCommerceChamberVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/commerce-chambers?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPage(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<PaginatedListOfCommerceChamberVm>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PaginatedListOfCommerceChamberVm>;
        })
      );
  }

  protected processGetPage(
    response: HttpResponseBase
  ): Observable<PaginatedListOfCommerceChamberVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfCommerceChamberVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  create(
    apiVersion: string,
    data: CommerceChamberCreateDto
  ): Observable<HttpResultOfString> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/commerce-chambers';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(data);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<HttpResultOfString>;
            }
          } else
            return _observableThrow(response_) as any as Observable<HttpResultOfString>;
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<HttpResultOfString> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfString.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  update(
    id: string | null | undefined,
    apiVersion: string,
    data: CommerceChamberUpdateDto
  ): Observable<HttpResultOfBoolean> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/commerce-chambers?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (id !== undefined && id !== null)
      url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(data);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<HttpResultOfBoolean>;
            }
          } else
            return _observableThrow(response_) as any as Observable<HttpResultOfBoolean>;
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<HttpResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  delete(
    id: string | null | undefined,
    apiVersion: string
  ): Observable<HttpResultOfBoolean> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/commerce-chambers?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (id !== undefined && id !== null)
      url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<HttpResultOfBoolean>;
            }
          } else
            return _observableThrow(response_) as any as Observable<HttpResultOfBoolean>;
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<HttpResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  get(id: string, apiVersion: string): Observable<CommerceChamberDetailsVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/commerce-chambers/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<CommerceChamberDetailsVm>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<CommerceChamberDetailsVm>;
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<CommerceChamberDetailsVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = CommerceChamberDetailsVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface IConnectionsClient {
  generate204(): Observable<void>;
}

@Injectable({
  providedIn: 'root',
})
export class ConnectionsClient implements IConnectionsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? '';
  }

  generate204(): Observable<void> {
    let url_ = this.baseUrl + '/generate_204';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGenerate204(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGenerate204(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processGenerate204(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

export interface IContractClient {
  createContract(
    apiVersion: string,
    data: ContractMainDataDto
  ): Observable<HttpResultOfString>;
  getContractsPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfContractMainDataPageVm>;
  createContractAward(
    apiVersion: string,
    data: ContractAwardInfoDto
  ): Observable<HttpResultOfString>;
  createBankGuarantee(
    apiVersion: string,
    data: BankGuaranteeDto
  ): Observable<HttpResultOfString>;
  getBanks(apiVersion: string): Observable<BankVm[]>;
  createContractDetails(
    apiVersion: string,
    data: ContractDetailsDto
  ): Observable<HttpResultOfString>;
  getContractMainData(id: string, apiVersion: string): Observable<ContractMainDataVm>;
  getContractAwardInfo(id: string, apiVersion: string): Observable<ContractAwardInfoVm>;
  calculateFinalPrice(
    initialTotalPrice: number | undefined,
    discountPercentage: number | undefined,
    vatPercentage: number | undefined,
    apiVersion: string
  ): Observable<number>;
  getContractBankGuarantee(id: string, apiVersion: string): Observable<BankGuaranteeVm>;
  getContractDetails(id: string, apiVersion: string): Observable<ContractDetailsVm>;
  updateContractMainData(
    id: string,
    apiVersion: string,
    data: ContractMainDataDto
  ): Observable<FileResponse>;
  deleteContract(id: string, apiVersion: string): Observable<FileResponse>;
  updateContractAwardData(
    id: string,
    apiVersion: string,
    data: ContractAwardInfoDto
  ): Observable<FileResponse>;
  updateBankGuarantee(
    id: string,
    apiVersion: string,
    data: BankGuaranteeDto
  ): Observable<FileResponse>;
  updateContractDetails(
    id: string,
    apiVersion: string,
    data: ContractDetailsDto
  ): Observable<FileResponse>;
  createFine(apiVersion: string, data: ContractFineDto): Observable<HttpResultOfString>;
  getContractFine(id: string): Observable<ContractFineVm[]>;
  updateContractFine(id: string, data: ContractFineDto): Observable<FileResponse>;
  deleteContractFine(id: string): Observable<FileResponse>;
}

@Injectable({
  providedIn: 'root',
})
export class ContractClient implements IContractClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? '';
  }

  createContract(
    apiVersion: string,
    data: ContractMainDataDto
  ): Observable<HttpResultOfString> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/contracts';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(data);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateContract(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateContract(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<HttpResultOfString>;
            }
          } else
            return _observableThrow(response_) as any as Observable<HttpResultOfString>;
        })
      );
  }

  protected processCreateContract(
    response: HttpResponseBase
  ): Observable<HttpResultOfString> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfString.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getContractsPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfContractMainDataPageVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/contracts?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetContractsPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetContractsPage(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<PaginatedListOfContractMainDataPageVm>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PaginatedListOfContractMainDataPageVm>;
        })
      );
  }

  protected processGetContractsPage(
    response: HttpResponseBase
  ): Observable<PaginatedListOfContractMainDataPageVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfContractMainDataPageVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  createContractAward(
    apiVersion: string,
    data: ContractAwardInfoDto
  ): Observable<HttpResultOfString> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/contracts/award';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(data);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateContractAward(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateContractAward(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<HttpResultOfString>;
            }
          } else
            return _observableThrow(response_) as any as Observable<HttpResultOfString>;
        })
      );
  }

  protected processCreateContractAward(
    response: HttpResponseBase
  ): Observable<HttpResultOfString> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfString.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  createBankGuarantee(
    apiVersion: string,
    data: BankGuaranteeDto
  ): Observable<HttpResultOfString> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/contracts/guarantee';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(data);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateBankGuarantee(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateBankGuarantee(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<HttpResultOfString>;
            }
          } else
            return _observableThrow(response_) as any as Observable<HttpResultOfString>;
        })
      );
  }

  protected processCreateBankGuarantee(
    response: HttpResponseBase
  ): Observable<HttpResultOfString> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfString.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getBanks(apiVersion: string): Observable<BankVm[]> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/contracts/banks';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetBanks(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetBanks(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<BankVm[]>;
            }
          } else return _observableThrow(response_) as any as Observable<BankVm[]>;
        })
      );
  }

  protected processGetBanks(response: HttpResponseBase): Observable<BankVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(BankVm.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  createContractDetails(
    apiVersion: string,
    data: ContractDetailsDto
  ): Observable<HttpResultOfString> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/contracts/details';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(data);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateContractDetails(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateContractDetails(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<HttpResultOfString>;
            }
          } else
            return _observableThrow(response_) as any as Observable<HttpResultOfString>;
        })
      );
  }

  protected processCreateContractDetails(
    response: HttpResponseBase
  ): Observable<HttpResultOfString> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfString.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getContractMainData(id: string, apiVersion: string): Observable<ContractMainDataVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/contracts/{id}/1';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetContractMainData(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetContractMainData(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ContractMainDataVm>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ContractMainDataVm>;
        })
      );
  }

  protected processGetContractMainData(
    response: HttpResponseBase
  ): Observable<ContractMainDataVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ContractMainDataVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getContractAwardInfo(id: string, apiVersion: string): Observable<ContractAwardInfoVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/contracts/{id}/award/2';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetContractAwardInfo(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetContractAwardInfo(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ContractAwardInfoVm>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ContractAwardInfoVm>;
        })
      );
  }

  protected processGetContractAwardInfo(
    response: HttpResponseBase
  ): Observable<ContractAwardInfoVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ContractAwardInfoVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  calculateFinalPrice(
    initialTotalPrice: number | undefined,
    discountPercentage: number | undefined,
    vatPercentage: number | undefined,
    apiVersion: string
  ): Observable<number> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/contracts/calculate/final-price?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (initialTotalPrice === null)
      throw new Error("The parameter 'initialTotalPrice' cannot be null.");
    else if (initialTotalPrice !== undefined)
      url_ += 'initialTotalPrice=' + encodeURIComponent('' + initialTotalPrice) + '&';
    if (discountPercentage === null)
      throw new Error("The parameter 'discountPercentage' cannot be null.");
    else if (discountPercentage !== undefined)
      url_ += 'discountPercentage=' + encodeURIComponent('' + discountPercentage) + '&';
    if (vatPercentage === null)
      throw new Error("The parameter 'vatPercentage' cannot be null.");
    else if (vatPercentage !== undefined)
      url_ += 'vatPercentage=' + encodeURIComponent('' + vatPercentage) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCalculateFinalPrice(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCalculateFinalPrice(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<number>;
            }
          } else return _observableThrow(response_) as any as Observable<number>;
        })
      );
  }

  protected processCalculateFinalPrice(response: HttpResponseBase): Observable<number> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;

          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getContractBankGuarantee(id: string, apiVersion: string): Observable<BankGuaranteeVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/contracts/{id}/guarantee/4';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetContractBankGuarantee(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetContractBankGuarantee(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<BankGuaranteeVm>;
            }
          } else return _observableThrow(response_) as any as Observable<BankGuaranteeVm>;
        })
      );
  }

  protected processGetContractBankGuarantee(
    response: HttpResponseBase
  ): Observable<BankGuaranteeVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = BankGuaranteeVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getContractDetails(id: string, apiVersion: string): Observable<ContractDetailsVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/contracts/{id}/details/5';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetContractDetails(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetContractDetails(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ContractDetailsVm>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ContractDetailsVm>;
        })
      );
  }

  protected processGetContractDetails(
    response: HttpResponseBase
  ): Observable<ContractDetailsVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ContractDetailsVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  updateContractMainData(
    id: string,
    apiVersion: string,
    data: ContractMainDataDto
  ): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/contracts/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(data);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateContractMainData(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateContractMainData(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processUpdateContractMainData(
    response: HttpResponseBase
  ): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  deleteContract(id: string, apiVersion: string): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/contracts/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteContract(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteContract(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processDeleteContract(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  updateContractAwardData(
    id: string,
    apiVersion: string,
    data: ContractAwardInfoDto
  ): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/contracts/{id}/award';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(data);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateContractAwardData(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateContractAwardData(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processUpdateContractAwardData(
    response: HttpResponseBase
  ): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  updateBankGuarantee(
    id: string,
    apiVersion: string,
    data: BankGuaranteeDto
  ): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/contracts/{id}/guarantee';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(data);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateBankGuarantee(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateBankGuarantee(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processUpdateBankGuarantee(
    response: HttpResponseBase
  ): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  updateContractDetails(
    id: string,
    apiVersion: string,
    data: ContractDetailsDto
  ): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/contracts/{id}/details';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(data);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateContractDetails(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateContractDetails(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processUpdateContractDetails(
    response: HttpResponseBase
  ): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  createFine(apiVersion: string, data: ContractFineDto): Observable<HttpResultOfString> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/contracts/fine';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(data);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateFine(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateFine(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<HttpResultOfString>;
            }
          } else
            return _observableThrow(response_) as any as Observable<HttpResultOfString>;
        })
      );
  }

  protected processCreateFine(
    response: HttpResponseBase
  ): Observable<HttpResultOfString> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfString.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getContractFine(id: string): Observable<ContractFineVm[]> {
    let url_ = this.baseUrl + '/{id}/fine/8';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetContractFine(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetContractFine(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ContractFineVm[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ContractFineVm[]>;
        })
      );
  }

  protected processGetContractFine(
    response: HttpResponseBase
  ): Observable<ContractFineVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ContractFineVm.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  updateContractFine(id: string, data: ContractFineDto): Observable<FileResponse> {
    let url_ = this.baseUrl + '/{id}/fine';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(data);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateContractFine(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateContractFine(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processUpdateContractFine(
    response: HttpResponseBase
  ): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  deleteContractFine(id: string): Observable<FileResponse> {
    let url_ = this.baseUrl + '/{id}/fine';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteContractFine(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteContractFine(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processDeleteContractFine(
    response: HttpResponseBase
  ): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

export interface IContractTypesClient {
  getContractTypes(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfContractTypeVm>;
  create(apiVersion: string, data: ContractTypeDto): Observable<HttpResultOfString>;
  update(
    id: string | null | undefined,
    apiVersion: string,
    data: ContractTypeDto
  ): Observable<HttpResultOfBoolean>;
  delete(id: string | null | undefined, apiVersion: string): Observable<FileResponse>;
  getAllContractTypes(apiVersion: string): Observable<ContractTypeVm[]>;
  get(contractTypeId: string, apiVersion: string): Observable<ContractTypeVm>;
}

@Injectable({
  providedIn: 'root',
})
export class ContractTypesClient implements IContractTypesClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? '';
  }

  getContractTypes(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfContractTypeVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/contract-types?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetContractTypes(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetContractTypes(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<PaginatedListOfContractTypeVm>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PaginatedListOfContractTypeVm>;
        })
      );
  }

  protected processGetContractTypes(
    response: HttpResponseBase
  ): Observable<PaginatedListOfContractTypeVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfContractTypeVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  create(apiVersion: string, data: ContractTypeDto): Observable<HttpResultOfString> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/contract-types';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(data);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<HttpResultOfString>;
            }
          } else
            return _observableThrow(response_) as any as Observable<HttpResultOfString>;
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<HttpResultOfString> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfString.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  update(
    id: string | null | undefined,
    apiVersion: string,
    data: ContractTypeDto
  ): Observable<HttpResultOfBoolean> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/contract-types?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (id !== undefined && id !== null)
      url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(data);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<HttpResultOfBoolean>;
            }
          } else
            return _observableThrow(response_) as any as Observable<HttpResultOfBoolean>;
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<HttpResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  delete(id: string | null | undefined, apiVersion: string): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/contract-types?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (id !== undefined && id !== null)
      url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getAllContractTypes(apiVersion: string): Observable<ContractTypeVm[]> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/contract-types/all';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllContractTypes(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllContractTypes(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ContractTypeVm[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ContractTypeVm[]>;
        })
      );
  }

  protected processGetAllContractTypes(
    response: HttpResponseBase
  ): Observable<ContractTypeVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ContractTypeVm.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  get(contractTypeId: string, apiVersion: string): Observable<ContractTypeVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/contract-types/{contractTypeId}';
    if (contractTypeId === undefined || contractTypeId === null)
      throw new Error("The parameter 'contractTypeId' must be defined.");
    url_ = url_.replace('{contractTypeId}', encodeURIComponent('' + contractTypeId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ContractTypeVm>;
            }
          } else return _observableThrow(response_) as any as Observable<ContractTypeVm>;
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<ContractTypeVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ContractTypeVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface ICountriesClient {
  createCountry(apiVersion: string, data: CountriesDto): Observable<string>;
  getCountries(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfCountryDetailsVm>;
  updateCountry(
    id: string | null | undefined,
    apiVersion: string,
    data: CountriesUpdateDto
  ): Observable<FileResponse>;
  getAllCountries(apiVersion: string): Observable<CountryVm[]>;
  updateCountryDetails(
    id: string,
    apiVersion: string,
    data: CountriesDto
  ): Observable<FileResponse>;
  getCountry(id: string, apiVersion: string): Observable<CountryDetailsVm>;
  deleteCountry(id: string, apiVersion: string): Observable<FileResponse>;
}

@Injectable({
  providedIn: 'root',
})
export class CountriesClient implements ICountriesClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? '';
  }

  createCountry(apiVersion: string, data: CountriesDto): Observable<string> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/countries';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(data);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateCountry(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateCountry(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<string>;
            }
          } else return _observableThrow(response_) as any as Observable<string>;
        })
      );
  }

  protected processCreateCountry(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;

          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getCountries(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfCountryDetailsVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/countries?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCountries(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCountries(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<PaginatedListOfCountryDetailsVm>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PaginatedListOfCountryDetailsVm>;
        })
      );
  }

  protected processGetCountries(
    response: HttpResponseBase
  ): Observable<PaginatedListOfCountryDetailsVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfCountryDetailsVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  updateCountry(
    id: string | null | undefined,
    apiVersion: string,
    data: CountriesUpdateDto
  ): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/countries?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (id !== undefined && id !== null)
      url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(data);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateCountry(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateCountry(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processUpdateCountry(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getAllCountries(apiVersion: string): Observable<CountryVm[]> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/countries/all';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAllCountries(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAllCountries(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<CountryVm[]>;
            }
          } else return _observableThrow(response_) as any as Observable<CountryVm[]>;
        })
      );
  }

  protected processGetAllCountries(response: HttpResponseBase): Observable<CountryVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(CountryVm.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  updateCountryDetails(
    id: string,
    apiVersion: string,
    data: CountriesDto
  ): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/countries/{id}/details';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(data);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateCountryDetails(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateCountryDetails(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processUpdateCountryDetails(
    response: HttpResponseBase
  ): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getCountry(id: string, apiVersion: string): Observable<CountryDetailsVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/countries/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetCountry(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetCountry(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<CountryDetailsVm>;
            }
          } else
            return _observableThrow(response_) as any as Observable<CountryDetailsVm>;
        })
      );
  }

  protected processGetCountry(response: HttpResponseBase): Observable<CountryDetailsVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = CountryDetailsVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  deleteCountry(id: string, apiVersion: string): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/countries/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteCountry(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteCountry(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processDeleteCountry(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

export interface ICovenantRequestsClient {
  getDetailsPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    termId: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfCovenantRequestDetailsVm>;
  create(apiVersion: string, request: CovenantRequestDto): Observable<HttpResultOfString>;
  accept(
    requestId: string,
    apiVersion: string,
    request: ChangeCovenantRequestStatusDto
  ): Observable<void>;
  reject(
    requestId: string,
    apiVersion: string,
    request: ChangeCovenantRequestStatusDto
  ): Observable<void>;
  getTransactionsPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    requestId: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfCovenantTransactionRequestVm>;
  addTransactionRequests(
    apiVersion: string,
    request: CovenantTransactionRequestDto[]
  ): Observable<HttpResultOfBoolean>;
}

@Injectable({
  providedIn: 'root',
})
export class CovenantRequestsClient implements ICovenantRequestsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? '';
  }

  getDetailsPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    termId: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfCovenantRequestDetailsVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/covenant-requests/details/page?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    if (termId !== undefined && termId !== null)
      url_ += 'termId=' + encodeURIComponent('' + termId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDetailsPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDetailsPage(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<PaginatedListOfCovenantRequestDetailsVm>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PaginatedListOfCovenantRequestDetailsVm>;
        })
      );
  }

  protected processGetDetailsPage(
    response: HttpResponseBase
  ): Observable<PaginatedListOfCovenantRequestDetailsVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfCovenantRequestDetailsVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  create(
    apiVersion: string,
    request: CovenantRequestDto
  ): Observable<HttpResultOfString> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/covenant-requests';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<HttpResultOfString>;
            }
          } else
            return _observableThrow(response_) as any as Observable<HttpResultOfString>;
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<HttpResultOfString> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfString.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  accept(
    requestId: string,
    apiVersion: string,
    request: ChangeCovenantRequestStatusDto
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/covenant-requests/{requestId}/accept';
    if (requestId === undefined || requestId === null)
      throw new Error("The parameter 'requestId' must be defined.");
    url_ = url_.replace('{requestId}', encodeURIComponent('' + requestId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAccept(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAccept(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processAccept(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  reject(
    requestId: string,
    apiVersion: string,
    request: ChangeCovenantRequestStatusDto
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/covenant-requests/{requestId}/reject';
    if (requestId === undefined || requestId === null)
      throw new Error("The parameter 'requestId' must be defined.");
    url_ = url_.replace('{requestId}', encodeURIComponent('' + requestId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processReject(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processReject(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processReject(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getTransactionsPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    requestId: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfCovenantTransactionRequestVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/covenant-requests/transactions/page?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    if (requestId !== undefined && requestId !== null)
      url_ += 'requestId=' + encodeURIComponent('' + requestId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTransactionsPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTransactionsPage(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<PaginatedListOfCovenantTransactionRequestVm>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PaginatedListOfCovenantTransactionRequestVm>;
        })
      );
  }

  protected processGetTransactionsPage(
    response: HttpResponseBase
  ): Observable<PaginatedListOfCovenantTransactionRequestVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfCovenantTransactionRequestVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  addTransactionRequests(
    apiVersion: string,
    request: CovenantTransactionRequestDto[]
  ): Observable<HttpResultOfBoolean> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/covenant-requests/transactions';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddTransactionRequests(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddTransactionRequests(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<HttpResultOfBoolean>;
            }
          } else
            return _observableThrow(response_) as any as Observable<HttpResultOfBoolean>;
        })
      );
  }

  protected processAddTransactionRequests(
    response: HttpResponseBase
  ): Observable<HttpResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface IDashboardReportsControllersClient {
  getRequestsSummary(apiVersion: string): Observable<RequestsSummaryVM[]>;
  getFinancialPositionSummary(
    apiVersion: string
  ): Observable<FinancialPositionSummaryVM[]>;
  getTasksSummary(apiVersion: string): Observable<TasksSummaryVM[]>;
  getTimelineProjectsSummary(apiVersion: string): Observable<TimelineSummaryVM[]>;
  getDataSummary(apiVersion: string): Observable<DataSummaryView>;
  getExpensesSummary(
    year: number | null | undefined,
    apiVersion: string
  ): Observable<ExpensesVM[]>;
}

@Injectable({
  providedIn: 'root',
})
export class DashboardReportsControllersClient
  implements IDashboardReportsControllersClient
{
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? '';
  }

  getRequestsSummary(apiVersion: string): Observable<RequestsSummaryVM[]> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/dashboard-reports/requests-summary';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRequestsSummary(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRequestsSummary(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<RequestsSummaryVM[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<RequestsSummaryVM[]>;
        })
      );
  }

  protected processGetRequestsSummary(
    response: HttpResponseBase
  ): Observable<RequestsSummaryVM[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(RequestsSummaryVM.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getFinancialPositionSummary(
    apiVersion: string
  ): Observable<FinancialPositionSummaryVM[]> {
    let url_ =
      this.baseUrl + '/api/v{apiVersion}/dashboard-reports/financial-position-summary';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetFinancialPositionSummary(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetFinancialPositionSummary(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<
                FinancialPositionSummaryVM[]
              >;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              FinancialPositionSummaryVM[]
            >;
        })
      );
  }

  protected processGetFinancialPositionSummary(
    response: HttpResponseBase
  ): Observable<FinancialPositionSummaryVM[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(FinancialPositionSummaryVM.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getTasksSummary(apiVersion: string): Observable<TasksSummaryVM[]> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/dashboard-reports/tasks-summary';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTasksSummary(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTasksSummary(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<TasksSummaryVM[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<TasksSummaryVM[]>;
        })
      );
  }

  protected processGetTasksSummary(
    response: HttpResponseBase
  ): Observable<TasksSummaryVM[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(TasksSummaryVM.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getTimelineProjectsSummary(apiVersion: string): Observable<TimelineSummaryVM[]> {
    let url_ =
      this.baseUrl + '/api/v{apiVersion}/dashboard-reports/timeline-projects-summary';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTimelineProjectsSummary(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTimelineProjectsSummary(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<TimelineSummaryVM[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<TimelineSummaryVM[]>;
        })
      );
  }

  protected processGetTimelineProjectsSummary(
    response: HttpResponseBase
  ): Observable<TimelineSummaryVM[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(TimelineSummaryVM.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getDataSummary(apiVersion: string): Observable<DataSummaryView> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/dashboard-reports/data-summary';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDataSummary(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDataSummary(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<DataSummaryView>;
            }
          } else return _observableThrow(response_) as any as Observable<DataSummaryView>;
        })
      );
  }

  protected processGetDataSummary(
    response: HttpResponseBase
  ): Observable<DataSummaryView> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = DataSummaryView.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getExpensesSummary(
    year: number | null | undefined,
    apiVersion: string
  ): Observable<ExpensesVM[]> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/dashboard-reports/expenses-summary?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (year !== undefined && year !== null)
      url_ += 'year=' + encodeURIComponent('' + year) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetExpensesSummary(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetExpensesSummary(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ExpensesVM[]>;
            }
          } else return _observableThrow(response_) as any as Observable<ExpensesVM[]>;
        })
      );
  }

  protected processGetExpensesSummary(
    response: HttpResponseBase
  ): Observable<ExpensesVM[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ExpensesVM.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface IDelegationsClient {
  getAll(apiVersion: string): Observable<DelegationVm[]>;
  create(apiVersion: string, data: DelegationDto): Observable<HttpResultOfString>;
  update(
    id: string | null | undefined,
    apiVersion: string,
    data: DelegationDto
  ): Observable<FileResponse>;
  delete(
    id: string | null | undefined,
    apiVersion: string
  ): Observable<HttpResultOfBoolean>;
  getByContract(contractId: string, apiVersion: string): Observable<DelegationVm>;
}

@Injectable({
  providedIn: 'root',
})
export class DelegationsClient implements IDelegationsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? '';
  }

  getAll(apiVersion: string): Observable<DelegationVm[]> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/commerce-chambers/delegations';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<DelegationVm[]>;
            }
          } else return _observableThrow(response_) as any as Observable<DelegationVm[]>;
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<DelegationVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(DelegationVm.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  create(apiVersion: string, data: DelegationDto): Observable<HttpResultOfString> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/commerce-chambers/delegations';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(data);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<HttpResultOfString>;
            }
          } else
            return _observableThrow(response_) as any as Observable<HttpResultOfString>;
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<HttpResultOfString> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfString.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  update(
    id: string | null | undefined,
    apiVersion: string,
    data: DelegationDto
  ): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/commerce-chambers/delegations?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (id !== undefined && id !== null)
      url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(data);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  delete(
    id: string | null | undefined,
    apiVersion: string
  ): Observable<HttpResultOfBoolean> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/commerce-chambers/delegations?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (id !== undefined && id !== null)
      url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<HttpResultOfBoolean>;
            }
          } else
            return _observableThrow(response_) as any as Observable<HttpResultOfBoolean>;
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<HttpResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getByContract(contractId: string, apiVersion: string): Observable<DelegationVm> {
    let url_ =
      this.baseUrl + '/api/v{apiVersion}/commerce-chambers/delegations/{contractId}/3';
    if (contractId === undefined || contractId === null)
      throw new Error("The parameter 'contractId' must be defined.");
    url_ = url_.replace('{contractId}', encodeURIComponent('' + contractId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetByContract(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetByContract(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<DelegationVm>;
            }
          } else return _observableThrow(response_) as any as Observable<DelegationVm>;
        })
      );
  }

  protected processGetByContract(response: HttpResponseBase): Observable<DelegationVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = DelegationVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface IExtractRequestsClient {
  get(requestId: string, apiVersion: string): Observable<ExtractRequestDetailsVm>;
  getLastByTermId(
    termId: string,
    apiVersion: string
  ): Observable<ExtractRequestDetailsVm>;
  getDetailsPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    termId: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfExtractRequestDetailsVm>;
  create(apiVersion: string, request: ExtractRequestDto): Observable<HttpResultOfString>;
  calculate(
    requestId: string,
    apiVersion: string,
    request: ExtractRequestCalculateDto
  ): Observable<ExtractRequestDetailsCalculateVm>;
  update(
    requestId: string,
    apiVersion: string,
    request: ExtractRequestUpdateDto
  ): Observable<void>;
  accept(
    requestId: string,
    apiVersion: string,
    request: ChangeExtractRequestStatusDto
  ): Observable<void>;
  reject(
    requestId: string,
    apiVersion: string,
    request: ChangeExtractRequestStatusDto
  ): Observable<void>;
  addTransactionRequests(
    apiVersion: string,
    request: ExtractRequestTransactionReqeustsDto
  ): Observable<HttpResultOfBoolean>;
}

@Injectable({
  providedIn: 'root',
})
export class ExtractRequestsClient implements IExtractRequestsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? '';
  }

  get(requestId: string, apiVersion: string): Observable<ExtractRequestDetailsVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/extract-requests/{requestId}';
    if (requestId === undefined || requestId === null)
      throw new Error("The parameter 'requestId' must be defined.");
    url_ = url_.replace('{requestId}', encodeURIComponent('' + requestId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ExtractRequestDetailsVm>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<ExtractRequestDetailsVm>;
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<ExtractRequestDetailsVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ExtractRequestDetailsVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getLastByTermId(
    termId: string,
    apiVersion: string
  ): Observable<ExtractRequestDetailsVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/extract-requests/last/{termId}';
    if (termId === undefined || termId === null)
      throw new Error("The parameter 'termId' must be defined.");
    url_ = url_.replace('{termId}', encodeURIComponent('' + termId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetLastByTermId(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetLastByTermId(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ExtractRequestDetailsVm>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<ExtractRequestDetailsVm>;
        })
      );
  }

  protected processGetLastByTermId(
    response: HttpResponseBase
  ): Observable<ExtractRequestDetailsVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ExtractRequestDetailsVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getDetailsPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    termId: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfExtractRequestDetailsVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/extract-requests/details/page?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    if (termId !== undefined && termId !== null)
      url_ += 'termId=' + encodeURIComponent('' + termId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDetailsPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDetailsPage(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<PaginatedListOfExtractRequestDetailsVm>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PaginatedListOfExtractRequestDetailsVm>;
        })
      );
  }

  protected processGetDetailsPage(
    response: HttpResponseBase
  ): Observable<PaginatedListOfExtractRequestDetailsVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfExtractRequestDetailsVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  create(apiVersion: string, request: ExtractRequestDto): Observable<HttpResultOfString> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/extract-requests';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<HttpResultOfString>;
            }
          } else
            return _observableThrow(response_) as any as Observable<HttpResultOfString>;
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<HttpResultOfString> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfString.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  calculate(
    requestId: string,
    apiVersion: string,
    request: ExtractRequestCalculateDto
  ): Observable<ExtractRequestDetailsCalculateVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/extract-requests/{requestId}/calculate';
    if (requestId === undefined || requestId === null)
      throw new Error("The parameter 'requestId' must be defined.");
    url_ = url_.replace('{requestId}', encodeURIComponent('' + requestId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCalculate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCalculate(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<ExtractRequestDetailsCalculateVm>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<ExtractRequestDetailsCalculateVm>;
        })
      );
  }

  protected processCalculate(
    response: HttpResponseBase
  ): Observable<ExtractRequestDetailsCalculateVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ExtractRequestDetailsCalculateVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  update(
    requestId: string,
    apiVersion: string,
    request: ExtractRequestUpdateDto
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/extract-requests/{requestId}/update';
    if (requestId === undefined || requestId === null)
      throw new Error("The parameter 'requestId' must be defined.");
    url_ = url_.replace('{requestId}', encodeURIComponent('' + requestId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  accept(
    requestId: string,
    apiVersion: string,
    request: ChangeExtractRequestStatusDto
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/extract-requests/{requestId}/accept';
    if (requestId === undefined || requestId === null)
      throw new Error("The parameter 'requestId' must be defined.");
    url_ = url_.replace('{requestId}', encodeURIComponent('' + requestId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAccept(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAccept(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processAccept(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  reject(
    requestId: string,
    apiVersion: string,
    request: ChangeExtractRequestStatusDto
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/extract-requests/{requestId}/reject';
    if (requestId === undefined || requestId === null)
      throw new Error("The parameter 'requestId' must be defined.");
    url_ = url_.replace('{requestId}', encodeURIComponent('' + requestId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processReject(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processReject(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processReject(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  addTransactionRequests(
    apiVersion: string,
    request: ExtractRequestTransactionReqeustsDto
  ): Observable<HttpResultOfBoolean> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/extract-requests/transactions';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddTransactionRequests(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddTransactionRequests(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<HttpResultOfBoolean>;
            }
          } else
            return _observableThrow(response_) as any as Observable<HttpResultOfBoolean>;
        })
      );
  }

  protected processAddTransactionRequests(
    response: HttpResponseBase
  ): Observable<HttpResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface IFilesClient {
  get(
    projectId: string | null | undefined,
    apiVersion: string
  ): Observable<FileDetails[]>;
  create(
    type: AttachmentType | undefined,
    contractId: string | null | undefined,
    stepNumber: number | undefined,
    apiVersion: string,
    media: FileParameter[] | null | undefined
  ): Observable<ValueTupleOfStringAndString[]>;
  delete(
    type: AttachmentType | undefined,
    contractId: string | null | undefined,
    stepNumber: number | undefined,
    filesName: string[] | null | undefined,
    apiVersion: string
  ): Observable<FileResponse>;
  download(
    projectId: string | null | undefined,
    fileName: string | null | undefined,
    apiVersion: string
  ): Observable<Stream>;
  uploadProjectFile(
    projectId: string | null | undefined,
    apiVersion: string,
    media: FileParameter[] | null | undefined
  ): Observable<ValueTupleOfStringAndString[]>;
  deleteProjectFile(
    projectId: string | null | undefined,
    filesName: string[] | null | undefined,
    apiVersion: string
  ): Observable<FileResponse>;
}

@Injectable({
  providedIn: 'root',
})
export class FilesClient implements IFilesClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? '';
  }

  get(
    projectId: string | null | undefined,
    apiVersion: string
  ): Observable<FileDetails[]> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/files/project-files-names?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (projectId !== undefined && projectId !== null)
      url_ += 'projectId=' + encodeURIComponent('' + projectId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileDetails[]>;
            }
          } else return _observableThrow(response_) as any as Observable<FileDetails[]>;
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<FileDetails[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(FileDetails.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  create(
    type: AttachmentType | undefined,
    contractId: string | null | undefined,
    stepNumber: number | undefined,
    apiVersion: string,
    media: FileParameter[] | null | undefined
  ): Observable<ValueTupleOfStringAndString[]> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/files?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (type === null) throw new Error("The parameter 'type' cannot be null.");
    else if (type !== undefined) url_ += 'type=' + encodeURIComponent('' + type) + '&';
    if (contractId !== undefined && contractId !== null)
      url_ += 'contractId=' + encodeURIComponent('' + contractId) + '&';
    if (stepNumber === null)
      throw new Error("The parameter 'stepNumber' cannot be null.");
    else if (stepNumber !== undefined)
      url_ += 'stepNumber=' + encodeURIComponent('' + stepNumber) + '&';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = new FormData();
    if (media !== null && media !== undefined)
      media.forEach((item_) =>
        content_.append('media', item_.data, item_.fileName ? item_.fileName : 'media')
      );

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<
                ValueTupleOfStringAndString[]
              >;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              ValueTupleOfStringAndString[]
            >;
        })
      );
  }

  protected processCreate(
    response: HttpResponseBase
  ): Observable<ValueTupleOfStringAndString[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(ValueTupleOfStringAndString.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  delete(
    type: AttachmentType | undefined,
    contractId: string | null | undefined,
    stepNumber: number | undefined,
    filesName: string[] | null | undefined,
    apiVersion: string
  ): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/files?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (type === null) throw new Error("The parameter 'type' cannot be null.");
    else if (type !== undefined) url_ += 'type=' + encodeURIComponent('' + type) + '&';
    if (contractId !== undefined && contractId !== null)
      url_ += 'contractId=' + encodeURIComponent('' + contractId) + '&';
    if (stepNumber === null)
      throw new Error("The parameter 'stepNumber' cannot be null.");
    else if (stepNumber !== undefined)
      url_ += 'stepNumber=' + encodeURIComponent('' + stepNumber) + '&';
    if (filesName !== undefined && filesName !== null)
      filesName &&
        filesName.forEach((item) => {
          url_ += 'filesName=' + encodeURIComponent('' + item) + '&';
        });
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  download(
    projectId: string | null | undefined,
    fileName: string | null | undefined,
    apiVersion: string
  ): Observable<Stream> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/files/download-project-file?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (projectId !== undefined && projectId !== null)
      url_ += 'projectId=' + encodeURIComponent('' + projectId) + '&';
    if (fileName !== undefined && fileName !== null)
      url_ += 'fileName=' + encodeURIComponent('' + fileName) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDownload(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDownload(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<Stream>;
            }
          } else return _observableThrow(response_) as any as Observable<Stream>;
        })
      );
  }

  protected processDownload(response: HttpResponseBase): Observable<Stream> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = Stream.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  uploadProjectFile(
    projectId: string | null | undefined,
    apiVersion: string,
    media: FileParameter[] | null | undefined
  ): Observable<ValueTupleOfStringAndString[]> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/files/upload-project-file?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (projectId !== undefined && projectId !== null)
      url_ += 'projectId=' + encodeURIComponent('' + projectId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = new FormData();
    if (media !== null && media !== undefined)
      media.forEach((item_) =>
        content_.append('media', item_.data, item_.fileName ? item_.fileName : 'media')
      );

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUploadProjectFile(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUploadProjectFile(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<
                ValueTupleOfStringAndString[]
              >;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              ValueTupleOfStringAndString[]
            >;
        })
      );
  }

  protected processUploadProjectFile(
    response: HttpResponseBase
  ): Observable<ValueTupleOfStringAndString[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(ValueTupleOfStringAndString.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  deleteProjectFile(
    projectId: string | null | undefined,
    filesName: string[] | null | undefined,
    apiVersion: string
  ): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/files/delete-project-file?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (projectId !== undefined && projectId !== null)
      url_ += 'projectId=' + encodeURIComponent('' + projectId) + '&';
    if (filesName !== undefined && filesName !== null)
      filesName &&
        filesName.forEach((item) => {
          url_ += 'filesName=' + encodeURIComponent('' + item) + '&';
        });
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteProjectFile(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteProjectFile(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processDeleteProjectFile(
    response: HttpResponseBase
  ): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

export interface IIdentityClient {
  refreshToken(
    apiVersion: string,
    command: RefreshTokenCommand
  ): Observable<AuthResponse>;
  login(apiVersion: string, command: LoginCommand): Observable<AuthResponse>;
  login2fa(
    apiVersion: string,
    command: LoginTwoFactorAuthenticationCommand
  ): Observable<AuthResponse>;
  externalLogin(
    apiVersion: string,
    command: ExternalLoginCommand
  ): Observable<AuthResponse>;
  resetPassword(
    apiVersion: string,
    command: ResetPasswordCommand
  ): Observable<AuthResponse>;
  forgetPassword(apiVersion: string, command: ForgetPasswordCommand): Observable<void>;
  logout(apiVersion: string): Observable<void>;
}

@Injectable({
  providedIn: 'root',
})
export class IdentityClient implements IIdentityClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? '';
  }

  refreshToken(
    apiVersion: string,
    command: RefreshTokenCommand
  ): Observable<AuthResponse> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/identity/refresh-token';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRefreshToken(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRefreshToken(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<AuthResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<AuthResponse>;
        })
      );
  }

  protected processRefreshToken(response: HttpResponseBase): Observable<AuthResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AuthResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  login(apiVersion: string, command: LoginCommand): Observable<AuthResponse> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/identity/login';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processLogin(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processLogin(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<AuthResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<AuthResponse>;
        })
      );
  }

  protected processLogin(response: HttpResponseBase): Observable<AuthResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AuthResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  login2fa(
    apiVersion: string,
    command: LoginTwoFactorAuthenticationCommand
  ): Observable<AuthResponse> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/identity/login-2fa';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processLogin2fa(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processLogin2fa(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<AuthResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<AuthResponse>;
        })
      );
  }

  protected processLogin2fa(response: HttpResponseBase): Observable<AuthResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AuthResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  externalLogin(
    apiVersion: string,
    command: ExternalLoginCommand
  ): Observable<AuthResponse> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/identity/external-login';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processExternalLogin(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processExternalLogin(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<AuthResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<AuthResponse>;
        })
      );
  }

  protected processExternalLogin(response: HttpResponseBase): Observable<AuthResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AuthResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  resetPassword(
    apiVersion: string,
    command: ResetPasswordCommand
  ): Observable<AuthResponse> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/identity/reset-password';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processResetPassword(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processResetPassword(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<AuthResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<AuthResponse>;
        })
      );
  }

  protected processResetPassword(response: HttpResponseBase): Observable<AuthResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AuthResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  forgetPassword(apiVersion: string, command: ForgetPasswordCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/identity/forget-password';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processForgetPassword(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processForgetPassword(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processForgetPassword(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  logout(apiVersion: string): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/identity/logout';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processLogout(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processLogout(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processLogout(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface IMaterialsClient {
  create(apiVersion: string, data: MaterialDto): Observable<HttpResultOfString>;
  getMaterials(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfMaterialVm>;
  update(id: string, apiVersion: string, data: MaterialDto): Observable<void>;
  getAll(apiVersion: string): Observable<MaterialVm[]>;
  get(materialId: string, apiVersion: string): Observable<MaterialVm>;
  delete(materialId: string, apiVersion: string): Observable<void>;
}

@Injectable({
  providedIn: 'root',
})
export class MaterialsClient implements IMaterialsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? '';
  }

  create(apiVersion: string, data: MaterialDto): Observable<HttpResultOfString> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/materials';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(data);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<HttpResultOfString>;
            }
          } else
            return _observableThrow(response_) as any as Observable<HttpResultOfString>;
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<HttpResultOfString> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfString.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getMaterials(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfMaterialVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/materials?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetMaterials(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetMaterials(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<PaginatedListOfMaterialVm>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PaginatedListOfMaterialVm>;
        })
      );
  }

  protected processGetMaterials(
    response: HttpResponseBase
  ): Observable<PaginatedListOfMaterialVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfMaterialVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  update(id: string, apiVersion: string, data: MaterialDto): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/materials/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(data);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getAll(apiVersion: string): Observable<MaterialVm[]> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/materials/All';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<MaterialVm[]>;
            }
          } else return _observableThrow(response_) as any as Observable<MaterialVm[]>;
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<MaterialVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(MaterialVm.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  get(materialId: string, apiVersion: string): Observable<MaterialVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/materials/{materialId}';
    if (materialId === undefined || materialId === null)
      throw new Error("The parameter 'materialId' must be defined.");
    url_ = url_.replace('{materialId}', encodeURIComponent('' + materialId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<MaterialVm>;
            }
          } else return _observableThrow(response_) as any as Observable<MaterialVm>;
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<MaterialVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = MaterialVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  delete(materialId: string, apiVersion: string): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/materials/{materialId}';
    if (materialId === undefined || materialId === null)
      throw new Error("The parameter 'materialId' must be defined.");
    url_ = url_.replace('{materialId}', encodeURIComponent('' + materialId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface IMeasurementUnitsClient {
  getAll(apiVersion: string): Observable<MeasurementUnitVm[]>;
  getMeasurementsUnits(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfMeasurementUnitVm>;
  create(apiVersion: string, data: MeasurementUnitDto): Observable<HttpResultOfString>;
  update(
    id: string | null | undefined,
    apiVersion: string,
    data: MeasurementUnitDto
  ): Observable<void>;
  delete(id: string | null | undefined, apiVersion: string): Observable<void>;
  get(measurementUnitId: string, apiVersion: string): Observable<MeasurementUnitVm>;
}

@Injectable({
  providedIn: 'root',
})
export class MeasurementUnitsClient implements IMeasurementUnitsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? '';
  }

  getAll(apiVersion: string): Observable<MeasurementUnitVm[]> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/measurements-units/All';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<MeasurementUnitVm[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<MeasurementUnitVm[]>;
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<MeasurementUnitVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(MeasurementUnitVm.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getMeasurementsUnits(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfMeasurementUnitVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/measurements-units?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetMeasurementsUnits(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetMeasurementsUnits(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<PaginatedListOfMeasurementUnitVm>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PaginatedListOfMeasurementUnitVm>;
        })
      );
  }

  protected processGetMeasurementsUnits(
    response: HttpResponseBase
  ): Observable<PaginatedListOfMeasurementUnitVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfMeasurementUnitVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  create(apiVersion: string, data: MeasurementUnitDto): Observable<HttpResultOfString> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/measurements-units';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(data);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<HttpResultOfString>;
            }
          } else
            return _observableThrow(response_) as any as Observable<HttpResultOfString>;
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<HttpResultOfString> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfString.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  update(
    id: string | null | undefined,
    apiVersion: string,
    data: MeasurementUnitDto
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/measurements-units?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (id !== undefined && id !== null)
      url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(data);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  delete(id: string | null | undefined, apiVersion: string): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/measurements-units?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (id !== undefined && id !== null)
      url_ += 'id=' + encodeURIComponent('' + id) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  get(measurementUnitId: string, apiVersion: string): Observable<MeasurementUnitVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/measurements-units/{measurementUnitId}';
    if (measurementUnitId === undefined || measurementUnitId === null)
      throw new Error("The parameter 'measurementUnitId' must be defined.");
    url_ = url_.replace(
      '{measurementUnitId}',
      encodeURIComponent('' + measurementUnitId)
    );
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<MeasurementUnitVm>;
            }
          } else
            return _observableThrow(response_) as any as Observable<MeasurementUnitVm>;
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<MeasurementUnitVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = MeasurementUnitVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface INotificationsClient {
  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfNotificationVm>;
  getNotReadCount(apiVersion: string): Observable<HttpResultOfInteger>;
  read(notificationId: string, apiVersion: string): Observable<void>;
}

@Injectable({
  providedIn: 'root',
})
export class NotificationsClient implements INotificationsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? '';
  }

  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfNotificationVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/notifications/page?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPage(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<PaginatedListOfNotificationVm>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PaginatedListOfNotificationVm>;
        })
      );
  }

  protected processGetPage(
    response: HttpResponseBase
  ): Observable<PaginatedListOfNotificationVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfNotificationVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getNotReadCount(apiVersion: string): Observable<HttpResultOfInteger> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/notifications/not-read-count';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetNotReadCount(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetNotReadCount(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<HttpResultOfInteger>;
            }
          } else
            return _observableThrow(response_) as any as Observable<HttpResultOfInteger>;
        })
      );
  }

  protected processGetNotReadCount(
    response: HttpResponseBase
  ): Observable<HttpResultOfInteger> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfInteger.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  read(notificationId: string, apiVersion: string): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/notifications/{notificationId}/read';
    if (notificationId === undefined || notificationId === null)
      throw new Error("The parameter 'notificationId' must be defined.");
    url_ = url_.replace('{notificationId}', encodeURIComponent('' + notificationId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRead(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRead(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processRead(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface IPriceRequestsApprovalsClient {
  getPage(
    termId: string | null | undefined,
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfPriceApprovalRequestVm>;
  get(requestId: string, apiVersion: string): Observable<PriceApprovalRequestDetailsVm>;
  getDetailsPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    termId: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfPriceApprovalRequestDetailsVm>;
  create(
    apiVersion: string,
    request: PriceApprovalRequestDto
  ): Observable<HttpResultOfString>;
  accept(
    requestId: string,
    apiVersion: string,
    request: ChangePriceApprovalRequestStatusDto
  ): Observable<void>;
  reject(
    requestId: string,
    apiVersion: string,
    request: ChangePriceApprovalRequestStatusDto
  ): Observable<void>;
  cancel(requestId: string, apiVersion: string): Observable<void>;
}

@Injectable({
  providedIn: 'root',
})
export class PriceRequestsApprovalsClient implements IPriceRequestsApprovalsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? '';
  }

  getPage(
    termId: string | null | undefined,
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfPriceApprovalRequestVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/price-approvals/page?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (termId !== undefined && termId !== null)
      url_ += 'termId=' + encodeURIComponent('' + termId) + '&';
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPage(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<PaginatedListOfPriceApprovalRequestVm>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PaginatedListOfPriceApprovalRequestVm>;
        })
      );
  }

  protected processGetPage(
    response: HttpResponseBase
  ): Observable<PaginatedListOfPriceApprovalRequestVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfPriceApprovalRequestVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  get(requestId: string, apiVersion: string): Observable<PriceApprovalRequestDetailsVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/price-approvals/{requestId}';
    if (requestId === undefined || requestId === null)
      throw new Error("The parameter 'requestId' must be defined.");
    url_ = url_.replace('{requestId}', encodeURIComponent('' + requestId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<PriceApprovalRequestDetailsVm>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PriceApprovalRequestDetailsVm>;
        })
      );
  }

  protected processGet(
    response: HttpResponseBase
  ): Observable<PriceApprovalRequestDetailsVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PriceApprovalRequestDetailsVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getDetailsPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    termId: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfPriceApprovalRequestDetailsVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/price-approvals/details/page?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    if (termId !== undefined && termId !== null)
      url_ += 'termId=' + encodeURIComponent('' + termId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDetailsPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDetailsPage(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<PaginatedListOfPriceApprovalRequestDetailsVm>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PaginatedListOfPriceApprovalRequestDetailsVm>;
        })
      );
  }

  protected processGetDetailsPage(
    response: HttpResponseBase
  ): Observable<PaginatedListOfPriceApprovalRequestDetailsVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfPriceApprovalRequestDetailsVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  create(
    apiVersion: string,
    request: PriceApprovalRequestDto
  ): Observable<HttpResultOfString> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/price-approvals';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<HttpResultOfString>;
            }
          } else
            return _observableThrow(response_) as any as Observable<HttpResultOfString>;
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<HttpResultOfString> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfString.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  accept(
    requestId: string,
    apiVersion: string,
    request: ChangePriceApprovalRequestStatusDto
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/price-approvals/{requestId}/accept';
    if (requestId === undefined || requestId === null)
      throw new Error("The parameter 'requestId' must be defined.");
    url_ = url_.replace('{requestId}', encodeURIComponent('' + requestId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAccept(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAccept(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processAccept(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  reject(
    requestId: string,
    apiVersion: string,
    request: ChangePriceApprovalRequestStatusDto
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/price-approvals/{requestId}/reject';
    if (requestId === undefined || requestId === null)
      throw new Error("The parameter 'requestId' must be defined.");
    url_ = url_.replace('{requestId}', encodeURIComponent('' + requestId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processReject(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processReject(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processReject(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  cancel(requestId: string, apiVersion: string): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/price-approvals/{requestId}/delete';
    if (requestId === undefined || requestId === null)
      throw new Error("The parameter 'requestId' must be defined.");
    url_ = url_.replace('{requestId}', encodeURIComponent('' + requestId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCancel(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCancel(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processCancel(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface IProfileClient {
  get(apiVersion: string): Observable<AccountDetailsVm>;
  changeProfile(apiVersion: string, command: ChangeProfileCommand): Observable<void>;
  changePicture(
    apiVersion: string,
    picture: FileParameter | null | undefined
  ): Observable<void>;
  changeEmail(apiVersion: string, command: ChangeEmailCommand): Observable<void>;
  changePassword(apiVersion: string, command: ChangePasswordCommand): Observable<void>;
  changeLanguage(apiVersion: string, command: ChangeLanguageCommand): Observable<void>;
}

@Injectable({
  providedIn: 'root',
})
export class ProfileClient implements IProfileClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? '';
  }

  get(apiVersion: string): Observable<AccountDetailsVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/profile';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<AccountDetailsVm>;
            }
          } else
            return _observableThrow(response_) as any as Observable<AccountDetailsVm>;
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<AccountDetailsVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AccountDetailsVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  changeProfile(apiVersion: string, command: ChangeProfileCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/profile';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processChangeProfile(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processChangeProfile(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processChangeProfile(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  changePicture(
    apiVersion: string,
    picture: FileParameter | null | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/profile/change-picture';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = new FormData();
    if (picture !== null && picture !== undefined)
      content_.append(
        'Picture',
        picture.data,
        picture.fileName ? picture.fileName : 'Picture'
      );

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processChangePicture(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processChangePicture(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processChangePicture(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  changeEmail(apiVersion: string, command: ChangeEmailCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/profile/change-email';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processChangeEmail(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processChangeEmail(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processChangeEmail(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  changePassword(apiVersion: string, command: ChangePasswordCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/profile/change-credentials';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processChangePassword(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processChangePassword(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processChangePassword(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  changeLanguage(apiVersion: string, command: ChangeLanguageCommand): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/profile/change-language';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(command);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processChangeLanguage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processChangeLanguage(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface IProjectsClient {
  getProject(id: string, apiVersion: string): Observable<ContractProjectVm[]>;
  getProjectMainData(id: string, apiVersion: string): Observable<ProjectMainDataVm[]>;
  getProjectQuantity(id: string, apiVersion: string): Observable<ProjectQuantityVm>;
  getProjectQuantitiesPage(
    projectId: string | null | undefined,
    businessType: BusinessType | null | undefined,
    isSpecificUser: boolean | null | undefined,
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfProjectQuantityVm>;
  getProjectDetails(id: string, apiVersion: string): Observable<ProjectDetailsVm>;
  updateProjectDetails(
    id: string,
    apiVersion: string,
    data: ProjectDetailsDto
  ): Observable<FileResponse>;
  getProjectVAT(id: string, apiVersion: string): Observable<ProjectVatVm>;
  getProjectsListing(
    status: ProjectStatus | null | undefined,
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfProjectListingVm>;
  getAll(apiVersion: string): Observable<ProjectDropdownVm[]>;
  getProjectsStatus(apiVersion: string): Observable<ProjectsStatusVm>;
  autoCompleteProjectQuantity(
    projectId: string,
    query: string | null | undefined,
    apiVersion: string
  ): Observable<ProjectQuantityAutoCompleteVm[]>;
  getProjectAssignees(
    projectId: string,
    apiVersion: string
  ): Observable<ProjectAssignees>;
  getProjectAssigneesDetails(
    projectId: string,
    apiVersion: string
  ): Observable<ProjectAssigneeDetailsVm[]>;
  getProjectModifiedDataData(
    projectId: string,
    apiVersion: string
  ): Observable<ProjectModifiedDataVm>;
  getProjectQuantitiesBulk(
    apiVersion: string,
    projectId: string,
    ids: string[]
  ): Observable<ProjectQuantityAutoCompleteVm[]>;
  createProject(apiVersion: string, data: ProjectDto): Observable<HttpResultOfString>;
  updateProject(
    id: string,
    apiVersion: string,
    data: ProjectDto
  ): Observable<FileResponse>;
  deleteProject(id: string, apiVersion: string): Observable<HttpResultOfBoolean>;
  createProjectQuantity(
    contractId: string | null | undefined,
    apiVersion: string,
    data: ProjectQuantityDto
  ): Observable<HttpResultOfString>;
  addQuantitiesByExcel(
    apiVersion: string,
    file: FileParameter | null | undefined,
    data_ContractId: string | null | undefined,
    data_ProjectId: string | null | undefined,
    data_SavingType: string | null | undefined
  ): Observable<FileResponse>;
  downloadMeasurementUnitsTemplate(apiVersion: string): Observable<FileResponse>;
  uploadProjectQuantities(
    projectId: string | null | undefined,
    apiVersion: string
  ): Observable<FileResponse>;
  assignUserToProject(
    projectId: string,
    apiVersion: string,
    data: AssignUserDto
  ): Observable<FileResponse>;
  assignManagerToProject(
    projectId: string,
    apiVersion: string,
    data: AssignUserDto
  ): Observable<FileResponse>;
  assignUsersToProject(
    projectId: string,
    apiVersion: string,
    data: AssignUserDto[]
  ): Observable<FileResponse>;
  removeUserFromProject(
    projectId: string,
    apiVersion: string,
    data: AssignUserDto
  ): Observable<FileResponse>;
  updateProjectQuantity(
    id: string,
    apiVersion: string,
    data: ProjectQuantityDto
  ): Observable<FileResponse>;
  deleteProjectQuantity(id: string, apiVersion: string): Observable<HttpResultOfBoolean>;
  getFinancialPositionSummary(
    projectId: string | null | undefined,
    apiVersion: string
  ): Observable<FinancialPositionSummaryVM[]>;
  getRequestsSummary(
    projectId: string | null | undefined,
    apiVersion: string
  ): Observable<RequestsSummaryVM[]>;
  getTimelineProjectsSummary(
    projectId: string | null | undefined,
    apiVersion: string
  ): Observable<TimelineSummaryVM[]>;
  getTasksSummary(
    projectId: string | null | undefined,
    apiVersion: string
  ): Observable<TasksSummaryVM[]>;
  getProjectTaskSummary(
    projectId: string | null | undefined,
    apiVersion: string
  ): Observable<ProjectTasksSummaryVM>;
  getExpensesSummary(
    projectId: string | null | undefined,
    year: number | null | undefined,
    apiVersion: string
  ): Observable<ExpensesVM[]>;
}

@Injectable({
  providedIn: 'root',
})
export class ProjectsClient implements IProjectsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? '';
  }

  getProject(id: string, apiVersion: string): Observable<ContractProjectVm[]> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/projects/{id}/6';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetProject(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetProject(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ContractProjectVm[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ContractProjectVm[]>;
        })
      );
  }

  protected processGetProject(
    response: HttpResponseBase
  ): Observable<ContractProjectVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(ContractProjectVm.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getProjectMainData(id: string, apiVersion: string): Observable<ProjectMainDataVm[]> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/projects/project-main-data/{id}/6';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetProjectMainData(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetProjectMainData(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProjectMainDataVm[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ProjectMainDataVm[]>;
        })
      );
  }

  protected processGetProjectMainData(
    response: HttpResponseBase
  ): Observable<ProjectMainDataVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(ProjectMainDataVm.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getProjectQuantity(id: string, apiVersion: string): Observable<ProjectQuantityVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/projects/quantity/{id}/7';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetProjectQuantity(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetProjectQuantity(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProjectQuantityVm>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ProjectQuantityVm>;
        })
      );
  }

  protected processGetProjectQuantity(
    response: HttpResponseBase
  ): Observable<ProjectQuantityVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ProjectQuantityVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getProjectQuantitiesPage(
    projectId: string | null | undefined,
    businessType: BusinessType | null | undefined,
    isSpecificUser: boolean | null | undefined,
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfProjectQuantityVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/projects/projectQuantities/7?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (projectId !== undefined && projectId !== null)
      url_ += 'ProjectId=' + encodeURIComponent('' + projectId) + '&';
    if (businessType !== undefined && businessType !== null)
      url_ += 'BusinessType=' + encodeURIComponent('' + businessType) + '&';
    if (isSpecificUser !== undefined && isSpecificUser !== null)
      url_ += 'IsSpecificUser=' + encodeURIComponent('' + isSpecificUser) + '&';
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetProjectQuantitiesPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetProjectQuantitiesPage(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<PaginatedListOfProjectQuantityVm>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PaginatedListOfProjectQuantityVm>;
        })
      );
  }

  protected processGetProjectQuantitiesPage(
    response: HttpResponseBase
  ): Observable<PaginatedListOfProjectQuantityVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfProjectQuantityVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getProjectDetails(id: string, apiVersion: string): Observable<ProjectDetailsVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/projects/{id}/details';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetProjectDetails(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetProjectDetails(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProjectDetailsVm>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ProjectDetailsVm>;
        })
      );
  }

  protected processGetProjectDetails(
    response: HttpResponseBase
  ): Observable<ProjectDetailsVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ProjectDetailsVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  updateProjectDetails(
    id: string,
    apiVersion: string,
    data: ProjectDetailsDto
  ): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/projects/{id}/details';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(data);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateProjectDetails(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateProjectDetails(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processUpdateProjectDetails(
    response: HttpResponseBase
  ): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getProjectVAT(id: string, apiVersion: string): Observable<ProjectVatVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/projects/{id}/vat';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetProjectVAT(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetProjectVAT(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProjectVatVm>;
            }
          } else return _observableThrow(response_) as any as Observable<ProjectVatVm>;
        })
      );
  }

  protected processGetProjectVAT(response: HttpResponseBase): Observable<ProjectVatVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ProjectVatVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getProjectsListing(
    status: ProjectStatus | null | undefined,
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfProjectListingVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/projects/listing?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (status !== undefined && status !== null)
      url_ += 'status=' + encodeURIComponent('' + status) + '&';
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetProjectsListing(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetProjectsListing(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<PaginatedListOfProjectListingVm>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PaginatedListOfProjectListingVm>;
        })
      );
  }

  protected processGetProjectsListing(
    response: HttpResponseBase
  ): Observable<PaginatedListOfProjectListingVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfProjectListingVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getAll(apiVersion: string): Observable<ProjectDropdownVm[]> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/projects/all';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAll(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAll(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProjectDropdownVm[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ProjectDropdownVm[]>;
        })
      );
  }

  protected processGetAll(response: HttpResponseBase): Observable<ProjectDropdownVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(ProjectDropdownVm.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getProjectsStatus(apiVersion: string): Observable<ProjectsStatusVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/projects/status';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetProjectsStatus(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetProjectsStatus(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProjectsStatusVm>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ProjectsStatusVm>;
        })
      );
  }

  protected processGetProjectsStatus(
    response: HttpResponseBase
  ): Observable<ProjectsStatusVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ProjectsStatusVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  autoCompleteProjectQuantity(
    projectId: string,
    query: string | null | undefined,
    apiVersion: string
  ): Observable<ProjectQuantityAutoCompleteVm[]> {
    let url_ =
      this.baseUrl +
      '/api/v{apiVersion}/projects/{projectId}/project-quantities/auto-complete?';
    if (projectId === undefined || projectId === null)
      throw new Error("The parameter 'projectId' must be defined.");
    url_ = url_.replace('{projectId}', encodeURIComponent('' + projectId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (query !== undefined && query !== null)
      url_ += 'query=' + encodeURIComponent('' + query) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAutoCompleteProjectQuantity(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAutoCompleteProjectQuantity(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<
                ProjectQuantityAutoCompleteVm[]
              >;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              ProjectQuantityAutoCompleteVm[]
            >;
        })
      );
  }

  protected processAutoCompleteProjectQuantity(
    response: HttpResponseBase
  ): Observable<ProjectQuantityAutoCompleteVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(ProjectQuantityAutoCompleteVm.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getProjectAssignees(
    projectId: string,
    apiVersion: string
  ): Observable<ProjectAssignees> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/projects/{projectId}/project-assignees';
    if (projectId === undefined || projectId === null)
      throw new Error("The parameter 'projectId' must be defined.");
    url_ = url_.replace('{projectId}', encodeURIComponent('' + projectId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetProjectAssignees(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetProjectAssignees(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProjectAssignees>;
            }
          } else
            return _observableThrow(response_) as any as Observable<ProjectAssignees>;
        })
      );
  }

  protected processGetProjectAssignees(
    response: HttpResponseBase
  ): Observable<ProjectAssignees> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ProjectAssignees.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getProjectAssigneesDetails(
    projectId: string,
    apiVersion: string
  ): Observable<ProjectAssigneeDetailsVm[]> {
    let url_ =
      this.baseUrl + '/api/v{apiVersion}/projects/{projectId}/project-assignees-details';
    if (projectId === undefined || projectId === null)
      throw new Error("The parameter 'projectId' must be defined.");
    url_ = url_.replace('{projectId}', encodeURIComponent('' + projectId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetProjectAssigneesDetails(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetProjectAssigneesDetails(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProjectAssigneeDetailsVm[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              ProjectAssigneeDetailsVm[]
            >;
        })
      );
  }

  protected processGetProjectAssigneesDetails(
    response: HttpResponseBase
  ): Observable<ProjectAssigneeDetailsVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(ProjectAssigneeDetailsVm.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getProjectModifiedDataData(
    projectId: string,
    apiVersion: string
  ): Observable<ProjectModifiedDataVm> {
    let url_ =
      this.baseUrl + '/api/v{apiVersion}/projects/{projectId}/project-modified-data';
    if (projectId === undefined || projectId === null)
      throw new Error("The parameter 'projectId' must be defined.");
    url_ = url_.replace('{projectId}', encodeURIComponent('' + projectId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetProjectModifiedDataData(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetProjectModifiedDataData(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProjectModifiedDataVm>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<ProjectModifiedDataVm>;
        })
      );
  }

  protected processGetProjectModifiedDataData(
    response: HttpResponseBase
  ): Observable<ProjectModifiedDataVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ProjectModifiedDataVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getProjectQuantitiesBulk(
    apiVersion: string,
    projectId: string,
    ids: string[]
  ): Observable<ProjectQuantityAutoCompleteVm[]> {
    let url_ =
      this.baseUrl + '/api/v{apiVersion}/projects/{projectId}/project-quantities/bulk';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (projectId === undefined || projectId === null)
      throw new Error("The parameter 'projectId' must be defined.");
    url_ = url_.replace('{projectId}', encodeURIComponent('' + projectId));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(ids);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetProjectQuantitiesBulk(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetProjectQuantitiesBulk(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<
                ProjectQuantityAutoCompleteVm[]
              >;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              ProjectQuantityAutoCompleteVm[]
            >;
        })
      );
  }

  protected processGetProjectQuantitiesBulk(
    response: HttpResponseBase
  ): Observable<ProjectQuantityAutoCompleteVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(ProjectQuantityAutoCompleteVm.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  createProject(apiVersion: string, data: ProjectDto): Observable<HttpResultOfString> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/projects';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(data);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateProject(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateProject(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<HttpResultOfString>;
            }
          } else
            return _observableThrow(response_) as any as Observable<HttpResultOfString>;
        })
      );
  }

  protected processCreateProject(
    response: HttpResponseBase
  ): Observable<HttpResultOfString> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfString.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  updateProject(
    id: string,
    apiVersion: string,
    data: ProjectDto
  ): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/projects/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(data);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateProject(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateProject(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processUpdateProject(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  deleteProject(id: string, apiVersion: string): Observable<HttpResultOfBoolean> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/projects/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteProject(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteProject(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<HttpResultOfBoolean>;
            }
          } else
            return _observableThrow(response_) as any as Observable<HttpResultOfBoolean>;
        })
      );
  }

  protected processDeleteProject(
    response: HttpResponseBase
  ): Observable<HttpResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  createProjectQuantity(
    contractId: string | null | undefined,
    apiVersion: string,
    data: ProjectQuantityDto
  ): Observable<HttpResultOfString> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/projects/projectQuantity?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (contractId !== undefined && contractId !== null)
      url_ += 'contractId=' + encodeURIComponent('' + contractId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(data);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateProjectQuantity(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateProjectQuantity(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<HttpResultOfString>;
            }
          } else
            return _observableThrow(response_) as any as Observable<HttpResultOfString>;
        })
      );
  }

  protected processCreateProjectQuantity(
    response: HttpResponseBase
  ): Observable<HttpResultOfString> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfString.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  addQuantitiesByExcel(
    apiVersion: string,
    file: FileParameter | null | undefined,
    data_ContractId: string | null | undefined,
    data_ProjectId: string | null | undefined,
    data_SavingType: string | null | undefined
  ): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/projects/add-quantities-by-excel';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = new FormData();
    if (file !== null && file !== undefined)
      content_.append('File', file.data, file.fileName ? file.fileName : 'File');
    if (data_ContractId !== null && data_ContractId !== undefined)
      content_.append('Data.ContractId', data_ContractId.toString());
    if (data_ProjectId !== null && data_ProjectId !== undefined)
      content_.append('Data.ProjectId', data_ProjectId.toString());
    if (data_SavingType !== null && data_SavingType !== undefined)
      content_.append('Data.SavingType', data_SavingType.toString());

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddQuantitiesByExcel(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddQuantitiesByExcel(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processAddQuantitiesByExcel(
    response: HttpResponseBase
  ): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  downloadMeasurementUnitsTemplate(apiVersion: string): Observable<FileResponse> {
    let url_ =
      this.baseUrl + '/api/v{apiVersion}/projects/download-measurement-units-template';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDownloadMeasurementUnitsTemplate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDownloadMeasurementUnitsTemplate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processDownloadMeasurementUnitsTemplate(
    response: HttpResponseBase
  ): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  uploadProjectQuantities(
    projectId: string | null | undefined,
    apiVersion: string
  ): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/projects/download-project-quantities?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (projectId !== undefined && projectId !== null)
      url_ += 'projectId=' + encodeURIComponent('' + projectId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUploadProjectQuantities(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUploadProjectQuantities(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processUploadProjectQuantities(
    response: HttpResponseBase
  ): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  assignUserToProject(
    projectId: string,
    apiVersion: string,
    data: AssignUserDto
  ): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/projects/{projectId}/assign-user';
    if (projectId === undefined || projectId === null)
      throw new Error("The parameter 'projectId' must be defined.");
    url_ = url_.replace('{projectId}', encodeURIComponent('' + projectId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(data);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAssignUserToProject(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAssignUserToProject(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processAssignUserToProject(
    response: HttpResponseBase
  ): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  assignManagerToProject(
    projectId: string,
    apiVersion: string,
    data: AssignUserDto
  ): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/projects/{projectId}/assign-manager';
    if (projectId === undefined || projectId === null)
      throw new Error("The parameter 'projectId' must be defined.");
    url_ = url_.replace('{projectId}', encodeURIComponent('' + projectId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(data);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAssignManagerToProject(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAssignManagerToProject(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processAssignManagerToProject(
    response: HttpResponseBase
  ): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  assignUsersToProject(
    projectId: string,
    apiVersion: string,
    data: AssignUserDto[]
  ): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/projects/{projectId}/assign-users';
    if (projectId === undefined || projectId === null)
      throw new Error("The parameter 'projectId' must be defined.");
    url_ = url_.replace('{projectId}', encodeURIComponent('' + projectId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(data);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAssignUsersToProject(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAssignUsersToProject(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processAssignUsersToProject(
    response: HttpResponseBase
  ): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  removeUserFromProject(
    projectId: string,
    apiVersion: string,
    data: AssignUserDto
  ): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/projects/{projectId}/remove-user';
    if (projectId === undefined || projectId === null)
      throw new Error("The parameter 'projectId' must be defined.");
    url_ = url_.replace('{projectId}', encodeURIComponent('' + projectId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(data);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRemoveUserFromProject(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRemoveUserFromProject(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processRemoveUserFromProject(
    response: HttpResponseBase
  ): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  updateProjectQuantity(
    id: string,
    apiVersion: string,
    data: ProjectQuantityDto
  ): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/projects/project-quantities/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(data);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateProjectQuantity(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateProjectQuantity(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processUpdateProjectQuantity(
    response: HttpResponseBase
  ): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  deleteProjectQuantity(id: string, apiVersion: string): Observable<HttpResultOfBoolean> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/projects/project-quantities/{id}';
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace('{id}', encodeURIComponent('' + id));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteProjectQuantity(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteProjectQuantity(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<HttpResultOfBoolean>;
            }
          } else
            return _observableThrow(response_) as any as Observable<HttpResultOfBoolean>;
        })
      );
  }

  protected processDeleteProjectQuantity(
    response: HttpResponseBase
  ): Observable<HttpResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getFinancialPositionSummary(
    projectId: string | null | undefined,
    apiVersion: string
  ): Observable<FinancialPositionSummaryVM[]> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/projects/financial-position-summary?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (projectId !== undefined && projectId !== null)
      url_ += 'projectId=' + encodeURIComponent('' + projectId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetFinancialPositionSummary(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetFinancialPositionSummary(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<
                FinancialPositionSummaryVM[]
              >;
            }
          } else
            return _observableThrow(response_) as any as Observable<
              FinancialPositionSummaryVM[]
            >;
        })
      );
  }

  protected processGetFinancialPositionSummary(
    response: HttpResponseBase
  ): Observable<FinancialPositionSummaryVM[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(FinancialPositionSummaryVM.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getRequestsSummary(
    projectId: string | null | undefined,
    apiVersion: string
  ): Observable<RequestsSummaryVM[]> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/projects/requests-summary?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (projectId !== undefined && projectId !== null)
      url_ += 'projectId=' + encodeURIComponent('' + projectId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRequestsSummary(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRequestsSummary(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<RequestsSummaryVM[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<RequestsSummaryVM[]>;
        })
      );
  }

  protected processGetRequestsSummary(
    response: HttpResponseBase
  ): Observable<RequestsSummaryVM[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(RequestsSummaryVM.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getTimelineProjectsSummary(
    projectId: string | null | undefined,
    apiVersion: string
  ): Observable<TimelineSummaryVM[]> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/projects/timeline-projects-summary?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (projectId !== undefined && projectId !== null)
      url_ += 'projectId=' + encodeURIComponent('' + projectId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTimelineProjectsSummary(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTimelineProjectsSummary(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<TimelineSummaryVM[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<TimelineSummaryVM[]>;
        })
      );
  }

  protected processGetTimelineProjectsSummary(
    response: HttpResponseBase
  ): Observable<TimelineSummaryVM[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(TimelineSummaryVM.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getTasksSummary(
    projectId: string | null | undefined,
    apiVersion: string
  ): Observable<TasksSummaryVM[]> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/projects/tasks-summary?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (projectId !== undefined && projectId !== null)
      url_ += 'projectId=' + encodeURIComponent('' + projectId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTasksSummary(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTasksSummary(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<TasksSummaryVM[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<TasksSummaryVM[]>;
        })
      );
  }

  protected processGetTasksSummary(
    response: HttpResponseBase
  ): Observable<TasksSummaryVM[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(TasksSummaryVM.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getProjectTaskSummary(
    projectId: string | null | undefined,
    apiVersion: string
  ): Observable<ProjectTasksSummaryVM> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/projects/tasks-project-summary?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (projectId !== undefined && projectId !== null)
      url_ += 'projectId=' + encodeURIComponent('' + projectId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetProjectTaskSummary(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetProjectTaskSummary(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ProjectTasksSummaryVM>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<ProjectTasksSummaryVM>;
        })
      );
  }

  protected processGetProjectTaskSummary(
    response: HttpResponseBase
  ): Observable<ProjectTasksSummaryVM> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ProjectTasksSummaryVM.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getExpensesSummary(
    projectId: string | null | undefined,
    year: number | null | undefined,
    apiVersion: string
  ): Observable<ExpensesVM[]> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/projects/expenses-summary?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (projectId !== undefined && projectId !== null)
      url_ += 'projectId=' + encodeURIComponent('' + projectId) + '&';
    if (year !== undefined && year !== null)
      url_ += 'year=' + encodeURIComponent('' + year) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetExpensesSummary(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetExpensesSummary(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<ExpensesVM[]>;
            }
          } else return _observableThrow(response_) as any as Observable<ExpensesVM[]>;
        })
      );
  }

  protected processGetExpensesSummary(
    response: HttpResponseBase
  ): Observable<ExpensesVM[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(ExpensesVM.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

export interface IScriptsClient {
  random(): Observable<string>;
  update(
    username: string | null | undefined,
    pat: string | null | undefined
  ): Observable<FileResponse>;
}

@Injectable({
  providedIn: 'root',
})
export class ScriptsClient implements IScriptsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? '';
  }

  random(): Observable<string> {
    let url_ = this.baseUrl + '/random';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRandom(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRandom(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<string>;
            }
          } else return _observableThrow(response_) as any as Observable<string>;
        })
      );
  }

  protected processRandom(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;

          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  update(
    username: string | null | undefined,
    pat: string | null | undefined
  ): Observable<FileResponse> {
    let url_ = this.baseUrl + '/update?';
    if (username !== undefined && username !== null)
      url_ += 'username=' + encodeURIComponent('' + username) + '&';
    if (pat !== undefined && pat !== null)
      url_ += 'pat=' + encodeURIComponent('' + pat) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

export interface IStorageClient {
  getRelated(delimiter: string, apiVersion: string): Observable<FileAttachmentDto[]>;
  getAttachment(uniqueKey: string, apiVersion: string): Observable<string>;
  download(uniqueKey: string, apiVersion: string): Observable<FileResponse>;
  upload(
    apiVersion: string,
    files: StorageFile[] | null | undefined,
    attachmentType: string | null | undefined,
    entityId: string | null | undefined
  ): Observable<FileResponse>;
  deleteStorageFile(apiVersion: string, data: StorageFileDto): Observable<FileResponse>;
}

@Injectable({
  providedIn: 'root',
})
export class StorageClient implements IStorageClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? '';
  }

  getRelated(delimiter: string, apiVersion: string): Observable<FileAttachmentDto[]> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/storage/{delimiter}/related';
    if (delimiter === undefined || delimiter === null)
      throw new Error("The parameter 'delimiter' must be defined.");
    url_ = url_.replace('{delimiter}', encodeURIComponent('' + delimiter));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetRelated(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetRelated(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileAttachmentDto[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<FileAttachmentDto[]>;
        })
      );
  }

  protected processGetRelated(
    response: HttpResponseBase
  ): Observable<FileAttachmentDto[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(FileAttachmentDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getAttachment(uniqueKey: string, apiVersion: string): Observable<string> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/storage/{uniqueKey}';
    if (uniqueKey === undefined || uniqueKey === null)
      throw new Error("The parameter 'uniqueKey' must be defined.");
    url_ = url_.replace('{uniqueKey}', encodeURIComponent('' + uniqueKey));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAttachment(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAttachment(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<string>;
            }
          } else return _observableThrow(response_) as any as Observable<string>;
        })
      );
  }

  protected processGetAttachment(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;

          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  download(uniqueKey: string, apiVersion: string): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/storage/{uniqueKey}/download';
    if (uniqueKey === undefined || uniqueKey === null)
      throw new Error("The parameter 'uniqueKey' must be defined.");
    url_ = url_.replace('{uniqueKey}', encodeURIComponent('' + uniqueKey));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDownload(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDownload(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processDownload(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  upload(
    apiVersion: string,
    files: StorageFile[] | null | undefined,
    attachmentType: string | null | undefined,
    entityId: string | null | undefined
  ): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/storage/upload';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = new FormData();
    if (files !== null && files !== undefined)
      files.forEach((item_) => content_.append('Files', item_.toString()));
    if (attachmentType !== null && attachmentType !== undefined)
      content_.append('AttachmentType', attachmentType.toString());
    if (entityId !== null && entityId !== undefined)
      content_.append('EntityId', entityId.toString());

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpload(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpload(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processUpload(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  deleteStorageFile(apiVersion: string, data: StorageFileDto): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/storage/delete-storage';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(data);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteStorageFile(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteStorageFile(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processDeleteStorageFile(
    response: HttpResponseBase
  ): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

export interface ISupplierApprovalsClient {
  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfSupplierApprovalRequestVm>;
  get(
    requestId: string,
    apiVersion: string
  ): Observable<SupplierApprovalRequestDetailsVm>;
  create(
    apiVersion: string,
    request: SupplierApprovalRequestDto
  ): Observable<HttpResultOfString>;
  accept(
    requestId: string,
    apiVersion: string,
    request: ChangeSupplierApprovalRequestStatusDto
  ): Observable<void>;
  reject(
    requestId: string,
    apiVersion: string,
    request: ChangeSupplierApprovalRequestStatusDto
  ): Observable<void>;
  update(
    requestId: string,
    apiVersion: string,
    request: SupplierApprovalRequestDto
  ): Observable<void>;
  delete(requestId: string, apiVersion: string): Observable<void>;
}

@Injectable({
  providedIn: 'root',
})
export class SupplierApprovalsClient implements ISupplierApprovalsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? '';
  }

  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfSupplierApprovalRequestVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/supplier-approvals/page?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPage(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<PaginatedListOfSupplierApprovalRequestVm>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PaginatedListOfSupplierApprovalRequestVm>;
        })
      );
  }

  protected processGetPage(
    response: HttpResponseBase
  ): Observable<PaginatedListOfSupplierApprovalRequestVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfSupplierApprovalRequestVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  get(
    requestId: string,
    apiVersion: string
  ): Observable<SupplierApprovalRequestDetailsVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/supplier-approvals/{requestId}';
    if (requestId === undefined || requestId === null)
      throw new Error("The parameter 'requestId' must be defined.");
    url_ = url_.replace('{requestId}', encodeURIComponent('' + requestId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<SupplierApprovalRequestDetailsVm>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<SupplierApprovalRequestDetailsVm>;
        })
      );
  }

  protected processGet(
    response: HttpResponseBase
  ): Observable<SupplierApprovalRequestDetailsVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SupplierApprovalRequestDetailsVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  create(
    apiVersion: string,
    request: SupplierApprovalRequestDto
  ): Observable<HttpResultOfString> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/supplier-approvals';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<HttpResultOfString>;
            }
          } else
            return _observableThrow(response_) as any as Observable<HttpResultOfString>;
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<HttpResultOfString> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfString.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  accept(
    requestId: string,
    apiVersion: string,
    request: ChangeSupplierApprovalRequestStatusDto
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/supplier-approvals/{requestId}/accept';
    if (requestId === undefined || requestId === null)
      throw new Error("The parameter 'requestId' must be defined.");
    url_ = url_.replace('{requestId}', encodeURIComponent('' + requestId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAccept(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAccept(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processAccept(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  reject(
    requestId: string,
    apiVersion: string,
    request: ChangeSupplierApprovalRequestStatusDto
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/supplier-approvals/{requestId}/reject';
    if (requestId === undefined || requestId === null)
      throw new Error("The parameter 'requestId' must be defined.");
    url_ = url_.replace('{requestId}', encodeURIComponent('' + requestId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processReject(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processReject(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processReject(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  update(
    requestId: string,
    apiVersion: string,
    request: SupplierApprovalRequestDto
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/supplier-approvals/{requestId}/update';
    if (requestId === undefined || requestId === null)
      throw new Error("The parameter 'requestId' must be defined.");
    url_ = url_.replace('{requestId}', encodeURIComponent('' + requestId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  delete(requestId: string, apiVersion: string): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/supplier-approvals/{requestId}/delete';
    if (requestId === undefined || requestId === null)
      throw new Error("The parameter 'requestId' must be defined.");
    url_ = url_.replace('{requestId}', encodeURIComponent('' + requestId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface ISuppliersClient {
  getPage(
    supplierType: SupplierType | null | undefined,
    serviceType: ServiceType | null | undefined,
    status: boolean | null | undefined,
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfSupplierPageVm>;
  get(supplierId: string, apiVersion: string): Observable<SupplierDetailsVm>;
  update(supplierId: string, apiVersion: string, request: SupplierDto): Observable<void>;
  delete(supplierId: string, apiVersion: string): Observable<void>;
  create(apiVersion: string, request: SupplierDto): Observable<HttpResultOfString>;
  activate(supplierId: string, apiVersion: string): Observable<void>;
  deactivate(supplierId: string, apiVersion: string): Observable<void>;
}

@Injectable({
  providedIn: 'root',
})
export class SuppliersClient implements ISuppliersClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? '';
  }

  getPage(
    supplierType: SupplierType | null | undefined,
    serviceType: ServiceType | null | undefined,
    status: boolean | null | undefined,
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfSupplierPageVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/suppliers/page?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (supplierType !== undefined && supplierType !== null)
      url_ += 'supplierType=' + encodeURIComponent('' + supplierType) + '&';
    if (serviceType !== undefined && serviceType !== null)
      url_ += 'serviceType=' + encodeURIComponent('' + serviceType) + '&';
    if (status !== undefined && status !== null)
      url_ += 'status=' + encodeURIComponent('' + status) + '&';
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPage(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<PaginatedListOfSupplierPageVm>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PaginatedListOfSupplierPageVm>;
        })
      );
  }

  protected processGetPage(
    response: HttpResponseBase
  ): Observable<PaginatedListOfSupplierPageVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfSupplierPageVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  get(supplierId: string, apiVersion: string): Observable<SupplierDetailsVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/suppliers/{supplierId}';
    if (supplierId === undefined || supplierId === null)
      throw new Error("The parameter 'supplierId' must be defined.");
    url_ = url_.replace('{supplierId}', encodeURIComponent('' + supplierId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<SupplierDetailsVm>;
            }
          } else
            return _observableThrow(response_) as any as Observable<SupplierDetailsVm>;
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<SupplierDetailsVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SupplierDetailsVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  update(supplierId: string, apiVersion: string, request: SupplierDto): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/suppliers/{supplierId}';
    if (supplierId === undefined || supplierId === null)
      throw new Error("The parameter 'supplierId' must be defined.");
    url_ = url_.replace('{supplierId}', encodeURIComponent('' + supplierId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  delete(supplierId: string, apiVersion: string): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/suppliers/{supplierId}';
    if (supplierId === undefined || supplierId === null)
      throw new Error("The parameter 'supplierId' must be defined.");
    url_ = url_.replace('{supplierId}', encodeURIComponent('' + supplierId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDelete(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDelete(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  create(apiVersion: string, request: SupplierDto): Observable<HttpResultOfString> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/suppliers';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<HttpResultOfString>;
            }
          } else
            return _observableThrow(response_) as any as Observable<HttpResultOfString>;
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<HttpResultOfString> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfString.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  activate(supplierId: string, apiVersion: string): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/suppliers/activate/{supplierId}';
    if (supplierId === undefined || supplierId === null)
      throw new Error("The parameter 'supplierId' must be defined.");
    url_ = url_.replace('{supplierId}', encodeURIComponent('' + supplierId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processActivate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processActivate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processActivate(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  deactivate(supplierId: string, apiVersion: string): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/suppliers/deactivate/{supplierId}';
    if (supplierId === undefined || supplierId === null)
      throw new Error("The parameter 'supplierId' must be defined.");
    url_ = url_.replace('{supplierId}', encodeURIComponent('' + supplierId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeactivate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeactivate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDeactivate(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface ISupplyRequestsApprovalsClient {
  getPage(
    termId: string | null | undefined,
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfSupplyApprovalRequestVm>;
  get(requestId: string, apiVersion: string): Observable<SupplyApprovalRequestDetailsVm>;
  getDetailsPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    termId: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfSupplyApprovalRequestDetailsVm>;
  create(
    apiVersion: string,
    request: SupplyApprovalRequestDto
  ): Observable<HttpResultOfString>;
  accept(
    requestId: string,
    apiVersion: string,
    request: ChangeSupplyApprovalRequestStatusDto
  ): Observable<void>;
  reject(
    requestId: string,
    apiVersion: string,
    request: ChangeSupplyApprovalRequestStatusDto
  ): Observable<void>;
  addTransactionRequests(
    apiVersion: string,
    request: SupplyApprovalRequestTransactionReqeustsDto
  ): Observable<HttpResultOfBoolean>;
}

@Injectable({
  providedIn: 'root',
})
export class SupplyRequestsApprovalsClient implements ISupplyRequestsApprovalsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? '';
  }

  getPage(
    termId: string | null | undefined,
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfSupplyApprovalRequestVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/supply-approvals/page?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (termId !== undefined && termId !== null)
      url_ += 'termId=' + encodeURIComponent('' + termId) + '&';
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPage(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<PaginatedListOfSupplyApprovalRequestVm>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PaginatedListOfSupplyApprovalRequestVm>;
        })
      );
  }

  protected processGetPage(
    response: HttpResponseBase
  ): Observable<PaginatedListOfSupplyApprovalRequestVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfSupplyApprovalRequestVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  get(requestId: string, apiVersion: string): Observable<SupplyApprovalRequestDetailsVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/supply-approvals/{requestId}';
    if (requestId === undefined || requestId === null)
      throw new Error("The parameter 'requestId' must be defined.");
    url_ = url_.replace('{requestId}', encodeURIComponent('' + requestId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<SupplyApprovalRequestDetailsVm>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<SupplyApprovalRequestDetailsVm>;
        })
      );
  }

  protected processGet(
    response: HttpResponseBase
  ): Observable<SupplyApprovalRequestDetailsVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SupplyApprovalRequestDetailsVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getDetailsPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    termId: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfSupplyApprovalRequestDetailsVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/supply-approvals/details/page?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    if (termId !== undefined && termId !== null)
      url_ += 'termId=' + encodeURIComponent('' + termId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDetailsPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDetailsPage(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<PaginatedListOfSupplyApprovalRequestDetailsVm>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PaginatedListOfSupplyApprovalRequestDetailsVm>;
        })
      );
  }

  protected processGetDetailsPage(
    response: HttpResponseBase
  ): Observable<PaginatedListOfSupplyApprovalRequestDetailsVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfSupplyApprovalRequestDetailsVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  create(
    apiVersion: string,
    request: SupplyApprovalRequestDto
  ): Observable<HttpResultOfString> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/supply-approvals';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<HttpResultOfString>;
            }
          } else
            return _observableThrow(response_) as any as Observable<HttpResultOfString>;
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<HttpResultOfString> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfString.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  accept(
    requestId: string,
    apiVersion: string,
    request: ChangeSupplyApprovalRequestStatusDto
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/supply-approvals/{requestId}/accept';
    if (requestId === undefined || requestId === null)
      throw new Error("The parameter 'requestId' must be defined.");
    url_ = url_.replace('{requestId}', encodeURIComponent('' + requestId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAccept(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAccept(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processAccept(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  reject(
    requestId: string,
    apiVersion: string,
    request: ChangeSupplyApprovalRequestStatusDto
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/supply-approvals/{requestId}/reject';
    if (requestId === undefined || requestId === null)
      throw new Error("The parameter 'requestId' must be defined.");
    url_ = url_.replace('{requestId}', encodeURIComponent('' + requestId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processReject(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processReject(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processReject(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  addTransactionRequests(
    apiVersion: string,
    request: SupplyApprovalRequestTransactionReqeustsDto
  ): Observable<HttpResultOfBoolean> {
    let url_ =
      this.baseUrl + '/api/v{apiVersion}/supply-approvals/add-transaction-requests';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAddTransactionRequests(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAddTransactionRequests(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<HttpResultOfBoolean>;
            }
          } else
            return _observableThrow(response_) as any as Observable<HttpResultOfBoolean>;
        })
      );
  }

  protected processAddTransactionRequests(
    response: HttpResponseBase
  ): Observable<HttpResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface ISupplyRequestsClient {
  getPage(
    status: SupplyRequestStatus | undefined,
    from: Date | null | undefined,
    to: Date | null | undefined,
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfSupplyRequestVm>;
  get(requestId: string, apiVersion: string): Observable<SupplyRequestDetailsVm>;
  create(apiVersion: string, request: SupplyRequestDto): Observable<HttpResultOfString>;
  accept(
    requestId: string,
    apiVersion: string,
    request: ChangeSupplyRequestStatusDto
  ): Observable<void>;
  reject(
    requestId: string,
    apiVersion: string,
    request: ChangeSupplyRequestStatusDto
  ): Observable<void>;
  update(
    requestId: string,
    apiVersion: string,
    request: SupplyRequestDto
  ): Observable<void>;
}

@Injectable({
  providedIn: 'root',
})
export class SupplyRequestsClient implements ISupplyRequestsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? '';
  }

  getPage(
    status: SupplyRequestStatus | undefined,
    from: Date | null | undefined,
    to: Date | null | undefined,
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfSupplyRequestVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/supply-requests/page?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (status === null) throw new Error("The parameter 'status' cannot be null.");
    else if (status !== undefined)
      url_ += 'status=' + encodeURIComponent('' + status) + '&';
    if (from !== undefined && from !== null)
      url_ += 'from=' + encodeURIComponent(from ? '' + from.toISOString() : '') + '&';
    if (to !== undefined && to !== null)
      url_ += 'to=' + encodeURIComponent(to ? '' + to.toISOString() : '') + '&';
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPage(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<PaginatedListOfSupplyRequestVm>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PaginatedListOfSupplyRequestVm>;
        })
      );
  }

  protected processGetPage(
    response: HttpResponseBase
  ): Observable<PaginatedListOfSupplyRequestVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfSupplyRequestVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  get(requestId: string, apiVersion: string): Observable<SupplyRequestDetailsVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/supply-requests/{requestId}';
    if (requestId === undefined || requestId === null)
      throw new Error("The parameter 'requestId' must be defined.");
    url_ = url_.replace('{requestId}', encodeURIComponent('' + requestId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<SupplyRequestDetailsVm>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<SupplyRequestDetailsVm>;
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<SupplyRequestDetailsVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SupplyRequestDetailsVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  create(apiVersion: string, request: SupplyRequestDto): Observable<HttpResultOfString> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/supply-requests';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<HttpResultOfString>;
            }
          } else
            return _observableThrow(response_) as any as Observable<HttpResultOfString>;
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<HttpResultOfString> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfString.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  accept(
    requestId: string,
    apiVersion: string,
    request: ChangeSupplyRequestStatusDto
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/supply-requests/{requestId}/accept';
    if (requestId === undefined || requestId === null)
      throw new Error("The parameter 'requestId' must be defined.");
    url_ = url_.replace('{requestId}', encodeURIComponent('' + requestId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAccept(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAccept(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processAccept(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  reject(
    requestId: string,
    apiVersion: string,
    request: ChangeSupplyRequestStatusDto
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/supply-requests/{requestId}/reject';
    if (requestId === undefined || requestId === null)
      throw new Error("The parameter 'requestId' must be defined.");
    url_ = url_.replace('{requestId}', encodeURIComponent('' + requestId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processReject(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processReject(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processReject(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  update(
    requestId: string,
    apiVersion: string,
    request: SupplyRequestDto
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/supply-requests/{requestId}/update';
    if (requestId === undefined || requestId === null)
      throw new Error("The parameter 'requestId' must be defined.");
    url_ = url_.replace('{requestId}', encodeURIComponent('' + requestId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface ITenantsClient {
  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfTenantDashboardVm>;
  get(tenantId: string, apiVersion: string): Observable<TenantDetailsVm>;
  update(tenantId: string, apiVersion: string, request: TenantDto): Observable<void>;
  testSqlConnection(
    apiVersion: string,
    request: TestConnectionRequest
  ): Observable<HttpResultOfBoolean>;
  testMongoConnection(
    apiVersion: string,
    request: TestConnectionRequest
  ): Observable<HttpResultOfBoolean>;
  create(apiVersion: string, request: TenantDto): Observable<TenantCreatedResponse>;
  updateLogo(
    apiVersion: string,
    tenantId: string | null | undefined,
    logo: FileParameter | null | undefined
  ): Observable<void>;
  extendSubscription(
    apiVersion: string,
    request: TenantExtendSubscriptionDto
  ): Observable<void>;
  activate(tenantId: string, apiVersion: string): Observable<void>;
  deactivate(tenantId: string, apiVersion: string): Observable<void>;
}

@Injectable({
  providedIn: 'root',
})
export class TenantsClient implements ITenantsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? '';
  }

  getPage(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfTenantDashboardVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/tenants/page?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPage(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<PaginatedListOfTenantDashboardVm>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PaginatedListOfTenantDashboardVm>;
        })
      );
  }

  protected processGetPage(
    response: HttpResponseBase
  ): Observable<PaginatedListOfTenantDashboardVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfTenantDashboardVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  get(tenantId: string, apiVersion: string): Observable<TenantDetailsVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/tenants/{tenantId}';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<TenantDetailsVm>;
            }
          } else return _observableThrow(response_) as any as Observable<TenantDetailsVm>;
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<TenantDetailsVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = TenantDetailsVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  update(tenantId: string, apiVersion: string, request: TenantDto): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/tenants/{tenantId}';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  testSqlConnection(
    apiVersion: string,
    request: TestConnectionRequest
  ): Observable<HttpResultOfBoolean> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/tenants/test-sql-connection';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processTestSqlConnection(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processTestSqlConnection(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<HttpResultOfBoolean>;
            }
          } else
            return _observableThrow(response_) as any as Observable<HttpResultOfBoolean>;
        })
      );
  }

  protected processTestSqlConnection(
    response: HttpResponseBase
  ): Observable<HttpResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  testMongoConnection(
    apiVersion: string,
    request: TestConnectionRequest
  ): Observable<HttpResultOfBoolean> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/tenants/test-mongo-connection';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processTestMongoConnection(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processTestMongoConnection(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<HttpResultOfBoolean>;
            }
          } else
            return _observableThrow(response_) as any as Observable<HttpResultOfBoolean>;
        })
      );
  }

  protected processTestMongoConnection(
    response: HttpResponseBase
  ): Observable<HttpResultOfBoolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfBoolean.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  create(apiVersion: string, request: TenantDto): Observable<TenantCreatedResponse> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/tenants';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<TenantCreatedResponse>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<TenantCreatedResponse>;
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<TenantCreatedResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = TenantCreatedResponse.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  updateLogo(
    apiVersion: string,
    tenantId: string | null | undefined,
    logo: FileParameter | null | undefined
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/tenants/update-logo';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = new FormData();
    if (tenantId !== null && tenantId !== undefined)
      content_.append('TenantId', tenantId.toString());
    if (logo !== null && logo !== undefined)
      content_.append('Logo', logo.data, logo.fileName ? logo.fileName : 'Logo');

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateLogo(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateLogo(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processUpdateLogo(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  extendSubscription(
    apiVersion: string,
    request: TenantExtendSubscriptionDto
  ): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/tenants/extend-subscription';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processExtendSubscription(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processExtendSubscription(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processExtendSubscription(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  activate(tenantId: string, apiVersion: string): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/tenants/activate/{tenantId}';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processActivate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processActivate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processActivate(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  deactivate(tenantId: string, apiVersion: string): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/tenants/deactivate/{tenantId}';
    if (tenantId === undefined || tenantId === null)
      throw new Error("The parameter 'tenantId' must be defined.");
    url_ = url_.replace('{tenantId}', encodeURIComponent('' + tenantId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeactivate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeactivate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processDeactivate(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ProblemDetails.fromJS(resultData404);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result404
          );
        })
      );
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ProblemDetails.fromJS(resultData400);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result400
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }
}

export interface ITendersClient {
  getListing(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfTenderVm>;
  getPage(
    pageNumber: number | undefined,
    limit: number | undefined,
    apiVersion: string
  ): Observable<TenderCardInfo[]>;
  get(tenderId: string, apiVersion: string): Observable<TenderInfo>;
  scrapListing(
    startFrom: number | undefined,
    count: number | undefined,
    to: Date | null | undefined,
    apiVersion: string
  ): Observable<HttpResultOfInteger>;
  enqueueDetails(apiVersion: string): Observable<void>;
  statusChecker(
    from: Date | null | undefined,
    to: Date | null | undefined,
    referenceNumber: string | null | undefined,
    count: number | undefined,
    apiVersion: string
  ): Observable<string>;
  apiChecker(apiVersion: string): Observable<RateLimitingResult>;
  webChecker(apiVersion: string): Observable<RateLimitingResult>;
}

@Injectable({
  providedIn: 'root',
})
export class TendersClient implements ITendersClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? '';
  }

  getListing(
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfTenderVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/tenders/page?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetListing(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetListing(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<PaginatedListOfTenderVm>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PaginatedListOfTenderVm>;
        })
      );
  }

  protected processGetListing(
    response: HttpResponseBase
  ): Observable<PaginatedListOfTenderVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfTenderVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getPage(
    pageNumber: number | undefined,
    limit: number | undefined,
    apiVersion: string
  ): Observable<TenderCardInfo[]> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/tenders/listing?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (pageNumber === null)
      throw new Error("The parameter 'pageNumber' cannot be null.");
    else if (pageNumber !== undefined)
      url_ += 'pageNumber=' + encodeURIComponent('' + pageNumber) + '&';
    if (limit === null) throw new Error("The parameter 'limit' cannot be null.");
    else if (limit !== undefined) url_ += 'limit=' + encodeURIComponent('' + limit) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPage(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPage(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<TenderCardInfo[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<TenderCardInfo[]>;
        })
      );
  }

  protected processGetPage(response: HttpResponseBase): Observable<TenderCardInfo[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(TenderCardInfo.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  get(tenderId: string, apiVersion: string): Observable<TenderInfo> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/tenders/{tenderId}';
    if (tenderId === undefined || tenderId === null)
      throw new Error("The parameter 'tenderId' must be defined.");
    url_ = url_.replace('{tenderId}', encodeURIComponent('' + tenderId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGet(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGet(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<TenderInfo>;
            }
          } else return _observableThrow(response_) as any as Observable<TenderInfo>;
        })
      );
  }

  protected processGet(response: HttpResponseBase): Observable<TenderInfo> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = TenderInfo.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  scrapListing(
    startFrom: number | undefined,
    count: number | undefined,
    to: Date | null | undefined,
    apiVersion: string
  ): Observable<HttpResultOfInteger> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/tenders/scrap-listing?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (startFrom === null) throw new Error("The parameter 'startFrom' cannot be null.");
    else if (startFrom !== undefined)
      url_ += 'StartFrom=' + encodeURIComponent('' + startFrom) + '&';
    if (count === null) throw new Error("The parameter 'count' cannot be null.");
    else if (count !== undefined) url_ += 'Count=' + encodeURIComponent('' + count) + '&';
    if (to !== undefined && to !== null)
      url_ += 'To=' + encodeURIComponent(to ? '' + to.toISOString() : '') + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processScrapListing(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processScrapListing(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<HttpResultOfInteger>;
            }
          } else
            return _observableThrow(response_) as any as Observable<HttpResultOfInteger>;
        })
      );
  }

  protected processScrapListing(
    response: HttpResponseBase
  ): Observable<HttpResultOfInteger> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfInteger.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  enqueueDetails(apiVersion: string): Observable<void> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/tenders/enqueue-details';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processEnqueueDetails(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processEnqueueDetails(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<void>;
            }
          } else return _observableThrow(response_) as any as Observable<void>;
        })
      );
  }

  protected processEnqueueDetails(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return _observableOf(null as any);
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  statusChecker(
    from: Date | null | undefined,
    to: Date | null | undefined,
    referenceNumber: string | null | undefined,
    count: number | undefined,
    apiVersion: string
  ): Observable<string> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/tenders/status-checker?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (from !== undefined && from !== null)
      url_ += 'From=' + encodeURIComponent(from ? '' + from.toISOString() : '') + '&';
    if (to !== undefined && to !== null)
      url_ += 'To=' + encodeURIComponent(to ? '' + to.toISOString() : '') + '&';
    if (referenceNumber !== undefined && referenceNumber !== null)
      url_ += 'ReferenceNumber=' + encodeURIComponent('' + referenceNumber) + '&';
    if (count === null) throw new Error("The parameter 'count' cannot be null.");
    else if (count !== undefined) url_ += 'Count=' + encodeURIComponent('' + count) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processStatusChecker(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processStatusChecker(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<string>;
            }
          } else return _observableThrow(response_) as any as Observable<string>;
        })
      );
  }

  protected processStatusChecker(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = resultData200 !== undefined ? resultData200 : <any>null;

          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  apiChecker(apiVersion: string): Observable<RateLimitingResult> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/tenders/api-rate-limiting-checker';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processApiChecker(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processApiChecker(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<RateLimitingResult>;
            }
          } else
            return _observableThrow(response_) as any as Observable<RateLimitingResult>;
        })
      );
  }

  protected processApiChecker(
    response: HttpResponseBase
  ): Observable<RateLimitingResult> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RateLimitingResult.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  webChecker(apiVersion: string): Observable<RateLimitingResult> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/tenders/web-rate-limiting-checker';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processWebChecker(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processWebChecker(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<RateLimitingResult>;
            }
          } else
            return _observableThrow(response_) as any as Observable<RateLimitingResult>;
        })
      );
  }

  protected processWebChecker(
    response: HttpResponseBase
  ): Observable<RateLimitingResult> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = RateLimitingResult.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

export interface IWorkItemsClient {
  getListing(
    projectId: string,
    termId: string | null | undefined,
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<WorkItemListingVm>;
  getComments(workItemId: string, apiVersion: string): Observable<WorkItemCommentVm[]>;
  getTags(query: string | null | undefined, apiVersion: string): Observable<string[]>;
  create(
    projectId: string,
    apiVersion: string,
    request: WorkItemDto
  ): Observable<HttpResultOfString>;
  comment(
    workItemId: string,
    apiVersion: string,
    request: WorkItemCommentDto
  ): Observable<HttpResultOfString>;
  update(
    workItemId: string,
    apiVersion: string,
    request: WorkItemDto
  ): Observable<FileResponse>;
  move(
    workItemId: string,
    apiVersion: string,
    request: WorkItemChangeStatusDto
  ): Observable<FileResponse>;
  updateComment(
    workItemId: string,
    commentId: string | null | undefined,
    apiVersion: string,
    request: WorkItemCommentDto
  ): Observable<FileResponse>;
  deleteComment(
    workItemId: string,
    commentId: string | null | undefined,
    apiVersion: string
  ): Observable<FileResponse>;
  getListing2(
    projectId: string,
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfWorkItemListingSummaryVm>;
}

@Injectable({
  providedIn: 'root',
})
export class WorkItemsClient implements IWorkItemsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ?? '';
  }

  getListing(
    projectId: string,
    termId: string | null | undefined,
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<WorkItemListingVm> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/work-items/{projectId}/listing?';
    if (projectId === undefined || projectId === null)
      throw new Error("The parameter 'projectId' must be defined.");
    url_ = url_.replace('{projectId}', encodeURIComponent('' + projectId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (termId !== undefined && termId !== null)
      url_ += 'termId=' + encodeURIComponent('' + termId) + '&';
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetListing(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetListing(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<WorkItemListingVm>;
            }
          } else
            return _observableThrow(response_) as any as Observable<WorkItemListingVm>;
        })
      );
  }

  protected processGetListing(response: HttpResponseBase): Observable<WorkItemListingVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = WorkItemListingVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getComments(workItemId: string, apiVersion: string): Observable<WorkItemCommentVm[]> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/work-items/{workItemId}/comments';
    if (workItemId === undefined || workItemId === null)
      throw new Error("The parameter 'workItemId' must be defined.");
    url_ = url_.replace('{workItemId}', encodeURIComponent('' + workItemId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetComments(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetComments(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<WorkItemCommentVm[]>;
            }
          } else
            return _observableThrow(response_) as any as Observable<WorkItemCommentVm[]>;
        })
      );
  }

  protected processGetComments(
    response: HttpResponseBase
  ): Observable<WorkItemCommentVm[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(WorkItemCommentVm.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  getTags(query: string | null | undefined, apiVersion: string): Observable<string[]> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/work-items/tags?';
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (query !== undefined && query !== null)
      url_ += 'query=' + encodeURIComponent('' + query) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTags(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTags(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<string[]>;
            }
          } else return _observableThrow(response_) as any as Observable<string[]>;
        })
      );
  }

  protected processGetTags(response: HttpResponseBase): Observable<string[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200) result200!.push(item);
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        })
      );
    } else if (status === 401) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ProblemDetails.fromJS(resultData401);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result401
          );
        })
      );
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ProblemDetails.fromJS(resultData403);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result403
          );
        })
      );
    } else if (status === 422) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ValidationProblemDetails.fromJS(resultData422);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            result422
          );
        })
      );
    } else {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let resultdefault: any = null;
          let resultDatadefault =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          resultdefault = ProblemDetails.fromJS(resultDatadefault);
          return throwException(
            'A server side error occurred.',
            status,
            _responseText,
            _headers,
            resultdefault
          );
        })
      );
    }
  }

  create(
    projectId: string,
    apiVersion: string,
    request: WorkItemDto
  ): Observable<HttpResultOfString> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/work-items/{projectId}/create';
    if (projectId === undefined || projectId === null)
      throw new Error("The parameter 'projectId' must be defined.");
    url_ = url_.replace('{projectId}', encodeURIComponent('' + projectId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<HttpResultOfString>;
            }
          } else
            return _observableThrow(response_) as any as Observable<HttpResultOfString>;
        })
      );
  }

  protected processCreate(response: HttpResponseBase): Observable<HttpResultOfString> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfString.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  comment(
    workItemId: string,
    apiVersion: string,
    request: WorkItemCommentDto
  ): Observable<HttpResultOfString> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/work-items/{workItemId}/comment';
    if (workItemId === undefined || workItemId === null)
      throw new Error("The parameter 'workItemId' must be defined.");
    url_ = url_.replace('{workItemId}', encodeURIComponent('' + workItemId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processComment(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processComment(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<HttpResultOfString>;
            }
          } else
            return _observableThrow(response_) as any as Observable<HttpResultOfString>;
        })
      );
  }

  protected processComment(response: HttpResponseBase): Observable<HttpResultOfString> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = HttpResultOfString.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  update(
    workItemId: string,
    apiVersion: string,
    request: WorkItemDto
  ): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/work-items/{workItemId}/update';
    if (workItemId === undefined || workItemId === null)
      throw new Error("The parameter 'workItemId' must be defined.");
    url_ = url_.replace('{workItemId}', encodeURIComponent('' + workItemId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdate(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  move(
    workItemId: string,
    apiVersion: string,
    request: WorkItemChangeStatusDto
  ): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/v{apiVersion}/work-items/{workItemId}/move';
    if (workItemId === undefined || workItemId === null)
      throw new Error("The parameter 'workItemId' must be defined.");
    url_ = url_.replace('{workItemId}', encodeURIComponent('' + workItemId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processMove(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processMove(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processMove(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  updateComment(
    workItemId: string,
    commentId: string | null | undefined,
    apiVersion: string,
    request: WorkItemCommentDto
  ): Observable<FileResponse> {
    let url_ =
      this.baseUrl + '/api/v{apiVersion}/work-items/{workItemId}/update-comment?';
    if (workItemId === undefined || workItemId === null)
      throw new Error("The parameter 'workItemId' must be defined.");
    url_ = url_.replace('{workItemId}', encodeURIComponent('' + workItemId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (commentId !== undefined && commentId !== null)
      url_ += 'commentId=' + encodeURIComponent('' + commentId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('put', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateComment(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateComment(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processUpdateComment(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  deleteComment(
    workItemId: string,
    commentId: string | null | undefined,
    apiVersion: string
  ): Observable<FileResponse> {
    let url_ =
      this.baseUrl + '/api/v{apiVersion}/work-items/{workItemId}/delete-comment?';
    if (workItemId === undefined || workItemId === null)
      throw new Error("The parameter 'workItemId' must be defined.");
    url_ = url_.replace('{workItemId}', encodeURIComponent('' + workItemId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (commentId !== undefined && commentId !== null)
      url_ += 'commentId=' + encodeURIComponent('' + commentId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteComment(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteComment(response_ as any);
            } catch (e) {
              return _observableThrow(e) as any as Observable<FileResponse>;
            }
          } else return _observableThrow(response_) as any as Observable<FileResponse>;
        })
      );
  }

  protected processDeleteComment(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      let fileNameMatch = contentDisposition
        ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(
            contentDisposition
          )
        : undefined;
      let fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[3] || fileNameMatch[2]
          : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition
          ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
          : undefined;
        fileName =
          fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({
        fileName: fileName,
        data: responseBlob as any,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }

  getListing2(
    projectId: string,
    offset: number | null | undefined,
    pageIndex: number | null | undefined,
    search: string | null | undefined,
    ascending: boolean | undefined,
    sortBy: string | null | undefined,
    apiVersion: string
  ): Observable<PaginatedListOfWorkItemListingSummaryVm> {
    let url_ =
      this.baseUrl + '/api/v{apiVersion}/work-items/{projectId}/listing-summary?';
    if (projectId === undefined || projectId === null)
      throw new Error("The parameter 'projectId' must be defined.");
    url_ = url_.replace('{projectId}', encodeURIComponent('' + projectId));
    if (apiVersion === undefined || apiVersion === null)
      throw new Error("The parameter 'apiVersion' must be defined.");
    url_ = url_.replace('{apiVersion}', encodeURIComponent('' + apiVersion));
    if (offset !== undefined && offset !== null)
      url_ += 'Offset=' + encodeURIComponent('' + offset) + '&';
    if (pageIndex !== undefined && pageIndex !== null)
      url_ += 'PageIndex=' + encodeURIComponent('' + pageIndex) + '&';
    if (search !== undefined && search !== null)
      url_ += 'Search=' + encodeURIComponent('' + search) + '&';
    if (ascending === null) throw new Error("The parameter 'ascending' cannot be null.");
    else if (ascending !== undefined)
      url_ += 'Ascending=' + encodeURIComponent('' + ascending) + '&';
    if (sortBy !== undefined && sortBy !== null)
      url_ += 'SortBy=' + encodeURIComponent('' + sortBy) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetListing2(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetListing2(response_ as any);
            } catch (e) {
              return _observableThrow(
                e
              ) as any as Observable<PaginatedListOfWorkItemListingSummaryVm>;
            }
          } else
            return _observableThrow(
              response_
            ) as any as Observable<PaginatedListOfWorkItemListingSummaryVm>;
        })
      );
  }

  protected processGetListing2(
    response: HttpResponseBase
  ): Observable<PaginatedListOfWorkItemListingSummaryVm> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (response as any).error instanceof Blob
        ? (response as any).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 =
            _responseText === ''
              ? null
              : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PaginatedListOfWorkItemListingSummaryVm.fromJS(resultData200);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText: string) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf(null as any);
  }
}

export class ProblemDetails implements IProblemDetails {
  type?: string | undefined;
  title?: string | undefined;
  status?: number | undefined;
  detail?: string | undefined;
  instance?: string | undefined;
  extensions?: { [key: string]: any };

  [key: string]: any;

  constructor(data?: IProblemDetails) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.type = _data['type'];
      this.title = _data['title'];
      this.status = _data['status'];
      this.detail = _data['detail'];
      this.instance = _data['instance'];
      if (_data['extensions']) {
        this.extensions = {} as any;
        for (let key in _data['extensions']) {
          if (_data['extensions'].hasOwnProperty(key))
            (<any>this.extensions)![key] = _data['extensions'][key];
        }
      }
    }
  }

  static fromJS(data: any): ProblemDetails {
    data = typeof data === 'object' ? data : {};
    let result = new ProblemDetails();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data['type'] = this.type;
    data['title'] = this.title;
    data['status'] = this.status;
    data['detail'] = this.detail;
    data['instance'] = this.instance;
    if (this.extensions) {
      data['extensions'] = {};
      for (let key in this.extensions) {
        if (this.extensions.hasOwnProperty(key))
          (<any>data['extensions'])[key] = (<any>this.extensions)[key];
      }
    }
    return data;
  }
}

export interface IProblemDetails {
  type?: string | undefined;
  title?: string | undefined;
  status?: number | undefined;
  detail?: string | undefined;
  instance?: string | undefined;
  extensions?: { [key: string]: any };

  [key: string]: any;
}

export class PaginatedListOfAdminVm implements IPaginatedListOfAdminVm {
  pageInfo?: PageInfo | undefined;
  items?: AdminVm[] | undefined;

  constructor(data?: IPaginatedListOfAdminVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(AdminVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfAdminVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfAdminVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfAdminVm {
  pageInfo?: PageInfo | undefined;
  items?: AdminVm[] | undefined;
}

export class PageInfo implements IPageInfo {
  sortingBy?: string | undefined;
  ascending?: boolean;
  pageIndex?: number;
  totalPages?: number;
  totalCount?: number;

  constructor(data?: IPageInfo) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.sortingBy = _data['sortingBy'];
      this.ascending = _data['ascending'];
      this.pageIndex = _data['pageIndex'];
      this.totalPages = _data['totalPages'];
      this.totalCount = _data['totalCount'];
    }
  }

  static fromJS(data: any): PageInfo {
    data = typeof data === 'object' ? data : {};
    let result = new PageInfo();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['sortingBy'] = this.sortingBy;
    data['ascending'] = this.ascending;
    data['pageIndex'] = this.pageIndex;
    data['totalPages'] = this.totalPages;
    data['totalCount'] = this.totalCount;
    return data;
  }
}

export interface IPageInfo {
  sortingBy?: string | undefined;
  ascending?: boolean;
  pageIndex?: number;
  totalPages?: number;
  totalCount?: number;
}

export class AdminVm implements IAdminVm {
  id?: string | undefined;
  username?: string | undefined;
  fullName?: string | undefined;
  phoneNumber?: string | undefined;
  pictureUrl?: string | undefined;
  loginProviders?: string[] | undefined;
  status?: AccountStatus;
  createdAt?: Date;
  roles?: Role[] | undefined;

  constructor(data?: IAdminVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.username = _data['username'];
      this.fullName = _data['fullName'];
      this.phoneNumber = _data['phoneNumber'];
      this.pictureUrl = _data['pictureUrl'];
      if (Array.isArray(_data['loginProviders'])) {
        this.loginProviders = [] as any;
        for (let item of _data['loginProviders']) this.loginProviders!.push(item);
      }
      this.status = _data['status'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : <any>undefined;
      if (Array.isArray(_data['roles'])) {
        this.roles = [] as any;
        for (let item of _data['roles']) this.roles!.push(item);
      }
    }
  }

  static fromJS(data: any): AdminVm {
    data = typeof data === 'object' ? data : {};
    let result = new AdminVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['username'] = this.username;
    data['fullName'] = this.fullName;
    data['phoneNumber'] = this.phoneNumber;
    data['pictureUrl'] = this.pictureUrl;
    if (Array.isArray(this.loginProviders)) {
      data['loginProviders'] = [];
      for (let item of this.loginProviders) data['loginProviders'].push(item);
    }
    data['status'] = this.status;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
    if (Array.isArray(this.roles)) {
      data['roles'] = [];
      for (let item of this.roles) data['roles'].push(item);
    }
    return data;
  }
}

export interface IAdminVm {
  id?: string | undefined;
  username?: string | undefined;
  fullName?: string | undefined;
  phoneNumber?: string | undefined;
  pictureUrl?: string | undefined;
  loginProviders?: string[] | undefined;
  status?: AccountStatus;
  createdAt?: Date;
  roles?: Role[] | undefined;
}

export enum AccountStatus {
  Live = 0,
  Deactivated = 1,
  Inactive = 2,
  Deleted = 3,
}

export enum Role {
  Admin = 0,
  SiteEngineer = 1,
  ProjectManager = 2,
  TechnicalOfficer = 3,
  Accountant = 4,
  Purchasing = 5,
  ProjectsManager = 6,
  GeneralManager = 7,
}

export class HttpValidationProblemDetails
  extends ProblemDetails
  implements IHttpValidationProblemDetails
{
  errors?: { [key: string]: string[] };

  [key: string]: any;

  constructor(data?: IHttpValidationProblemDetails) {
    super(data);
  }

  override init(_data?: any) {
    super.init(_data);
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      if (_data['errors']) {
        this.errors = {} as any;
        for (let key in _data['errors']) {
          if (_data['errors'].hasOwnProperty(key))
            (<any>this.errors)![key] =
              _data['errors'][key] !== undefined ? _data['errors'][key] : [];
        }
      }
    }
  }

  static override fromJS(data: any): HttpValidationProblemDetails {
    data = typeof data === 'object' ? data : {};
    let result = new HttpValidationProblemDetails();
    result.init(data);
    return result;
  }

  override toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    if (this.errors) {
      data['errors'] = {};
      for (let key in this.errors) {
        if (this.errors.hasOwnProperty(key))
          (<any>data['errors'])[key] = (<any>this.errors)[key];
      }
    }
    super.toJSON(data);
    return data;
  }
}

export interface IHttpValidationProblemDetails extends IProblemDetails {
  errors?: { [key: string]: string[] };

  [key: string]: any;
}

export class ValidationProblemDetails
  extends HttpValidationProblemDetails
  implements IValidationProblemDetails
{
  [key: string]: any;

  constructor(data?: IValidationProblemDetails) {
    super(data);
  }

  override init(_data?: any) {
    super.init(_data);
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      if (_data['errors']) {
        this.errors = {} as any;
        for (let key in _data['errors']) {
          if (_data['errors'].hasOwnProperty(key))
            (<any>this.errors)![key] =
              _data['errors'][key] !== undefined ? _data['errors'][key] : [];
        }
      }
    }
  }

  static override fromJS(data: any): ValidationProblemDetails {
    data = typeof data === 'object' ? data : {};
    let result = new ValidationProblemDetails();
    result.init(data);
    return result;
  }

  override toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    if (this.errors) {
      data['errors'] = {};
      for (let key in this.errors) {
        if (this.errors.hasOwnProperty(key))
          (<any>data['errors'])[key] = (<any>this.errors)[key];
      }
    }
    super.toJSON(data);
    return data;
  }
}

export interface IValidationProblemDetails extends IHttpValidationProblemDetails {
  errors?: { [key: string]: string[] };

  [key: string]: any;
}

export class AccountListVm implements IAccountListVm {
  id?: string | undefined;
  username?: string | undefined;
  fullName?: string | undefined;
  picture?: string | undefined;

  constructor(data?: IAccountListVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.username = _data['username'];
      this.fullName = _data['fullName'];
      this.picture = _data['picture'];
    }
  }

  static fromJS(data: any): AccountListVm {
    data = typeof data === 'object' ? data : {};
    let result = new AccountListVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['username'] = this.username;
    data['fullName'] = this.fullName;
    data['picture'] = this.picture;
    return data;
  }
}

export interface IAccountListVm {
  id?: string | undefined;
  username?: string | undefined;
  fullName?: string | undefined;
  picture?: string | undefined;
}

export class AccountDetailsDashboardVm implements IAccountDetailsDashboardVm {
  name?: FullNameDto | undefined;
  email?: string | undefined;
  username?: string | undefined;
  phoneNumber?: string | undefined;
  pictureUrl?: string | undefined;
  roles?: Role[] | undefined;

  constructor(data?: IAccountDetailsDashboardVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'] ? FullNameDto.fromJS(_data['name']) : <any>undefined;
      this.email = _data['email'];
      this.username = _data['username'];
      this.phoneNumber = _data['phoneNumber'];
      this.pictureUrl = _data['pictureUrl'];
      if (Array.isArray(_data['roles'])) {
        this.roles = [] as any;
        for (let item of _data['roles']) this.roles!.push(item);
      }
    }
  }

  static fromJS(data: any): AccountDetailsDashboardVm {
    data = typeof data === 'object' ? data : {};
    let result = new AccountDetailsDashboardVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    data['email'] = this.email;
    data['username'] = this.username;
    data['phoneNumber'] = this.phoneNumber;
    data['pictureUrl'] = this.pictureUrl;
    if (Array.isArray(this.roles)) {
      data['roles'] = [];
      for (let item of this.roles) data['roles'].push(item);
    }
    return data;
  }
}

export interface IAccountDetailsDashboardVm {
  name?: FullNameDto | undefined;
  email?: string | undefined;
  username?: string | undefined;
  phoneNumber?: string | undefined;
  pictureUrl?: string | undefined;
  roles?: Role[] | undefined;
}

export class FullNameDto implements IFullNameDto {
  firstName?: string | undefined;
  lastName?: string | undefined;

  constructor(data?: IFullNameDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.firstName = _data['firstName'];
      this.lastName = _data['lastName'];
    }
  }

  static fromJS(data: any): FullNameDto {
    data = typeof data === 'object' ? data : {};
    let result = new FullNameDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['firstName'] = this.firstName;
    data['lastName'] = this.lastName;
    return data;
  }
}

export interface IFullNameDto {
  firstName?: string | undefined;
  lastName?: string | undefined;
}

export class AccountResult implements IAccountResult {
  id?: string | undefined;
  username?: string | undefined;
  createdAt?: Date;

  constructor(data?: IAccountResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.username = _data['username'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): AccountResult {
    data = typeof data === 'object' ? data : {};
    let result = new AccountResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['username'] = this.username;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
    return data;
  }
}

export interface IAccountResult {
  id?: string | undefined;
  username?: string | undefined;
  createdAt?: Date;
}

export class AccountsPostCommand implements IAccountsPostCommand {
  data?: AccountDto | undefined;

  constructor(data?: IAccountsPostCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data['data'] ? AccountDto.fromJS(_data['data']) : <any>undefined;
    }
  }

  static fromJS(data: any): AccountsPostCommand {
    data = typeof data === 'object' ? data : {};
    let result = new AccountsPostCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['data'] = this.data ? this.data.toJSON() : <any>undefined;
    return data;
  }
}

export interface IAccountsPostCommand {
  data?: AccountDto | undefined;
}

export class AccountDto implements IAccountDto {
  fullName?: FullNameDto | undefined;
  email?: string | undefined;
  role?: Role;
  phoneNumber?: string | undefined;

  constructor(data?: IAccountDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.fullName = _data['fullName']
        ? FullNameDto.fromJS(_data['fullName'])
        : <any>undefined;
      this.email = _data['email'];
      this.role = _data['role'];
      this.phoneNumber = _data['phoneNumber'];
    }
  }

  static fromJS(data: any): AccountDto {
    data = typeof data === 'object' ? data : {};
    let result = new AccountDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['fullName'] = this.fullName ? this.fullName.toJSON() : <any>undefined;
    data['email'] = this.email;
    data['role'] = this.role;
    data['phoneNumber'] = this.phoneNumber;
    return data;
  }
}

export interface IAccountDto {
  fullName?: FullNameDto | undefined;
  email?: string | undefined;
  role?: Role;
  phoneNumber?: string | undefined;
}

export class QrImage implements IQrImage {
  base64?: string | undefined;
  secretKey?: string | undefined;

  constructor(data?: IQrImage) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.base64 = _data['base64'];
      this.secretKey = _data['secretKey'];
    }
  }

  static fromJS(data: any): QrImage {
    data = typeof data === 'object' ? data : {};
    let result = new QrImage();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['base64'] = this.base64;
    data['secretKey'] = this.secretKey;
    return data;
  }
}

export interface IQrImage {
  base64?: string | undefined;
  secretKey?: string | undefined;
}

export class EnableTwoFactorAuthenticationCommand
  implements IEnableTwoFactorAuthenticationCommand
{
  constructor(data?: IEnableTwoFactorAuthenticationCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {}

  static fromJS(data: any): EnableTwoFactorAuthenticationCommand {
    data = typeof data === 'object' ? data : {};
    let result = new EnableTwoFactorAuthenticationCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    return data;
  }
}

export interface IEnableTwoFactorAuthenticationCommand {}

export class HttpResultOfBoolean implements IHttpResultOfBoolean {
  result?: boolean;

  constructor(data?: IHttpResultOfBoolean) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.result = _data['result'];
    }
  }

  static fromJS(data: any): HttpResultOfBoolean {
    data = typeof data === 'object' ? data : {};
    let result = new HttpResultOfBoolean();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['result'] = this.result;
    return data;
  }
}

export interface IHttpResultOfBoolean {
  result?: boolean;
}

export class OtpVerificationDTO implements IOtpVerificationDTO {
  otp?: string | undefined;
  secretKey?: string | undefined;

  constructor(data?: IOtpVerificationDTO) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.otp = _data['otp'];
      this.secretKey = _data['secretKey'];
    }
  }

  static fromJS(data: any): OtpVerificationDTO {
    data = typeof data === 'object' ? data : {};
    let result = new OtpVerificationDTO();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['otp'] = this.otp;
    data['secretKey'] = this.secretKey;
    return data;
  }
}

export interface IOtpVerificationDTO {
  otp?: string | undefined;
  secretKey?: string | undefined;
}

export class DisableTwoFactorAuthenticationCommand
  implements IDisableTwoFactorAuthenticationCommand
{
  constructor(data?: IDisableTwoFactorAuthenticationCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {}

  static fromJS(data: any): DisableTwoFactorAuthenticationCommand {
    data = typeof data === 'object' ? data : {};
    let result = new DisableTwoFactorAuthenticationCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    return data;
  }
}

export interface IDisableTwoFactorAuthenticationCommand {}

export class AccountsResetTwoFACommand implements IAccountsResetTwoFACommand {
  userId?: string | undefined;

  constructor(data?: IAccountsResetTwoFACommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data['userId'];
    }
  }

  static fromJS(data: any): AccountsResetTwoFACommand {
    data = typeof data === 'object' ? data : {};
    let result = new AccountsResetTwoFACommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userId'] = this.userId;
    return data;
  }
}

export interface IAccountsResetTwoFACommand {
  userId?: string | undefined;
}

export class AccountsPutCommand implements IAccountsPutCommand {
  userId?: string | undefined;
  data?: AccountDto | undefined;

  constructor(data?: IAccountsPutCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data['userId'];
      this.data = _data['data'] ? AccountDto.fromJS(_data['data']) : <any>undefined;
    }
  }

  static fromJS(data: any): AccountsPutCommand {
    data = typeof data === 'object' ? data : {};
    let result = new AccountsPutCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userId'] = this.userId;
    data['data'] = this.data ? this.data.toJSON() : <any>undefined;
    return data;
  }
}

export interface IAccountsPutCommand {
  userId?: string | undefined;
  data?: AccountDto | undefined;
}

export class ResetUserPasswordCommand implements IResetUserPasswordCommand {
  userId?: string | undefined;

  constructor(data?: IResetUserPasswordCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data['userId'];
    }
  }

  static fromJS(data: any): ResetUserPasswordCommand {
    data = typeof data === 'object' ? data : {};
    let result = new ResetUserPasswordCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userId'] = this.userId;
    return data;
  }
}

export interface IResetUserPasswordCommand {
  userId?: string | undefined;
}

export class AccountsEndLockoutCommand implements IAccountsEndLockoutCommand {
  userId?: string | undefined;

  constructor(data?: IAccountsEndLockoutCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data['userId'];
    }
  }

  static fromJS(data: any): AccountsEndLockoutCommand {
    data = typeof data === 'object' ? data : {};
    let result = new AccountsEndLockoutCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userId'] = this.userId;
    return data;
  }
}

export interface IAccountsEndLockoutCommand {
  userId?: string | undefined;
}

export class AccountsActivateCommand implements IAccountsActivateCommand {
  userId?: string | undefined;

  constructor(data?: IAccountsActivateCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data['userId'];
    }
  }

  static fromJS(data: any): AccountsActivateCommand {
    data = typeof data === 'object' ? data : {};
    let result = new AccountsActivateCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userId'] = this.userId;
    return data;
  }
}

export interface IAccountsActivateCommand {
  userId?: string | undefined;
}

export class AccountsDeactivateCommand implements IAccountsDeactivateCommand {
  data?: DeactivationRequestDto | undefined;

  constructor(data?: IAccountsDeactivateCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.data = _data['data']
        ? DeactivationRequestDto.fromJS(_data['data'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): AccountsDeactivateCommand {
    data = typeof data === 'object' ? data : {};
    let result = new AccountsDeactivateCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['data'] = this.data ? this.data.toJSON() : <any>undefined;
    return data;
  }
}

export interface IAccountsDeactivateCommand {
  data?: DeactivationRequestDto | undefined;
}

export class DeactivationRequestDto implements IDeactivationRequestDto {
  userId?: string | undefined;
  reason?: string | undefined;

  constructor(data?: IDeactivationRequestDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data['userId'];
      this.reason = _data['reason'];
    }
  }

  static fromJS(data: any): DeactivationRequestDto {
    data = typeof data === 'object' ? data : {};
    let result = new DeactivationRequestDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userId'] = this.userId;
    data['reason'] = this.reason;
    return data;
  }
}

export interface IDeactivationRequestDto {
  userId?: string | undefined;
  reason?: string | undefined;
}

export class PaginatedListOfRequestActivityViewVM
  implements IPaginatedListOfRequestActivityViewVM
{
  pageInfo?: PageInfo | undefined;
  items?: RequestActivityViewVM[] | undefined;

  constructor(data?: IPaginatedListOfRequestActivityViewVM) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items'])
          this.items!.push(RequestActivityViewVM.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfRequestActivityViewVM {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfRequestActivityViewVM();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfRequestActivityViewVM {
  pageInfo?: PageInfo | undefined;
  items?: RequestActivityViewVM[] | undefined;
}

export class RequestActivityViewVM implements IRequestActivityViewVM {
  id?: string | undefined;
  phase?: string | undefined;
  termId?: string | undefined;
  termTitle?: string | undefined;
  actor?: number;
  notes?: string | undefined;
  metaData?: string | undefined;
  createdAt?: Date;
  createdBy?: string | undefined;
  lastModifiedAt?: Date | undefined;
  lastModifiedBy?: string | undefined;
  requestType?: string | undefined;
  project?: RequestActivityViewProjectVm | undefined;
  request?: RequestActivityDataVm | undefined;

  constructor(data?: IRequestActivityViewVM) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.phase = _data['phase'];
      this.termId = _data['termId'];
      this.termTitle = _data['termTitle'];
      this.actor = _data['actor'];
      this.notes = _data['notes'];
      this.metaData = _data['metaData'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : <any>undefined;
      this.createdBy = _data['createdBy'];
      this.lastModifiedAt = _data['lastModifiedAt']
        ? new Date(_data['lastModifiedAt'].toString())
        : <any>undefined;
      this.lastModifiedBy = _data['lastModifiedBy'];
      this.requestType = _data['requestType'];
      this.project = _data['project']
        ? RequestActivityViewProjectVm.fromJS(_data['project'])
        : <any>undefined;
      this.request = _data['request']
        ? RequestActivityDataVm.fromJS(_data['request'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): RequestActivityViewVM {
    data = typeof data === 'object' ? data : {};
    let result = new RequestActivityViewVM();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['phase'] = this.phase;
    data['termId'] = this.termId;
    data['termTitle'] = this.termTitle;
    data['actor'] = this.actor;
    data['notes'] = this.notes;
    data['metaData'] = this.metaData;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
    data['createdBy'] = this.createdBy;
    data['lastModifiedAt'] = this.lastModifiedAt
      ? this.lastModifiedAt.toISOString()
      : <any>undefined;
    data['lastModifiedBy'] = this.lastModifiedBy;
    data['requestType'] = this.requestType;
    data['project'] = this.project ? this.project.toJSON() : <any>undefined;
    data['request'] = this.request ? this.request.toJSON() : <any>undefined;
    return data;
  }
}

export interface IRequestActivityViewVM {
  id?: string | undefined;
  phase?: string | undefined;
  termId?: string | undefined;
  termTitle?: string | undefined;
  actor?: number;
  notes?: string | undefined;
  metaData?: string | undefined;
  createdAt?: Date;
  createdBy?: string | undefined;
  lastModifiedAt?: Date | undefined;
  lastModifiedBy?: string | undefined;
  requestType?: string | undefined;
  project?: RequestActivityViewProjectVm | undefined;
  request?: RequestActivityDataVm | undefined;
}

export class RequestActivityViewProjectVm implements IRequestActivityViewProjectVm {
  id?: string | undefined;
  name?: string | undefined;
  description?: string | undefined;

  constructor(data?: IRequestActivityViewProjectVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.description = _data['description'];
    }
  }

  static fromJS(data: any): RequestActivityViewProjectVm {
    data = typeof data === 'object' ? data : {};
    let result = new RequestActivityViewProjectVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['description'] = this.description;
    return data;
  }
}

export interface IRequestActivityViewProjectVm {
  id?: string | undefined;
  name?: string | undefined;
  description?: string | undefined;
}

export class RequestActivityDataVm implements IRequestActivityDataVm {
  requestId?: string | undefined;
  status?: string | undefined;
  quantity?: number;
  requestNumber?: number;
  requestDate?: Date;
  extractRequestType?: string | undefined;
  extractRequestExtractValue?: number | undefined;

  constructor(data?: IRequestActivityDataVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.requestId = _data['requestId'];
      this.status = _data['status'];
      this.quantity = _data['quantity'];
      this.requestNumber = _data['requestNumber'];
      this.requestDate = _data['requestDate']
        ? new Date(_data['requestDate'].toString())
        : <any>undefined;
      this.extractRequestType = _data['extractRequestType'];
      this.extractRequestExtractValue = _data['extractRequestExtractValue'];
    }
  }

  static fromJS(data: any): RequestActivityDataVm {
    data = typeof data === 'object' ? data : {};
    let result = new RequestActivityDataVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['requestId'] = this.requestId;
    data['status'] = this.status;
    data['quantity'] = this.quantity;
    data['requestNumber'] = this.requestNumber;
    data['requestDate'] = this.requestDate
      ? this.requestDate.toISOString()
      : <any>undefined;
    data['extractRequestType'] = this.extractRequestType;
    data['extractRequestExtractValue'] = this.extractRequestExtractValue;
    return data;
  }
}

export interface IRequestActivityDataVm {
  requestId?: string | undefined;
  status?: string | undefined;
  quantity?: number;
  requestNumber?: number;
  requestDate?: Date;
  extractRequestType?: string | undefined;
  extractRequestExtractValue?: number | undefined;
}

export class PaginatedListOfAuditLogVm implements IPaginatedListOfAuditLogVm {
  pageInfo?: PageInfo | undefined;
  items?: AuditLogVm[] | undefined;

  constructor(data?: IPaginatedListOfAuditLogVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(AuditLogVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfAuditLogVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfAuditLogVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfAuditLogVm {
  pageInfo?: PageInfo | undefined;
  items?: AuditLogVm[] | undefined;
}

export class AuditLogVm implements IAuditLogVm {
  id?: string | undefined;
  entityId?: string | undefined;
  entityType?: string | undefined;
  state?: AuditLogState;
  data?: string | undefined;
  properties?: string | undefined;
  createdAt?: Date;

  constructor(data?: IAuditLogVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.entityId = _data['entityId'];
      this.entityType = _data['entityType'];
      this.state = _data['state'];
      this.data = _data['data'];
      this.properties = _data['properties'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): AuditLogVm {
    data = typeof data === 'object' ? data : {};
    let result = new AuditLogVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['entityId'] = this.entityId;
    data['entityType'] = this.entityType;
    data['state'] = this.state;
    data['data'] = this.data;
    data['properties'] = this.properties;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
    return data;
  }
}

export interface IAuditLogVm {
  id?: string | undefined;
  entityId?: string | undefined;
  entityType?: string | undefined;
  state?: AuditLogState;
  data?: string | undefined;
  properties?: string | undefined;
  createdAt?: Date;
}

export enum AuditLogState {
  Added = 0,
  Modified = 1,
  Deleted = 2,
}

export class BanksDTO implements IBanksDTO {
  id?: string | undefined;
  name?: WeakLocalizedString | undefined;

  constructor(data?: IBanksDTO) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name']
        ? WeakLocalizedString.fromJS(_data['name'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): BanksDTO {
    data = typeof data === 'object' ? data : {};
    let result = new BanksDTO();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    return data;
  }
}

export interface IBanksDTO {
  id?: string | undefined;
  name?: WeakLocalizedString | undefined;
}

export abstract class ValueObject implements IValueObject {
  constructor(data?: IValueObject) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {}

  static fromJS(data: any): ValueObject {
    data = typeof data === 'object' ? data : {};
    throw new Error("The abstract class 'ValueObject' cannot be instantiated.");
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    return data;
  }
}

export interface IValueObject {}

export class WeakLocalizedString extends ValueObject implements IWeakLocalizedString {
  ar?: string | undefined;
  en?: string | undefined;

  constructor(data?: IWeakLocalizedString) {
    super(data);
  }

  override init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.ar = _data['ar'];
      this.en = _data['en'];
    }
  }

  static override fromJS(data: any): WeakLocalizedString {
    data = typeof data === 'object' ? data : {};
    let result = new WeakLocalizedString();
    result.init(data);
    return result;
  }

  override toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['ar'] = this.ar;
    data['en'] = this.en;
    super.toJSON(data);
    return data;
  }
}

export interface IWeakLocalizedString extends IValueObject {
  ar?: string | undefined;
  en?: string | undefined;
}

export class PaginatedListOfBanksDTO implements IPaginatedListOfBanksDTO {
  pageInfo?: PageInfo | undefined;
  items?: BanksDTO[] | undefined;

  constructor(data?: IPaginatedListOfBanksDTO) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(BanksDTO.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfBanksDTO {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfBanksDTO();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfBanksDTO {
  pageInfo?: PageInfo | undefined;
  items?: BanksDTO[] | undefined;
}

export class HttpResultOfString implements IHttpResultOfString {
  result?: string | undefined;

  constructor(data?: IHttpResultOfString) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.result = _data['result'];
    }
  }

  static fromJS(data: any): HttpResultOfString {
    data = typeof data === 'object' ? data : {};
    let result = new HttpResultOfString();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['result'] = this.result;
    return data;
  }
}

export interface IHttpResultOfString {
  result?: string | undefined;
}

export class CreateBankDTO implements ICreateBankDTO {
  name?: WeakLocalizedString | undefined;

  constructor(data?: ICreateBankDTO) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name']
        ? WeakLocalizedString.fromJS(_data['name'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): CreateBankDTO {
    data = typeof data === 'object' ? data : {};
    let result = new CreateBankDTO();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICreateBankDTO {
  name?: WeakLocalizedString | undefined;
}

export class PaginatedListOfBranchPageVm implements IPaginatedListOfBranchPageVm {
  pageInfo?: PageInfo | undefined;
  items?: BranchPageVm[] | undefined;

  constructor(data?: IPaginatedListOfBranchPageVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(BranchPageVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfBranchPageVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfBranchPageVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfBranchPageVm {
  pageInfo?: PageInfo | undefined;
  items?: BranchPageVm[] | undefined;
}

export class BranchPageVm implements IBranchPageVm {
  id?: string | undefined;
  code?: string | undefined;
  name?: string | undefined;

  constructor(data?: IBranchPageVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.code = _data['code'];
      this.name = _data['name'];
    }
  }

  static fromJS(data: any): BranchPageVm {
    data = typeof data === 'object' ? data : {};
    let result = new BranchPageVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['code'] = this.code;
    data['name'] = this.name;
    return data;
  }
}

export interface IBranchPageVm {
  id?: string | undefined;
  code?: string | undefined;
  name?: string | undefined;
}

export class BranchDetailsVm implements IBranchDetailsVm {
  id?: string | undefined;
  code?: string | undefined;
  name?: LocalizedStringDto | undefined;
  description?: LocalizedStringDto | undefined;

  constructor(data?: IBranchDetailsVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.code = _data['code'];
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
      this.description = _data['description']
        ? LocalizedStringDto.fromJS(_data['description'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): BranchDetailsVm {
    data = typeof data === 'object' ? data : {};
    let result = new BranchDetailsVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['code'] = this.code;
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    data['description'] = this.description ? this.description.toJSON() : <any>undefined;
    return data;
  }
}

export interface IBranchDetailsVm {
  id?: string | undefined;
  code?: string | undefined;
  name?: LocalizedStringDto | undefined;
  description?: LocalizedStringDto | undefined;
}

export class LocalizedStringDto implements ILocalizedStringDto {
  ar?: string | undefined;
  en?: string | undefined;

  constructor(data?: ILocalizedStringDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.ar = _data['ar'];
      this.en = _data['en'];
    }
  }

  static fromJS(data: any): LocalizedStringDto {
    data = typeof data === 'object' ? data : {};
    let result = new LocalizedStringDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['ar'] = this.ar;
    data['en'] = this.en;
    return data;
  }
}

export interface ILocalizedStringDto {
  ar?: string | undefined;
  en?: string | undefined;
}

export class BranchDto implements IBranchDto {
  code?: string | undefined;
  name?: LocalizedStringDto | undefined;
  description?: LocalizedStringDto | undefined;

  constructor(data?: IBranchDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.code = _data['code'];
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
      this.description = _data['description']
        ? LocalizedStringDto.fromJS(_data['description'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): BranchDto {
    data = typeof data === 'object' ? data : {};
    let result = new BranchDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['code'] = this.code;
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    data['description'] = this.description ? this.description.toJSON() : <any>undefined;
    return data;
  }
}

export interface IBranchDto {
  code?: string | undefined;
  name?: LocalizedStringDto | undefined;
  description?: LocalizedStringDto | undefined;
}

export class CityVm implements ICityVm {
  id?: string | undefined;
  name?: LocalizedStringDto | undefined;
  country?: CityCountryVm | undefined;

  constructor(data?: ICityVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
      this.country = _data['country']
        ? CityCountryVm.fromJS(_data['country'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): CityVm {
    data = typeof data === 'object' ? data : {};
    let result = new CityVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    data['country'] = this.country ? this.country.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICityVm {
  id?: string | undefined;
  name?: LocalizedStringDto | undefined;
  country?: CityCountryVm | undefined;
}

export class CityCountryVm implements ICityCountryVm {
  id?: string | undefined;
  name?: LocalizedStringDto | undefined;
  vat?: number;

  constructor(data?: ICityCountryVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
      this.vat = _data['vat'];
    }
  }

  static fromJS(data: any): CityCountryVm {
    data = typeof data === 'object' ? data : {};
    let result = new CityCountryVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    data['vat'] = this.vat;
    return data;
  }
}

export interface ICityCountryVm {
  id?: string | undefined;
  name?: LocalizedStringDto | undefined;
  vat?: number;
}

export class PaginatedListOfCityVm implements IPaginatedListOfCityVm {
  pageInfo?: PageInfo | undefined;
  items?: CityVm[] | undefined;

  constructor(data?: IPaginatedListOfCityVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(CityVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfCityVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfCityVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfCityVm {
  pageInfo?: PageInfo | undefined;
  items?: CityVm[] | undefined;
}

export class CityDto implements ICityDto {
  name?: LocalizedStringDto | undefined;
  countryId?: string | undefined;

  constructor(data?: ICityDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
      this.countryId = _data['countryId'];
    }
  }

  static fromJS(data: any): CityDto {
    data = typeof data === 'object' ? data : {};
    let result = new CityDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    data['countryId'] = this.countryId;
    return data;
  }
}

export interface ICityDto {
  name?: LocalizedStringDto | undefined;
  countryId?: string | undefined;
}

export class ClientDto implements IClientDto {
  name?: string | undefined;
  commercialRegisterNumber?: string | undefined;
  identification?: string | undefined;
  isActive?: boolean;
  type?: ClientType;
  address?: NationalAddressDto | undefined;
  contactInfo?: ClientContactInfoDto | undefined;

  constructor(data?: IClientDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.commercialRegisterNumber = _data['commercialRegisterNumber'];
      this.identification = _data['identification'];
      this.isActive = _data['isActive'];
      this.type = _data['type'];
      this.address = _data['address']
        ? NationalAddressDto.fromJS(_data['address'])
        : <any>undefined;
      this.contactInfo = _data['contactInfo']
        ? ClientContactInfoDto.fromJS(_data['contactInfo'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): ClientDto {
    data = typeof data === 'object' ? data : {};
    let result = new ClientDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['commercialRegisterNumber'] = this.commercialRegisterNumber;
    data['identification'] = this.identification;
    data['isActive'] = this.isActive;
    data['type'] = this.type;
    data['address'] = this.address ? this.address.toJSON() : <any>undefined;
    data['contactInfo'] = this.contactInfo ? this.contactInfo.toJSON() : <any>undefined;
    return data;
  }
}

export interface IClientDto {
  name?: string | undefined;
  commercialRegisterNumber?: string | undefined;
  identification?: string | undefined;
  isActive?: boolean;
  type?: ClientType;
  address?: NationalAddressDto | undefined;
  contactInfo?: ClientContactInfoDto | undefined;
}

export enum ClientType {
  Governmental = 0,
  SemiGovernmental = 1,
  PrivateCompany = 2,
  PrivateIndividual = 3,
}

export class NationalAddressDto implements INationalAddressDto {
  id?: string | undefined;
  countryId?: string | undefined;
  cityId?: string | undefined;
  shortAddress?: string | undefined;
  street?: string | undefined;
  buildingNumber?: number;

  constructor(data?: INationalAddressDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.countryId = _data['countryId'];
      this.cityId = _data['cityId'];
      this.shortAddress = _data['shortAddress'];
      this.street = _data['street'];
      this.buildingNumber = _data['buildingNumber'];
    }
  }

  static fromJS(data: any): NationalAddressDto {
    data = typeof data === 'object' ? data : {};
    let result = new NationalAddressDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['countryId'] = this.countryId;
    data['cityId'] = this.cityId;
    data['shortAddress'] = this.shortAddress;
    data['street'] = this.street;
    data['buildingNumber'] = this.buildingNumber;
    return data;
  }
}

export interface INationalAddressDto {
  id?: string | undefined;
  countryId?: string | undefined;
  cityId?: string | undefined;
  shortAddress?: string | undefined;
  street?: string | undefined;
  buildingNumber?: number;
}

export class ClientContactInfoDto implements IClientContactInfoDto {
  id?: string | undefined;
  name?: string | undefined;
  phoneNumber?: string | undefined;
  phoneNumber2?: string | undefined;
  email?: string | undefined;
  postalCode?: string | undefined;
  faxNumber?: string | undefined;
  clientId?: string | undefined;

  constructor(data?: IClientContactInfoDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.phoneNumber = _data['phoneNumber'];
      this.phoneNumber2 = _data['phoneNumber2'];
      this.email = _data['email'];
      this.postalCode = _data['postalCode'];
      this.faxNumber = _data['faxNumber'];
      this.clientId = _data['clientId'];
    }
  }

  static fromJS(data: any): ClientContactInfoDto {
    data = typeof data === 'object' ? data : {};
    let result = new ClientContactInfoDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['phoneNumber'] = this.phoneNumber;
    data['phoneNumber2'] = this.phoneNumber2;
    data['email'] = this.email;
    data['postalCode'] = this.postalCode;
    data['faxNumber'] = this.faxNumber;
    data['clientId'] = this.clientId;
    return data;
  }
}

export interface IClientContactInfoDto {
  id?: string | undefined;
  name?: string | undefined;
  phoneNumber?: string | undefined;
  phoneNumber2?: string | undefined;
  email?: string | undefined;
  postalCode?: string | undefined;
  faxNumber?: string | undefined;
  clientId?: string | undefined;
}

export class ClientVm implements IClientVm {
  id?: string | undefined;
  name?: string | undefined;
  commercialRegisterNumber?: string | undefined;
  identification?: string | undefined;
  isActive?: boolean;
  type?: ClientType;
  address?: NationalAddressVm | undefined;
  contactInfo?: ClientContactInfoVm | undefined;

  constructor(data?: IClientVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.commercialRegisterNumber = _data['commercialRegisterNumber'];
      this.identification = _data['identification'];
      this.isActive = _data['isActive'];
      this.type = _data['type'];
      this.address = _data['address']
        ? NationalAddressVm.fromJS(_data['address'])
        : <any>undefined;
      this.contactInfo = _data['contactInfo']
        ? ClientContactInfoVm.fromJS(_data['contactInfo'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): ClientVm {
    data = typeof data === 'object' ? data : {};
    let result = new ClientVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['commercialRegisterNumber'] = this.commercialRegisterNumber;
    data['identification'] = this.identification;
    data['isActive'] = this.isActive;
    data['type'] = this.type;
    data['address'] = this.address ? this.address.toJSON() : <any>undefined;
    data['contactInfo'] = this.contactInfo ? this.contactInfo.toJSON() : <any>undefined;
    return data;
  }
}

export interface IClientVm {
  id?: string | undefined;
  name?: string | undefined;
  commercialRegisterNumber?: string | undefined;
  identification?: string | undefined;
  isActive?: boolean;
  type?: ClientType;
  address?: NationalAddressVm | undefined;
  contactInfo?: ClientContactInfoVm | undefined;
}

export class NationalAddressVm implements INationalAddressVm {
  id?: string | undefined;
  country?: ClientCountryVm | undefined;
  city?: ClientCityVM | undefined;
  shortAddress?: string | undefined;
  street?: string | undefined;
  buildingNumber?: number;

  constructor(data?: INationalAddressVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.country = _data['country']
        ? ClientCountryVm.fromJS(_data['country'])
        : <any>undefined;
      this.city = _data['city'] ? ClientCityVM.fromJS(_data['city']) : <any>undefined;
      this.shortAddress = _data['shortAddress'];
      this.street = _data['street'];
      this.buildingNumber = _data['buildingNumber'];
    }
  }

  static fromJS(data: any): NationalAddressVm {
    data = typeof data === 'object' ? data : {};
    let result = new NationalAddressVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['country'] = this.country ? this.country.toJSON() : <any>undefined;
    data['city'] = this.city ? this.city.toJSON() : <any>undefined;
    data['shortAddress'] = this.shortAddress;
    data['street'] = this.street;
    data['buildingNumber'] = this.buildingNumber;
    return data;
  }
}

export interface INationalAddressVm {
  id?: string | undefined;
  country?: ClientCountryVm | undefined;
  city?: ClientCityVM | undefined;
  shortAddress?: string | undefined;
  street?: string | undefined;
  buildingNumber?: number;
}

export class ClientCountryVm implements IClientCountryVm {
  id?: string | undefined;
  name?: LocalizedStringDto | undefined;

  constructor(data?: IClientCountryVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): ClientCountryVm {
    data = typeof data === 'object' ? data : {};
    let result = new ClientCountryVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    return data;
  }
}

export interface IClientCountryVm {
  id?: string | undefined;
  name?: LocalizedStringDto | undefined;
}

export class ClientCityVM implements IClientCityVM {
  id?: string | undefined;
  name?: LocalizedStringDto | undefined;

  constructor(data?: IClientCityVM) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): ClientCityVM {
    data = typeof data === 'object' ? data : {};
    let result = new ClientCityVM();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    return data;
  }
}

export interface IClientCityVM {
  id?: string | undefined;
  name?: LocalizedStringDto | undefined;
}

export class ClientContactInfoVm implements IClientContactInfoVm {
  id?: string | undefined;
  name?: string | undefined;
  phoneNumber?: string | undefined;
  email?: string | undefined;
  phoneNumber2?: string | undefined;
  postalCode?: string | undefined;
  faxNumber?: string | undefined;

  constructor(data?: IClientContactInfoVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.phoneNumber = _data['phoneNumber'];
      this.email = _data['email'];
      this.phoneNumber2 = _data['phoneNumber2'];
      this.postalCode = _data['postalCode'];
      this.faxNumber = _data['faxNumber'];
    }
  }

  static fromJS(data: any): ClientContactInfoVm {
    data = typeof data === 'object' ? data : {};
    let result = new ClientContactInfoVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['phoneNumber'] = this.phoneNumber;
    data['email'] = this.email;
    data['phoneNumber2'] = this.phoneNumber2;
    data['postalCode'] = this.postalCode;
    data['faxNumber'] = this.faxNumber;
    return data;
  }
}

export interface IClientContactInfoVm {
  id?: string | undefined;
  name?: string | undefined;
  phoneNumber?: string | undefined;
  email?: string | undefined;
  phoneNumber2?: string | undefined;
  postalCode?: string | undefined;
  faxNumber?: string | undefined;
}

export class PaginatedListOfClientVm implements IPaginatedListOfClientVm {
  pageInfo?: PageInfo | undefined;
  items?: ClientVm[] | undefined;

  constructor(data?: IPaginatedListOfClientVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(ClientVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfClientVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfClientVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfClientVm {
  pageInfo?: PageInfo | undefined;
  items?: ClientVm[] | undefined;
}

export class CommerceChamberVm implements ICommerceChamberVm {
  id?: string | undefined;
  name?: LocalizedStringDto | undefined;

  constructor(data?: ICommerceChamberVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): CommerceChamberVm {
    data = typeof data === 'object' ? data : {};
    let result = new CommerceChamberVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICommerceChamberVm {
  id?: string | undefined;
  name?: LocalizedStringDto | undefined;
}

export class PaginatedListOfCommerceChamberVm
  implements IPaginatedListOfCommerceChamberVm
{
  pageInfo?: PageInfo | undefined;
  items?: CommerceChamberVm[] | undefined;

  constructor(data?: IPaginatedListOfCommerceChamberVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(CommerceChamberVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfCommerceChamberVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfCommerceChamberVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfCommerceChamberVm {
  pageInfo?: PageInfo | undefined;
  items?: CommerceChamberVm[] | undefined;
}

export class CommerceChamberDetailsVm implements ICommerceChamberDetailsVm {
  id?: string | undefined;
  name?: LocalizedStringDto | undefined;
  delegations?: CommerceChamberDelegationVm[] | undefined;

  constructor(data?: ICommerceChamberDetailsVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
      if (Array.isArray(_data['delegations'])) {
        this.delegations = [] as any;
        for (let item of _data['delegations'])
          this.delegations!.push(CommerceChamberDelegationVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): CommerceChamberDetailsVm {
    data = typeof data === 'object' ? data : {};
    let result = new CommerceChamberDetailsVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    if (Array.isArray(this.delegations)) {
      data['delegations'] = [];
      for (let item of this.delegations) data['delegations'].push(item.toJSON());
    }
    return data;
  }
}

export interface ICommerceChamberDetailsVm {
  id?: string | undefined;
  name?: LocalizedStringDto | undefined;
  delegations?: CommerceChamberDelegationVm[] | undefined;
}

export class CommerceChamberDelegationVm implements ICommerceChamberDelegationVm {
  id?: string | undefined;
  documentNumber?: number;
  delegatedToName?: string | undefined;
  commerceChamberId?: string | undefined;

  constructor(data?: ICommerceChamberDelegationVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.documentNumber = _data['documentNumber'];
      this.delegatedToName = _data['delegatedToName'];
      this.commerceChamberId = _data['commerceChamberId'];
    }
  }

  static fromJS(data: any): CommerceChamberDelegationVm {
    data = typeof data === 'object' ? data : {};
    let result = new CommerceChamberDelegationVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['documentNumber'] = this.documentNumber;
    data['delegatedToName'] = this.delegatedToName;
    data['commerceChamberId'] = this.commerceChamberId;
    return data;
  }
}

export interface ICommerceChamberDelegationVm {
  id?: string | undefined;
  documentNumber?: number;
  delegatedToName?: string | undefined;
  commerceChamberId?: string | undefined;
}

export class CommerceChamberCreateDto implements ICommerceChamberCreateDto {
  name?: LocalizedStringDto | undefined;
  delegations?: DelegationDto[] | undefined;

  constructor(data?: ICommerceChamberCreateDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
      if (Array.isArray(_data['delegations'])) {
        this.delegations = [] as any;
        for (let item of _data['delegations'])
          this.delegations!.push(DelegationDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): CommerceChamberCreateDto {
    data = typeof data === 'object' ? data : {};
    let result = new CommerceChamberCreateDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    if (Array.isArray(this.delegations)) {
      data['delegations'] = [];
      for (let item of this.delegations) data['delegations'].push(item.toJSON());
    }
    return data;
  }
}

export interface ICommerceChamberCreateDto {
  name?: LocalizedStringDto | undefined;
  delegations?: DelegationDto[] | undefined;
}

export class DelegationDto implements IDelegationDto {
  documentNumber?: number;
  delegatedToName?: string | undefined;
  notes?: string | undefined;
  commerceChamberId?: string | undefined;
  contractId?: string | undefined;
  savingType?: SavingType;

  constructor(data?: IDelegationDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.documentNumber = _data['documentNumber'];
      this.delegatedToName = _data['delegatedToName'];
      this.notes = _data['notes'];
      this.commerceChamberId = _data['commerceChamberId'];
      this.contractId = _data['contractId'];
      this.savingType = _data['savingType'];
    }
  }

  static fromJS(data: any): DelegationDto {
    data = typeof data === 'object' ? data : {};
    let result = new DelegationDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['documentNumber'] = this.documentNumber;
    data['delegatedToName'] = this.delegatedToName;
    data['notes'] = this.notes;
    data['commerceChamberId'] = this.commerceChamberId;
    data['contractId'] = this.contractId;
    data['savingType'] = this.savingType;
    return data;
  }
}

export interface IDelegationDto {
  documentNumber?: number;
  delegatedToName?: string | undefined;
  notes?: string | undefined;
  commerceChamberId?: string | undefined;
  contractId?: string | undefined;
  savingType?: SavingType;
}

export enum SavingType {
  Draft = 0,
  Save = 1,
}

export class CommerceChamberUpdateDto implements ICommerceChamberUpdateDto {
  name?: LocalizedStringDto | undefined;

  constructor(data?: ICommerceChamberUpdateDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): CommerceChamberUpdateDto {
    data = typeof data === 'object' ? data : {};
    let result = new CommerceChamberUpdateDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICommerceChamberUpdateDto {
  name?: LocalizedStringDto | undefined;
}

export class ContractMainDataDto implements IContractMainDataDto {
  name?: string | undefined;
  refNumber?: string | undefined;
  countryId?: string | undefined;
  clientId?: string | undefined;
  competitionType?: CompetitionType;

  constructor(data?: IContractMainDataDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.refNumber = _data['refNumber'];
      this.countryId = _data['countryId'];
      this.clientId = _data['clientId'];
      this.competitionType = _data['competitionType'];
    }
  }

  static fromJS(data: any): ContractMainDataDto {
    data = typeof data === 'object' ? data : {};
    let result = new ContractMainDataDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['refNumber'] = this.refNumber;
    data['countryId'] = this.countryId;
    data['clientId'] = this.clientId;
    data['competitionType'] = this.competitionType;
    return data;
  }
}

export interface IContractMainDataDto {
  name?: string | undefined;
  refNumber?: string | undefined;
  countryId?: string | undefined;
  clientId?: string | undefined;
  competitionType?: CompetitionType;
}

export enum CompetitionType {
  Competition = 0,
  DirectOrder = 1,
}

export class ContractAwardInfoDto implements IContractAwardInfoDto {
  awardNumber?: string | undefined;
  awardOrderIssuanceDate?: Date;
  awardOrderIssuanceHijriDate?: Date;
  receiptAwardOrderDate?: Date;
  receiptAwardOrderHijriDate?: Date;
  itimadCompetitionNumber?: string | undefined;
  displayNumber?: string | undefined;
  initialTotalPrice?: number;
  discountPercentage?: number;
  vatPercentage?: number;
  contractId?: string | undefined;
  savingType?: SavingType;

  constructor(data?: IContractAwardInfoDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.awardNumber = _data['awardNumber'];
      this.awardOrderIssuanceDate = _data['awardOrderIssuanceDate']
        ? new Date(_data['awardOrderIssuanceDate'].toString())
        : <any>undefined;
      this.awardOrderIssuanceHijriDate = _data['awardOrderIssuanceHijriDate']
        ? new Date(_data['awardOrderIssuanceHijriDate'].toString())
        : <any>undefined;
      this.receiptAwardOrderDate = _data['receiptAwardOrderDate']
        ? new Date(_data['receiptAwardOrderDate'].toString())
        : <any>undefined;
      this.receiptAwardOrderHijriDate = _data['receiptAwardOrderHijriDate']
        ? new Date(_data['receiptAwardOrderHijriDate'].toString())
        : <any>undefined;
      this.itimadCompetitionNumber = _data['itimadCompetitionNumber'];
      this.displayNumber = _data['displayNumber'];
      this.initialTotalPrice = _data['initialTotalPrice'];
      this.discountPercentage = _data['discountPercentage'];
      this.vatPercentage = _data['vatPercentage'];
      this.contractId = _data['contractId'];
      this.savingType = _data['savingType'];
    }
  }

  static fromJS(data: any): ContractAwardInfoDto {
    data = typeof data === 'object' ? data : {};
    let result = new ContractAwardInfoDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['awardNumber'] = this.awardNumber;
    data['awardOrderIssuanceDate'] = this.awardOrderIssuanceDate
      ? this.awardOrderIssuanceDate.toISOString()
      : <any>undefined;
    data['awardOrderIssuanceHijriDate'] = this.awardOrderIssuanceHijriDate
      ? this.awardOrderIssuanceHijriDate.toISOString()
      : <any>undefined;
    data['receiptAwardOrderDate'] = this.receiptAwardOrderDate
      ? this.receiptAwardOrderDate.toISOString()
      : <any>undefined;
    data['receiptAwardOrderHijriDate'] = this.receiptAwardOrderHijriDate
      ? this.receiptAwardOrderHijriDate.toISOString()
      : <any>undefined;
    data['itimadCompetitionNumber'] = this.itimadCompetitionNumber;
    data['displayNumber'] = this.displayNumber;
    data['initialTotalPrice'] = this.initialTotalPrice;
    data['discountPercentage'] = this.discountPercentage;
    data['vatPercentage'] = this.vatPercentage;
    data['contractId'] = this.contractId;
    data['savingType'] = this.savingType;
    return data;
  }
}

export interface IContractAwardInfoDto {
  awardNumber?: string | undefined;
  awardOrderIssuanceDate?: Date;
  awardOrderIssuanceHijriDate?: Date;
  receiptAwardOrderDate?: Date;
  receiptAwardOrderHijriDate?: Date;
  itimadCompetitionNumber?: string | undefined;
  displayNumber?: string | undefined;
  initialTotalPrice?: number;
  discountPercentage?: number;
  vatPercentage?: number;
  contractId?: string | undefined;
  savingType?: SavingType;
}

export class BankGuaranteeDto implements IBankGuaranteeDto {
  receivedOrganization?: string | undefined;
  bankGuaranteePercentage?: number;
  isBankHasFinalGuarantee?: boolean;
  bankGuaranteeValidityFrom?: Date | undefined;
  bankGuaranteeValidityTo?: Date | undefined;
  notes?: string | undefined;
  bankId?: string | undefined;
  contractId?: string | undefined;
  savingType?: SavingType;

  constructor(data?: IBankGuaranteeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.receivedOrganization = _data['receivedOrganization'];
      this.bankGuaranteePercentage = _data['bankGuaranteePercentage'];
      this.isBankHasFinalGuarantee = _data['isBankHasFinalGuarantee'];
      this.bankGuaranteeValidityFrom = _data['bankGuaranteeValidityFrom']
        ? new Date(_data['bankGuaranteeValidityFrom'].toString())
        : <any>undefined;
      this.bankGuaranteeValidityTo = _data['bankGuaranteeValidityTo']
        ? new Date(_data['bankGuaranteeValidityTo'].toString())
        : <any>undefined;
      this.notes = _data['notes'];
      this.bankId = _data['bankId'];
      this.contractId = _data['contractId'];
      this.savingType = _data['savingType'];
    }
  }

  static fromJS(data: any): BankGuaranteeDto {
    data = typeof data === 'object' ? data : {};
    let result = new BankGuaranteeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['receivedOrganization'] = this.receivedOrganization;
    data['bankGuaranteePercentage'] = this.bankGuaranteePercentage;
    data['isBankHasFinalGuarantee'] = this.isBankHasFinalGuarantee;
    data['bankGuaranteeValidityFrom'] = this.bankGuaranteeValidityFrom
      ? this.bankGuaranteeValidityFrom.toISOString()
      : <any>undefined;
    data['bankGuaranteeValidityTo'] = this.bankGuaranteeValidityTo
      ? this.bankGuaranteeValidityTo.toISOString()
      : <any>undefined;
    data['notes'] = this.notes;
    data['bankId'] = this.bankId;
    data['contractId'] = this.contractId;
    data['savingType'] = this.savingType;
    return data;
  }
}

export interface IBankGuaranteeDto {
  receivedOrganization?: string | undefined;
  bankGuaranteePercentage?: number;
  isBankHasFinalGuarantee?: boolean;
  bankGuaranteeValidityFrom?: Date | undefined;
  bankGuaranteeValidityTo?: Date | undefined;
  notes?: string | undefined;
  bankId?: string | undefined;
  contractId?: string | undefined;
  savingType?: SavingType;
}

export class BankVm implements IBankVm {
  id?: string | undefined;
  name?: WeakLocalizedString | undefined;

  constructor(data?: IBankVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name']
        ? WeakLocalizedString.fromJS(_data['name'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): BankVm {
    data = typeof data === 'object' ? data : {};
    let result = new BankVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    return data;
  }
}

export interface IBankVm {
  id?: string | undefined;
  name?: WeakLocalizedString | undefined;
}

export class ContractDetailsDto implements IContractDetailsDto {
  name?: string | undefined;
  refNumber?: string | undefined;
  issuanceDate?: Date;
  issuanceHijriDate?: Date;
  contractSigningDate?: Date;
  dateReceiptHardCopy?: Date;
  period?: PeriodDto | undefined;
  contractStatus?: ContractStatus;
  contractTypeId?: string | undefined;
  contractId?: string | undefined;
  clientId?: string | undefined;
  savingType?: SavingType;

  constructor(data?: IContractDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.refNumber = _data['refNumber'];
      this.issuanceDate = _data['issuanceDate']
        ? new Date(_data['issuanceDate'].toString())
        : <any>undefined;
      this.issuanceHijriDate = _data['issuanceHijriDate']
        ? new Date(_data['issuanceHijriDate'].toString())
        : <any>undefined;
      this.contractSigningDate = _data['contractSigningDate']
        ? new Date(_data['contractSigningDate'].toString())
        : <any>undefined;
      this.dateReceiptHardCopy = _data['dateReceiptHardCopy']
        ? new Date(_data['dateReceiptHardCopy'].toString())
        : <any>undefined;
      this.period = _data['period'] ? PeriodDto.fromJS(_data['period']) : <any>undefined;
      this.contractStatus = _data['contractStatus'];
      this.contractTypeId = _data['contractTypeId'];
      this.contractId = _data['contractId'];
      this.clientId = _data['clientId'];
      this.savingType = _data['savingType'];
    }
  }

  static fromJS(data: any): ContractDetailsDto {
    data = typeof data === 'object' ? data : {};
    let result = new ContractDetailsDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['refNumber'] = this.refNumber;
    data['issuanceDate'] = this.issuanceDate
      ? this.issuanceDate.toISOString()
      : <any>undefined;
    data['issuanceHijriDate'] = this.issuanceHijriDate
      ? this.issuanceHijriDate.toISOString()
      : <any>undefined;
    data['contractSigningDate'] = this.contractSigningDate
      ? this.contractSigningDate.toISOString()
      : <any>undefined;
    data['dateReceiptHardCopy'] = this.dateReceiptHardCopy
      ? this.dateReceiptHardCopy.toISOString()
      : <any>undefined;
    data['period'] = this.period ? this.period.toJSON() : <any>undefined;
    data['contractStatus'] = this.contractStatus;
    data['contractTypeId'] = this.contractTypeId;
    data['contractId'] = this.contractId;
    data['clientId'] = this.clientId;
    data['savingType'] = this.savingType;
    return data;
  }
}

export interface IContractDetailsDto {
  name?: string | undefined;
  refNumber?: string | undefined;
  issuanceDate?: Date;
  issuanceHijriDate?: Date;
  contractSigningDate?: Date;
  dateReceiptHardCopy?: Date;
  period?: PeriodDto | undefined;
  contractStatus?: ContractStatus;
  contractTypeId?: string | undefined;
  contractId?: string | undefined;
  clientId?: string | undefined;
  savingType?: SavingType;
}

export class PeriodDto implements IPeriodDto {
  years?: number;
  months?: number;
  days?: number;

  constructor(data?: IPeriodDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.years = _data['years'];
      this.months = _data['months'];
      this.days = _data['days'];
    }
  }

  static fromJS(data: any): PeriodDto {
    data = typeof data === 'object' ? data : {};
    let result = new PeriodDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['years'] = this.years;
    data['months'] = this.months;
    data['days'] = this.days;
    return data;
  }
}

export interface IPeriodDto {
  years?: number;
  months?: number;
  days?: number;
}

export enum ContractStatus {
  Draft = 0,
  Started = 1,
  NotStarted = 2,
  InitialReceipt = 3,
  FinalReceipt = 4,
  InProgress = 5,
  Canceled = 6,
  Finished = 7,
}

export class PaginatedListOfContractMainDataPageVm
  implements IPaginatedListOfContractMainDataPageVm
{
  pageInfo?: PageInfo | undefined;
  items?: ContractMainDataPageVm[] | undefined;

  constructor(data?: IPaginatedListOfContractMainDataPageVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items'])
          this.items!.push(ContractMainDataPageVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfContractMainDataPageVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfContractMainDataPageVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfContractMainDataPageVm {
  pageInfo?: PageInfo | undefined;
  items?: ContractMainDataPageVm[] | undefined;
}

export class ContractMainDataPageVm implements IContractMainDataPageVm {
  id?: string | undefined;
  name?: string | undefined;
  refNumber?: string | undefined;
  status?: ContractStatus;
  clientName?: string | undefined;
  createAt?: Date;
  contractType?: string | undefined;
  lastStep?: number;

  constructor(data?: IContractMainDataPageVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.refNumber = _data['refNumber'];
      this.status = _data['status'];
      this.clientName = _data['clientName'];
      this.createAt = _data['createAt']
        ? new Date(_data['createAt'].toString())
        : <any>undefined;
      this.contractType = _data['contractType'];
      this.lastStep = _data['lastStep'];
    }
  }

  static fromJS(data: any): ContractMainDataPageVm {
    data = typeof data === 'object' ? data : {};
    let result = new ContractMainDataPageVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['refNumber'] = this.refNumber;
    data['status'] = this.status;
    data['clientName'] = this.clientName;
    data['createAt'] = this.createAt ? this.createAt.toISOString() : <any>undefined;
    data['contractType'] = this.contractType;
    data['lastStep'] = this.lastStep;
    return data;
  }
}

export interface IContractMainDataPageVm {
  id?: string | undefined;
  name?: string | undefined;
  refNumber?: string | undefined;
  status?: ContractStatus;
  clientName?: string | undefined;
  createAt?: Date;
  contractType?: string | undefined;
  lastStep?: number;
}

export class ContractMainDataVm implements IContractMainDataVm {
  id?: string | undefined;
  name?: string | undefined;
  refNumber?: string | undefined;
  clientId?: string | undefined;
  countryId?: string | undefined;
  stepNumber?: number;
  lastStep?: number;
  competitionType?: CompetitionType;

  constructor(data?: IContractMainDataVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.refNumber = _data['refNumber'];
      this.clientId = _data['clientId'];
      this.countryId = _data['countryId'];
      this.stepNumber = _data['stepNumber'];
      this.lastStep = _data['lastStep'];
      this.competitionType = _data['competitionType'];
    }
  }

  static fromJS(data: any): ContractMainDataVm {
    data = typeof data === 'object' ? data : {};
    let result = new ContractMainDataVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['refNumber'] = this.refNumber;
    data['clientId'] = this.clientId;
    data['countryId'] = this.countryId;
    data['stepNumber'] = this.stepNumber;
    data['lastStep'] = this.lastStep;
    data['competitionType'] = this.competitionType;
    return data;
  }
}

export interface IContractMainDataVm {
  id?: string | undefined;
  name?: string | undefined;
  refNumber?: string | undefined;
  clientId?: string | undefined;
  countryId?: string | undefined;
  stepNumber?: number;
  lastStep?: number;
  competitionType?: CompetitionType;
}

export class ContractAwardInfoVm implements IContractAwardInfoVm {
  id?: string | undefined;
  awardNumber?: string | undefined;
  awardOrderIssuanceDate?: Date | undefined;
  awardOrderIssuanceHijriDate?: Date | undefined;
  receiptAwardOrderDate?: Date | undefined;
  receiptAwardOrderHijriDate?: Date | undefined;
  itimadCompetitionNumber?: string | undefined;
  displayNumber?: string | undefined;
  files?: ContractFileVM[] | undefined;
  initialTotalPrice?: number;
  discountPercentage?: number;
  vatPercentage?: number;
  totalPriceAfterDiscount?: number;
  finalTotalPrice?: number;
  contractId?: string | undefined;
  stepNumber?: number;
  lastStep?: number | undefined;

  constructor(data?: IContractAwardInfoVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.awardNumber = _data['awardNumber'];
      this.awardOrderIssuanceDate = _data['awardOrderIssuanceDate']
        ? new Date(_data['awardOrderIssuanceDate'].toString())
        : <any>undefined;
      this.awardOrderIssuanceHijriDate = _data['awardOrderIssuanceHijriDate']
        ? new Date(_data['awardOrderIssuanceHijriDate'].toString())
        : <any>undefined;
      this.receiptAwardOrderDate = _data['receiptAwardOrderDate']
        ? new Date(_data['receiptAwardOrderDate'].toString())
        : <any>undefined;
      this.receiptAwardOrderHijriDate = _data['receiptAwardOrderHijriDate']
        ? new Date(_data['receiptAwardOrderHijriDate'].toString())
        : <any>undefined;
      this.itimadCompetitionNumber = _data['itimadCompetitionNumber'];
      this.displayNumber = _data['displayNumber'];
      if (Array.isArray(_data['files'])) {
        this.files = [] as any;
        for (let item of _data['files']) this.files!.push(ContractFileVM.fromJS(item));
      }
      this.initialTotalPrice = _data['initialTotalPrice'];
      this.discountPercentage = _data['discountPercentage'];
      this.vatPercentage = _data['vatPercentage'];
      this.totalPriceAfterDiscount = _data['totalPriceAfterDiscount'];
      this.finalTotalPrice = _data['finalTotalPrice'];
      this.contractId = _data['contractId'];
      this.stepNumber = _data['stepNumber'];
      this.lastStep = _data['lastStep'];
    }
  }

  static fromJS(data: any): ContractAwardInfoVm {
    data = typeof data === 'object' ? data : {};
    let result = new ContractAwardInfoVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['awardNumber'] = this.awardNumber;
    data['awardOrderIssuanceDate'] = this.awardOrderIssuanceDate
      ? this.awardOrderIssuanceDate.toISOString()
      : <any>undefined;
    data['awardOrderIssuanceHijriDate'] = this.awardOrderIssuanceHijriDate
      ? this.awardOrderIssuanceHijriDate.toISOString()
      : <any>undefined;
    data['receiptAwardOrderDate'] = this.receiptAwardOrderDate
      ? this.receiptAwardOrderDate.toISOString()
      : <any>undefined;
    data['receiptAwardOrderHijriDate'] = this.receiptAwardOrderHijriDate
      ? this.receiptAwardOrderHijriDate.toISOString()
      : <any>undefined;
    data['itimadCompetitionNumber'] = this.itimadCompetitionNumber;
    data['displayNumber'] = this.displayNumber;
    if (Array.isArray(this.files)) {
      data['files'] = [];
      for (let item of this.files) data['files'].push(item.toJSON());
    }
    data['initialTotalPrice'] = this.initialTotalPrice;
    data['discountPercentage'] = this.discountPercentage;
    data['vatPercentage'] = this.vatPercentage;
    data['totalPriceAfterDiscount'] = this.totalPriceAfterDiscount;
    data['finalTotalPrice'] = this.finalTotalPrice;
    data['contractId'] = this.contractId;
    data['stepNumber'] = this.stepNumber;
    data['lastStep'] = this.lastStep;
    return data;
  }
}

export interface IContractAwardInfoVm {
  id?: string | undefined;
  awardNumber?: string | undefined;
  awardOrderIssuanceDate?: Date | undefined;
  awardOrderIssuanceHijriDate?: Date | undefined;
  receiptAwardOrderDate?: Date | undefined;
  receiptAwardOrderHijriDate?: Date | undefined;
  itimadCompetitionNumber?: string | undefined;
  displayNumber?: string | undefined;
  files?: ContractFileVM[] | undefined;
  initialTotalPrice?: number;
  discountPercentage?: number;
  vatPercentage?: number;
  totalPriceAfterDiscount?: number;
  finalTotalPrice?: number;
  contractId?: string | undefined;
  stepNumber?: number;
  lastStep?: number | undefined;
}

export class ContractFileVM implements IContractFileVM {
  fileName?: string | undefined;
  fileDisplayName?: string | undefined;

  constructor(data?: IContractFileVM) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.fileName = _data['fileName'];
      this.fileDisplayName = _data['fileDisplayName'];
    }
  }

  static fromJS(data: any): ContractFileVM {
    data = typeof data === 'object' ? data : {};
    let result = new ContractFileVM();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['fileName'] = this.fileName;
    data['fileDisplayName'] = this.fileDisplayName;
    return data;
  }
}

export interface IContractFileVM {
  fileName?: string | undefined;
  fileDisplayName?: string | undefined;
}

export class BankGuaranteeVm implements IBankGuaranteeVm {
  id?: string | undefined;
  receivedOrganization?: string | undefined;
  bankGuaranteePercentage?: number;
  isBankHasFinalGuarantee?: boolean;
  awardTotalPrice?: number;
  bankGuaranteeAmount?: number;
  bankGuaranteeValidityFrom?: Date | undefined;
  bankGuaranteeValidityTo?: Date | undefined;
  notes?: string | undefined;
  filesName?: ContractFileVM[] | undefined;
  bankId?: string | undefined;
  awardOrderIssuanceDate?: Date | undefined;
  contractId?: string | undefined;
  stepNumber?: number;
  lastStep?: number | undefined;

  constructor(data?: IBankGuaranteeVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.receivedOrganization = _data['receivedOrganization'];
      this.bankGuaranteePercentage = _data['bankGuaranteePercentage'];
      this.isBankHasFinalGuarantee = _data['isBankHasFinalGuarantee'];
      this.awardTotalPrice = _data['awardTotalPrice'];
      this.bankGuaranteeAmount = _data['bankGuaranteeAmount'];
      this.bankGuaranteeValidityFrom = _data['bankGuaranteeValidityFrom']
        ? new Date(_data['bankGuaranteeValidityFrom'].toString())
        : <any>undefined;
      this.bankGuaranteeValidityTo = _data['bankGuaranteeValidityTo']
        ? new Date(_data['bankGuaranteeValidityTo'].toString())
        : <any>undefined;
      this.notes = _data['notes'];
      if (Array.isArray(_data['filesName'])) {
        this.filesName = [] as any;
        for (let item of _data['filesName'])
          this.filesName!.push(ContractFileVM.fromJS(item));
      }
      this.bankId = _data['bankId'];
      this.awardOrderIssuanceDate = _data['awardOrderIssuanceDate']
        ? new Date(_data['awardOrderIssuanceDate'].toString())
        : <any>undefined;
      this.contractId = _data['contractId'];
      this.stepNumber = _data['stepNumber'];
      this.lastStep = _data['lastStep'];
    }
  }

  static fromJS(data: any): BankGuaranteeVm {
    data = typeof data === 'object' ? data : {};
    let result = new BankGuaranteeVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['receivedOrganization'] = this.receivedOrganization;
    data['bankGuaranteePercentage'] = this.bankGuaranteePercentage;
    data['isBankHasFinalGuarantee'] = this.isBankHasFinalGuarantee;
    data['awardTotalPrice'] = this.awardTotalPrice;
    data['bankGuaranteeAmount'] = this.bankGuaranteeAmount;
    data['bankGuaranteeValidityFrom'] = this.bankGuaranteeValidityFrom
      ? this.bankGuaranteeValidityFrom.toISOString()
      : <any>undefined;
    data['bankGuaranteeValidityTo'] = this.bankGuaranteeValidityTo
      ? this.bankGuaranteeValidityTo.toISOString()
      : <any>undefined;
    data['notes'] = this.notes;
    if (Array.isArray(this.filesName)) {
      data['filesName'] = [];
      for (let item of this.filesName) data['filesName'].push(item.toJSON());
    }
    data['bankId'] = this.bankId;
    data['awardOrderIssuanceDate'] = this.awardOrderIssuanceDate
      ? this.awardOrderIssuanceDate.toISOString()
      : <any>undefined;
    data['contractId'] = this.contractId;
    data['stepNumber'] = this.stepNumber;
    data['lastStep'] = this.lastStep;
    return data;
  }
}

export interface IBankGuaranteeVm {
  id?: string | undefined;
  receivedOrganization?: string | undefined;
  bankGuaranteePercentage?: number;
  isBankHasFinalGuarantee?: boolean;
  awardTotalPrice?: number;
  bankGuaranteeAmount?: number;
  bankGuaranteeValidityFrom?: Date | undefined;
  bankGuaranteeValidityTo?: Date | undefined;
  notes?: string | undefined;
  filesName?: ContractFileVM[] | undefined;
  bankId?: string | undefined;
  awardOrderIssuanceDate?: Date | undefined;
  contractId?: string | undefined;
  stepNumber?: number;
  lastStep?: number | undefined;
}

export class ContractDetailsVm implements IContractDetailsVm {
  id?: string | undefined;
  name?: string | undefined;
  refNumber?: string | undefined;
  issuanceDate?: Date | undefined;
  issuanceHijriDate?: Date | undefined;
  contractSigningDate?: Date | undefined;
  dateReceiptHardCopy?: Date | undefined;
  bankGuaranteeValidityFrom?: Date | undefined;
  period?: PeriodDto | undefined;
  contractId?: string | undefined;
  contractTypeId?: string | undefined;
  awardOrderIssuanceDate?: Date;
  clientId?: string | undefined;
  files?: ContractFileVM[] | undefined;
  stepNumber?: number;
  contractStatus?: ContractStatus;
  lastStep?: number | undefined;

  constructor(data?: IContractDetailsVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.refNumber = _data['refNumber'];
      this.issuanceDate = _data['issuanceDate']
        ? new Date(_data['issuanceDate'].toString())
        : <any>undefined;
      this.issuanceHijriDate = _data['issuanceHijriDate']
        ? new Date(_data['issuanceHijriDate'].toString())
        : <any>undefined;
      this.contractSigningDate = _data['contractSigningDate']
        ? new Date(_data['contractSigningDate'].toString())
        : <any>undefined;
      this.dateReceiptHardCopy = _data['dateReceiptHardCopy']
        ? new Date(_data['dateReceiptHardCopy'].toString())
        : <any>undefined;
      this.bankGuaranteeValidityFrom = _data['bankGuaranteeValidityFrom']
        ? new Date(_data['bankGuaranteeValidityFrom'].toString())
        : <any>undefined;
      this.period = _data['period'] ? PeriodDto.fromJS(_data['period']) : <any>undefined;
      this.contractId = _data['contractId'];
      this.contractTypeId = _data['contractTypeId'];
      this.awardOrderIssuanceDate = _data['awardOrderIssuanceDate']
        ? new Date(_data['awardOrderIssuanceDate'].toString())
        : <any>undefined;
      this.clientId = _data['clientId'];
      if (Array.isArray(_data['files'])) {
        this.files = [] as any;
        for (let item of _data['files']) this.files!.push(ContractFileVM.fromJS(item));
      }
      this.stepNumber = _data['stepNumber'];
      this.contractStatus = _data['contractStatus'];
      this.lastStep = _data['lastStep'];
    }
  }

  static fromJS(data: any): ContractDetailsVm {
    data = typeof data === 'object' ? data : {};
    let result = new ContractDetailsVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['refNumber'] = this.refNumber;
    data['issuanceDate'] = this.issuanceDate
      ? this.issuanceDate.toISOString()
      : <any>undefined;
    data['issuanceHijriDate'] = this.issuanceHijriDate
      ? this.issuanceHijriDate.toISOString()
      : <any>undefined;
    data['contractSigningDate'] = this.contractSigningDate
      ? this.contractSigningDate.toISOString()
      : <any>undefined;
    data['dateReceiptHardCopy'] = this.dateReceiptHardCopy
      ? this.dateReceiptHardCopy.toISOString()
      : <any>undefined;
    data['bankGuaranteeValidityFrom'] = this.bankGuaranteeValidityFrom
      ? this.bankGuaranteeValidityFrom.toISOString()
      : <any>undefined;
    data['period'] = this.period ? this.period.toJSON() : <any>undefined;
    data['contractId'] = this.contractId;
    data['contractTypeId'] = this.contractTypeId;
    data['awardOrderIssuanceDate'] = this.awardOrderIssuanceDate
      ? this.awardOrderIssuanceDate.toISOString()
      : <any>undefined;
    data['clientId'] = this.clientId;
    if (Array.isArray(this.files)) {
      data['files'] = [];
      for (let item of this.files) data['files'].push(item.toJSON());
    }
    data['stepNumber'] = this.stepNumber;
    data['contractStatus'] = this.contractStatus;
    data['lastStep'] = this.lastStep;
    return data;
  }
}

export interface IContractDetailsVm {
  id?: string | undefined;
  name?: string | undefined;
  refNumber?: string | undefined;
  issuanceDate?: Date | undefined;
  issuanceHijriDate?: Date | undefined;
  contractSigningDate?: Date | undefined;
  dateReceiptHardCopy?: Date | undefined;
  bankGuaranteeValidityFrom?: Date | undefined;
  period?: PeriodDto | undefined;
  contractId?: string | undefined;
  contractTypeId?: string | undefined;
  awardOrderIssuanceDate?: Date;
  clientId?: string | undefined;
  files?: ContractFileVM[] | undefined;
  stepNumber?: number;
  contractStatus?: ContractStatus;
  lastStep?: number | undefined;
}

export class ContractFineDto implements IContractFineDto {
  description?: string | undefined;
  amount?: number;
  daysCount?: number;
  contractId?: string | undefined;
  savingType?: SavingType;

  constructor(data?: IContractFineDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.description = _data['description'];
      this.amount = _data['amount'];
      this.daysCount = _data['daysCount'];
      this.contractId = _data['contractId'];
      this.savingType = _data['savingType'];
    }
  }

  static fromJS(data: any): ContractFineDto {
    data = typeof data === 'object' ? data : {};
    let result = new ContractFineDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['description'] = this.description;
    data['amount'] = this.amount;
    data['daysCount'] = this.daysCount;
    data['contractId'] = this.contractId;
    data['savingType'] = this.savingType;
    return data;
  }
}

export interface IContractFineDto {
  description?: string | undefined;
  amount?: number;
  daysCount?: number;
  contractId?: string | undefined;
  savingType?: SavingType;
}

export class ContractFineVm implements IContractFineVm {
  id?: string | undefined;
  description?: string | undefined;
  amount?: number;
  daysCount?: number;
  contractId?: string | undefined;
  lastStep?: number | undefined;
  stepNumber?: number;

  constructor(data?: IContractFineVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.description = _data['description'];
      this.amount = _data['amount'];
      this.daysCount = _data['daysCount'];
      this.contractId = _data['contractId'];
      this.lastStep = _data['lastStep'];
      this.stepNumber = _data['stepNumber'];
    }
  }

  static fromJS(data: any): ContractFineVm {
    data = typeof data === 'object' ? data : {};
    let result = new ContractFineVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['description'] = this.description;
    data['amount'] = this.amount;
    data['daysCount'] = this.daysCount;
    data['contractId'] = this.contractId;
    data['lastStep'] = this.lastStep;
    data['stepNumber'] = this.stepNumber;
    return data;
  }
}

export interface IContractFineVm {
  id?: string | undefined;
  description?: string | undefined;
  amount?: number;
  daysCount?: number;
  contractId?: string | undefined;
  lastStep?: number | undefined;
  stepNumber?: number;
}

export class PaginatedListOfContractTypeVm implements IPaginatedListOfContractTypeVm {
  pageInfo?: PageInfo | undefined;
  items?: ContractTypeVm[] | undefined;

  constructor(data?: IPaginatedListOfContractTypeVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(ContractTypeVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfContractTypeVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfContractTypeVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfContractTypeVm {
  pageInfo?: PageInfo | undefined;
  items?: ContractTypeVm[] | undefined;
}

export class ContractTypeVm implements IContractTypeVm {
  id?: string | undefined;
  name?: LocalizedStringDto | undefined;

  constructor(data?: IContractTypeVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): ContractTypeVm {
    data = typeof data === 'object' ? data : {};
    let result = new ContractTypeVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    return data;
  }
}

export interface IContractTypeVm {
  id?: string | undefined;
  name?: LocalizedStringDto | undefined;
}

export class ContractTypeDto implements IContractTypeDto {
  name?: LocalizedStringDto | undefined;

  constructor(data?: IContractTypeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): ContractTypeDto {
    data = typeof data === 'object' ? data : {};
    let result = new ContractTypeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    return data;
  }
}

export interface IContractTypeDto {
  name?: LocalizedStringDto | undefined;
}

export class CountriesDto implements ICountriesDto {
  name?: LocalizedStringDto | undefined;
  isO1?: string | undefined;
  isO2?: string | undefined;
  vat?: number;
  currency?: CurrencyDto | undefined;

  constructor(data?: ICountriesDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
      this.isO1 = _data['isO1'];
      this.isO2 = _data['isO2'];
      this.vat = _data['vat'];
      this.currency = _data['currency']
        ? CurrencyDto.fromJS(_data['currency'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): CountriesDto {
    data = typeof data === 'object' ? data : {};
    let result = new CountriesDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    data['isO1'] = this.isO1;
    data['isO2'] = this.isO2;
    data['vat'] = this.vat;
    data['currency'] = this.currency ? this.currency.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICountriesDto {
  name?: LocalizedStringDto | undefined;
  isO1?: string | undefined;
  isO2?: string | undefined;
  vat?: number;
  currency?: CurrencyDto | undefined;
}

export class CurrencyDto implements ICurrencyDto {
  description?: LocalizedStringDto | undefined;
  code?: string | undefined;
  symbol?: string | undefined;

  constructor(data?: ICurrencyDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.description = _data['description']
        ? LocalizedStringDto.fromJS(_data['description'])
        : <any>undefined;
      this.code = _data['code'];
      this.symbol = _data['symbol'];
    }
  }

  static fromJS(data: any): CurrencyDto {
    data = typeof data === 'object' ? data : {};
    let result = new CurrencyDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['description'] = this.description ? this.description.toJSON() : <any>undefined;
    data['code'] = this.code;
    data['symbol'] = this.symbol;
    return data;
  }
}

export interface ICurrencyDto {
  description?: LocalizedStringDto | undefined;
  code?: string | undefined;
  symbol?: string | undefined;
}

export class CountryVm implements ICountryVm {
  id?: string | undefined;
  name?: LocalizedStringDto | undefined;
  vat?: number;
  cities?: CountryCityVm[] | undefined;

  constructor(data?: ICountryVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
      this.vat = _data['vat'];
      if (Array.isArray(_data['cities'])) {
        this.cities = [] as any;
        for (let item of _data['cities']) this.cities!.push(CountryCityVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): CountryVm {
    data = typeof data === 'object' ? data : {};
    let result = new CountryVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    data['vat'] = this.vat;
    if (Array.isArray(this.cities)) {
      data['cities'] = [];
      for (let item of this.cities) data['cities'].push(item.toJSON());
    }
    return data;
  }
}

export interface ICountryVm {
  id?: string | undefined;
  name?: LocalizedStringDto | undefined;
  vat?: number;
  cities?: CountryCityVm[] | undefined;
}

export class CountryCityVm implements ICountryCityVm {
  id?: string | undefined;
  name?: LocalizedStringDto | undefined;

  constructor(data?: ICountryCityVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): CountryCityVm {
    data = typeof data === 'object' ? data : {};
    let result = new CountryCityVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    return data;
  }
}

export interface ICountryCityVm {
  id?: string | undefined;
  name?: LocalizedStringDto | undefined;
}

export class PaginatedListOfCountryDetailsVm implements IPaginatedListOfCountryDetailsVm {
  pageInfo?: PageInfo | undefined;
  items?: CountryDetailsVm[] | undefined;

  constructor(data?: IPaginatedListOfCountryDetailsVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(CountryDetailsVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfCountryDetailsVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfCountryDetailsVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfCountryDetailsVm {
  pageInfo?: PageInfo | undefined;
  items?: CountryDetailsVm[] | undefined;
}

export class CountryDetailsVm implements ICountryDetailsVm {
  id?: string | undefined;
  name?: LocalizedStringDto | undefined;
  isO1?: string | undefined;
  isO2?: string | undefined;
  vat?: number;
  countryCurrency?: CurrencyDto | undefined;

  constructor(data?: ICountryDetailsVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
      this.isO1 = _data['isO1'];
      this.isO2 = _data['isO2'];
      this.vat = _data['vat'];
      this.countryCurrency = _data['countryCurrency']
        ? CurrencyDto.fromJS(_data['countryCurrency'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): CountryDetailsVm {
    data = typeof data === 'object' ? data : {};
    let result = new CountryDetailsVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    data['isO1'] = this.isO1;
    data['isO2'] = this.isO2;
    data['vat'] = this.vat;
    data['countryCurrency'] = this.countryCurrency
      ? this.countryCurrency.toJSON()
      : <any>undefined;
    return data;
  }
}

export interface ICountryDetailsVm {
  id?: string | undefined;
  name?: LocalizedStringDto | undefined;
  isO1?: string | undefined;
  isO2?: string | undefined;
  vat?: number;
  countryCurrency?: CurrencyDto | undefined;
}

export class CountriesUpdateDto implements ICountriesUpdateDto {
  vat?: number;

  constructor(data?: ICountriesUpdateDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.vat = _data['vat'];
    }
  }

  static fromJS(data: any): CountriesUpdateDto {
    data = typeof data === 'object' ? data : {};
    let result = new CountriesUpdateDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['vat'] = this.vat;
    return data;
  }
}

export interface ICountriesUpdateDto {
  vat?: number;
}

export class PaginatedListOfCovenantRequestDetailsVm
  implements IPaginatedListOfCovenantRequestDetailsVm
{
  pageInfo?: PageInfo | undefined;
  items?: CovenantRequestDetailsVm[] | undefined;

  constructor(data?: IPaginatedListOfCovenantRequestDetailsVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items'])
          this.items!.push(CovenantRequestDetailsVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfCovenantRequestDetailsVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfCovenantRequestDetailsVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfCovenantRequestDetailsVm {
  pageInfo?: PageInfo | undefined;
  items?: CovenantRequestDetailsVm[] | undefined;
}

export class CovenantRequestDetailsVm implements ICovenantRequestDetailsVm {
  id?: string | undefined;
  businessData?: string | undefined;
  requestNumber?: number;
  measurementUnitId?: string | undefined;
  projectId?: string | undefined;
  termId?: string | undefined;
  quantity?: number;
  singlePrice?: number;
  totalPriceWithoutVat?: number;
  totalPriceWithVat?: number;
  vatPrice?: number;
  notes?: string | undefined;
  createdAt?: Date;
  createdBy?: string | undefined;
  attachments?: FileAttachmentDto[] | undefined;
  term?: ProjectQuantityMainDataVm | undefined;
  measurementUnit?: MeasurementUnitVm | undefined;
  status?: CovenantRequestStatusVm;
  phase?: CovenantRequestPhaseVm;
  creatorName?: string | undefined;
  isTaxFree?: boolean;
  vat?: number;
  history?: CovenantRequestStatusLogVm[] | undefined;

  constructor(data?: ICovenantRequestDetailsVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.businessData = _data['businessData'];
      this.requestNumber = _data['requestNumber'];
      this.measurementUnitId = _data['measurementUnitId'];
      this.projectId = _data['projectId'];
      this.termId = _data['termId'];
      this.quantity = _data['quantity'];
      this.singlePrice = _data['singlePrice'];
      this.totalPriceWithoutVat = _data['totalPriceWithoutVat'];
      this.totalPriceWithVat = _data['totalPriceWithVat'];
      this.vatPrice = _data['vatPrice'];
      this.notes = _data['notes'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : <any>undefined;
      this.createdBy = _data['createdBy'];
      if (Array.isArray(_data['attachments'])) {
        this.attachments = [] as any;
        for (let item of _data['attachments'])
          this.attachments!.push(FileAttachmentDto.fromJS(item));
      }
      this.term = _data['term']
        ? ProjectQuantityMainDataVm.fromJS(_data['term'])
        : <any>undefined;
      this.measurementUnit = _data['measurementUnit']
        ? MeasurementUnitVm.fromJS(_data['measurementUnit'])
        : <any>undefined;
      this.status = _data['status'];
      this.phase = _data['phase'];
      this.creatorName = _data['creatorName'];
      this.isTaxFree = _data['isTaxFree'];
      this.vat = _data['vat'];
      if (Array.isArray(_data['history'])) {
        this.history = [] as any;
        for (let item of _data['history'])
          this.history!.push(CovenantRequestStatusLogVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): CovenantRequestDetailsVm {
    data = typeof data === 'object' ? data : {};
    let result = new CovenantRequestDetailsVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['businessData'] = this.businessData;
    data['requestNumber'] = this.requestNumber;
    data['measurementUnitId'] = this.measurementUnitId;
    data['projectId'] = this.projectId;
    data['termId'] = this.termId;
    data['quantity'] = this.quantity;
    data['singlePrice'] = this.singlePrice;
    data['totalPriceWithoutVat'] = this.totalPriceWithoutVat;
    data['totalPriceWithVat'] = this.totalPriceWithVat;
    data['vatPrice'] = this.vatPrice;
    data['notes'] = this.notes;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
    data['createdBy'] = this.createdBy;
    if (Array.isArray(this.attachments)) {
      data['attachments'] = [];
      for (let item of this.attachments) data['attachments'].push(item.toJSON());
    }
    data['term'] = this.term ? this.term.toJSON() : <any>undefined;
    data['measurementUnit'] = this.measurementUnit
      ? this.measurementUnit.toJSON()
      : <any>undefined;
    data['status'] = this.status;
    data['phase'] = this.phase;
    data['creatorName'] = this.creatorName;
    data['isTaxFree'] = this.isTaxFree;
    data['vat'] = this.vat;
    if (Array.isArray(this.history)) {
      data['history'] = [];
      for (let item of this.history) data['history'].push(item.toJSON());
    }
    return data;
  }
}

export interface ICovenantRequestDetailsVm {
  id?: string | undefined;
  businessData?: string | undefined;
  requestNumber?: number;
  measurementUnitId?: string | undefined;
  projectId?: string | undefined;
  termId?: string | undefined;
  quantity?: number;
  singlePrice?: number;
  totalPriceWithoutVat?: number;
  totalPriceWithVat?: number;
  vatPrice?: number;
  notes?: string | undefined;
  createdAt?: Date;
  createdBy?: string | undefined;
  attachments?: FileAttachmentDto[] | undefined;
  term?: ProjectQuantityMainDataVm | undefined;
  measurementUnit?: MeasurementUnitVm | undefined;
  status?: CovenantRequestStatusVm;
  phase?: CovenantRequestPhaseVm;
  creatorName?: string | undefined;
  isTaxFree?: boolean;
  vat?: number;
  history?: CovenantRequestStatusLogVm[] | undefined;
}

export class FileAttachmentDto implements IFileAttachmentDto {
  url?: string | undefined;
  uniqueKey?: string | undefined;
  uniqueName?: string | undefined;
  displayName?: string | undefined;
  extension?: string | undefined;
  subEntityId?: string | undefined;
  entityId?: string | undefined;
  attachmentSubType?: AttachmentSubType;

  constructor(data?: IFileAttachmentDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.url = _data['url'];
      this.uniqueKey = _data['uniqueKey'];
      this.uniqueName = _data['uniqueName'];
      this.displayName = _data['displayName'];
      this.extension = _data['extension'];
      this.subEntityId = _data['subEntityId'];
      this.entityId = _data['entityId'];
      this.attachmentSubType = _data['attachmentSubType'];
    }
  }

  static fromJS(data: any): FileAttachmentDto {
    data = typeof data === 'object' ? data : {};
    let result = new FileAttachmentDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['url'] = this.url;
    data['uniqueKey'] = this.uniqueKey;
    data['uniqueName'] = this.uniqueName;
    data['displayName'] = this.displayName;
    data['extension'] = this.extension;
    data['subEntityId'] = this.subEntityId;
    data['entityId'] = this.entityId;
    data['attachmentSubType'] = this.attachmentSubType;
    return data;
  }
}

export interface IFileAttachmentDto {
  url?: string | undefined;
  uniqueKey?: string | undefined;
  uniqueName?: string | undefined;
  displayName?: string | undefined;
  extension?: string | undefined;
  subEntityId?: string | undefined;
  entityId?: string | undefined;
  attachmentSubType?: AttachmentSubType;
}

export enum AttachmentSubType {
  None = 0,
  Schemes = 1,
  QuantitySurveySchedule = 2,
  ApprovedPriceQuote = 3,
}

export class ProjectQuantityMainDataVm implements IProjectQuantityMainDataVm {
  id?: string | undefined;
  title?: string | undefined;
  itemNumber?: number;
  projectId?: string | undefined;

  constructor(data?: IProjectQuantityMainDataVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.title = _data['title'];
      this.itemNumber = _data['itemNumber'];
      this.projectId = _data['projectId'];
    }
  }

  static fromJS(data: any): ProjectQuantityMainDataVm {
    data = typeof data === 'object' ? data : {};
    let result = new ProjectQuantityMainDataVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['title'] = this.title;
    data['itemNumber'] = this.itemNumber;
    data['projectId'] = this.projectId;
    return data;
  }
}

export interface IProjectQuantityMainDataVm {
  id?: string | undefined;
  title?: string | undefined;
  itemNumber?: number;
  projectId?: string | undefined;
}

export class MeasurementUnitVm implements IMeasurementUnitVm {
  id?: string | undefined;
  name?: LocalizedStringDto | undefined;
  abbreviation?: LocalizedStringDto | undefined;

  constructor(data?: IMeasurementUnitVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
      this.abbreviation = _data['abbreviation']
        ? LocalizedStringDto.fromJS(_data['abbreviation'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): MeasurementUnitVm {
    data = typeof data === 'object' ? data : {};
    let result = new MeasurementUnitVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    data['abbreviation'] = this.abbreviation
      ? this.abbreviation.toJSON()
      : <any>undefined;
    return data;
  }
}

export interface IMeasurementUnitVm {
  id?: string | undefined;
  name?: LocalizedStringDto | undefined;
  abbreviation?: LocalizedStringDto | undefined;
}

export enum CovenantRequestStatusVm {
  Pending = 0,
  Rejected = 1,
  Approved = 2,
}

export enum CovenantRequestPhaseVm {
  ProjectManagerReview = 0,
  TechnicalOfficeReview = 1,
  ProjectsManagerReview = 2,
  GeneralManagerReview = 3,
  AccountantReview = 4,
  Completed = 5,
}

export class CovenantRequestStatusLogVm implements ICovenantRequestStatusLogVm {
  id?: string | undefined;
  covenantRequestId?: string | undefined;
  status?: CovenantRequestStatus;
  notes?: string | undefined;
  createdAt?: Date;
  attachments?: FileAttachmentDto[] | undefined;
  actor?: CovenantRequestActor;

  constructor(data?: ICovenantRequestStatusLogVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.covenantRequestId = _data['covenantRequestId'];
      this.status = _data['status'];
      this.notes = _data['notes'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : <any>undefined;
      if (Array.isArray(_data['attachments'])) {
        this.attachments = [] as any;
        for (let item of _data['attachments'])
          this.attachments!.push(FileAttachmentDto.fromJS(item));
      }
      this.actor = _data['actor'];
    }
  }

  static fromJS(data: any): CovenantRequestStatusLogVm {
    data = typeof data === 'object' ? data : {};
    let result = new CovenantRequestStatusLogVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['covenantRequestId'] = this.covenantRequestId;
    data['status'] = this.status;
    data['notes'] = this.notes;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
    if (Array.isArray(this.attachments)) {
      data['attachments'] = [];
      for (let item of this.attachments) data['attachments'].push(item.toJSON());
    }
    data['actor'] = this.actor;
    return data;
  }
}

export interface ICovenantRequestStatusLogVm {
  id?: string | undefined;
  covenantRequestId?: string | undefined;
  status?: CovenantRequestStatus;
  notes?: string | undefined;
  createdAt?: Date;
  attachments?: FileAttachmentDto[] | undefined;
  actor?: CovenantRequestActor;
}

export enum CovenantRequestStatus {
  Created = 0,
  Rejected = 1,
  Approved = 2,
  Transferred = 3,
  Completed = 4,
}

export enum CovenantRequestActor {
  SiteEngineer = 0,
  ProjectManager = 1,
  TechnicalOffice = 2,
  ProjectsManager = 3,
  Accountant = 4,
  GeneralManager = 5,
}

export class CovenantRequestDto implements ICovenantRequestDto {
  businessData?: string | undefined;
  measurementUnitId?: string | undefined;
  projectId?: string | undefined;
  termId?: string | undefined;
  quantity?: number;
  singlePrice?: number;
  totalPrice?: number;
  notes?: string | undefined;
  isTaxFree?: boolean;
  vat?: number;
  attachments?: UploadAttachmentDto[] | undefined;

  constructor(data?: ICovenantRequestDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.businessData = _data['businessData'];
      this.measurementUnitId = _data['measurementUnitId'];
      this.projectId = _data['projectId'];
      this.termId = _data['termId'];
      this.quantity = _data['quantity'];
      this.singlePrice = _data['singlePrice'];
      this.totalPrice = _data['totalPrice'];
      this.notes = _data['notes'];
      this.isTaxFree = _data['isTaxFree'];
      this.vat = _data['vat'];
      if (Array.isArray(_data['attachments'])) {
        this.attachments = [] as any;
        for (let item of _data['attachments'])
          this.attachments!.push(UploadAttachmentDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): CovenantRequestDto {
    data = typeof data === 'object' ? data : {};
    let result = new CovenantRequestDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['businessData'] = this.businessData;
    data['measurementUnitId'] = this.measurementUnitId;
    data['projectId'] = this.projectId;
    data['termId'] = this.termId;
    data['quantity'] = this.quantity;
    data['singlePrice'] = this.singlePrice;
    data['totalPrice'] = this.totalPrice;
    data['notes'] = this.notes;
    data['isTaxFree'] = this.isTaxFree;
    data['vat'] = this.vat;
    if (Array.isArray(this.attachments)) {
      data['attachments'] = [];
      for (let item of this.attachments) data['attachments'].push(item.toJSON());
    }
    return data;
  }
}

export interface ICovenantRequestDto {
  businessData?: string | undefined;
  measurementUnitId?: string | undefined;
  projectId?: string | undefined;
  termId?: string | undefined;
  quantity?: number;
  singlePrice?: number;
  totalPrice?: number;
  notes?: string | undefined;
  isTaxFree?: boolean;
  vat?: number;
  attachments?: UploadAttachmentDto[] | undefined;
}

export class UploadAttachmentDto implements IUploadAttachmentDto {
  uniqueKey?: string | undefined;
  displayName?: string | undefined;
  mimeType?: string | undefined;
  sizeInBytes?: number;
  attachmentSubType?: AttachmentSubType;

  constructor(data?: IUploadAttachmentDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.uniqueKey = _data['uniqueKey'];
      this.displayName = _data['displayName'];
      this.mimeType = _data['mimeType'];
      this.sizeInBytes = _data['sizeInBytes'];
      this.attachmentSubType = _data['attachmentSubType'];
    }
  }

  static fromJS(data: any): UploadAttachmentDto {
    data = typeof data === 'object' ? data : {};
    let result = new UploadAttachmentDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['uniqueKey'] = this.uniqueKey;
    data['displayName'] = this.displayName;
    data['mimeType'] = this.mimeType;
    data['sizeInBytes'] = this.sizeInBytes;
    data['attachmentSubType'] = this.attachmentSubType;
    return data;
  }
}

export interface IUploadAttachmentDto {
  uniqueKey?: string | undefined;
  displayName?: string | undefined;
  mimeType?: string | undefined;
  sizeInBytes?: number;
  attachmentSubType?: AttachmentSubType;
}

export class ChangeCovenantRequestStatusDto implements IChangeCovenantRequestStatusDto {
  notes?: string | undefined;
  attachments?: UploadAttachmentDto[] | undefined;

  constructor(data?: IChangeCovenantRequestStatusDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.notes = _data['notes'];
      if (Array.isArray(_data['attachments'])) {
        this.attachments = [] as any;
        for (let item of _data['attachments'])
          this.attachments!.push(UploadAttachmentDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ChangeCovenantRequestStatusDto {
    data = typeof data === 'object' ? data : {};
    let result = new ChangeCovenantRequestStatusDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['notes'] = this.notes;
    if (Array.isArray(this.attachments)) {
      data['attachments'] = [];
      for (let item of this.attachments) data['attachments'].push(item.toJSON());
    }
    return data;
  }
}

export interface IChangeCovenantRequestStatusDto {
  notes?: string | undefined;
  attachments?: UploadAttachmentDto[] | undefined;
}

export class PaginatedListOfCovenantTransactionRequestVm
  implements IPaginatedListOfCovenantTransactionRequestVm
{
  pageInfo?: PageInfo | undefined;
  items?: CovenantTransactionRequestVm[] | undefined;

  constructor(data?: IPaginatedListOfCovenantTransactionRequestVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items'])
          this.items!.push(CovenantTransactionRequestVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfCovenantTransactionRequestVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfCovenantTransactionRequestVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfCovenantTransactionRequestVm {
  pageInfo?: PageInfo | undefined;
  items?: CovenantTransactionRequestVm[] | undefined;
}

export class CovenantTransactionRequestVm implements ICovenantTransactionRequestVm {
  date?: Date;
  amount?: number;
  remain?: number;
  order?: number;

  constructor(data?: ICovenantTransactionRequestVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.date = _data['date'] ? new Date(_data['date'].toString()) : <any>undefined;
      this.amount = _data['amount'];
      this.remain = _data['remain'];
      this.order = _data['order'];
    }
  }

  static fromJS(data: any): CovenantTransactionRequestVm {
    data = typeof data === 'object' ? data : {};
    let result = new CovenantTransactionRequestVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['date'] = this.date ? this.date.toISOString() : <any>undefined;
    data['amount'] = this.amount;
    data['remain'] = this.remain;
    data['order'] = this.order;
    return data;
  }
}

export interface ICovenantTransactionRequestVm {
  date?: Date;
  amount?: number;
  remain?: number;
  order?: number;
}

export class CovenantTransactionRequestDto implements ICovenantTransactionRequestDto {
  covenantRequestId?: string | undefined;
  date?: Date;
  amount?: number;
  remain?: number;

  constructor(data?: ICovenantTransactionRequestDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.covenantRequestId = _data['covenantRequestId'];
      this.date = _data['date'] ? new Date(_data['date'].toString()) : <any>undefined;
      this.amount = _data['amount'];
      this.remain = _data['remain'];
    }
  }

  static fromJS(data: any): CovenantTransactionRequestDto {
    data = typeof data === 'object' ? data : {};
    let result = new CovenantTransactionRequestDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['covenantRequestId'] = this.covenantRequestId;
    data['date'] = this.date ? this.date.toISOString() : <any>undefined;
    data['amount'] = this.amount;
    data['remain'] = this.remain;
    return data;
  }
}

export interface ICovenantTransactionRequestDto {
  covenantRequestId?: string | undefined;
  date?: Date;
  amount?: number;
  remain?: number;
}

export class RequestsSummaryVM implements IRequestsSummaryVM {
  projectId?: string | undefined;
  siteImage?: string | undefined;
  projectName?: string | undefined;
  covenantRequestsCount?: number;
  supplyRequestsCount?: number;
  priceRequestsCount?: number;
  extractRequestsCount?: number;

  constructor(data?: IRequestsSummaryVM) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.projectId = _data['projectId'];
      this.siteImage = _data['siteImage'];
      this.projectName = _data['projectName'];
      this.covenantRequestsCount = _data['covenantRequestsCount'];
      this.supplyRequestsCount = _data['supplyRequestsCount'];
      this.priceRequestsCount = _data['priceRequestsCount'];
      this.extractRequestsCount = _data['extractRequestsCount'];
    }
  }

  static fromJS(data: any): RequestsSummaryVM {
    data = typeof data === 'object' ? data : {};
    let result = new RequestsSummaryVM();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['projectId'] = this.projectId;
    data['siteImage'] = this.siteImage;
    data['projectName'] = this.projectName;
    data['covenantRequestsCount'] = this.covenantRequestsCount;
    data['supplyRequestsCount'] = this.supplyRequestsCount;
    data['priceRequestsCount'] = this.priceRequestsCount;
    data['extractRequestsCount'] = this.extractRequestsCount;
    return data;
  }
}

export interface IRequestsSummaryVM {
  projectId?: string | undefined;
  siteImage?: string | undefined;
  projectName?: string | undefined;
  covenantRequestsCount?: number;
  supplyRequestsCount?: number;
  priceRequestsCount?: number;
  extractRequestsCount?: number;
}

export class FinancialPositionSummaryVM implements IFinancialPositionSummaryVM {
  projectId?: string | undefined;
  siteImage?: string | undefined;
  projectName?: string | undefined;
  totalValue?: number | undefined;
  actualValue?: number | undefined;

  constructor(data?: IFinancialPositionSummaryVM) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.projectId = _data['projectId'];
      this.siteImage = _data['siteImage'];
      this.projectName = _data['projectName'];
      this.totalValue = _data['totalValue'];
      this.actualValue = _data['actualValue'];
    }
  }

  static fromJS(data: any): FinancialPositionSummaryVM {
    data = typeof data === 'object' ? data : {};
    let result = new FinancialPositionSummaryVM();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['projectId'] = this.projectId;
    data['siteImage'] = this.siteImage;
    data['projectName'] = this.projectName;
    data['totalValue'] = this.totalValue;
    data['actualValue'] = this.actualValue;
    return data;
  }
}

export interface IFinancialPositionSummaryVM {
  projectId?: string | undefined;
  siteImage?: string | undefined;
  projectName?: string | undefined;
  totalValue?: number | undefined;
  actualValue?: number | undefined;
}

export class TasksSummaryVM implements ITasksSummaryVM {
  projectId?: string | undefined;
  siteImage?: string | undefined;
  projectName?: string | undefined;
  notStartedTaskCount?: number;
  inProgressTasksCount?: number;
  completedTasksCount?: number;

  constructor(data?: ITasksSummaryVM) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.projectId = _data['projectId'];
      this.siteImage = _data['siteImage'];
      this.projectName = _data['projectName'];
      this.notStartedTaskCount = _data['notStartedTaskCount'];
      this.inProgressTasksCount = _data['inProgressTasksCount'];
      this.completedTasksCount = _data['completedTasksCount'];
    }
  }

  static fromJS(data: any): TasksSummaryVM {
    data = typeof data === 'object' ? data : {};
    let result = new TasksSummaryVM();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['projectId'] = this.projectId;
    data['siteImage'] = this.siteImage;
    data['projectName'] = this.projectName;
    data['notStartedTaskCount'] = this.notStartedTaskCount;
    data['inProgressTasksCount'] = this.inProgressTasksCount;
    data['completedTasksCount'] = this.completedTasksCount;
    return data;
  }
}

export interface ITasksSummaryVM {
  projectId?: string | undefined;
  siteImage?: string | undefined;
  projectName?: string | undefined;
  notStartedTaskCount?: number;
  inProgressTasksCount?: number;
  completedTasksCount?: number;
}

export class TimelineSummaryVM implements ITimelineSummaryVM {
  projectId?: string | undefined;
  siteImage?: string | undefined;
  projectName?: string | undefined;
  totalDurationMonths?: number;
  elapsedDurationMonths?: number;
  remainingDurationInMonths?: number;

  constructor(data?: ITimelineSummaryVM) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.projectId = _data['projectId'];
      this.siteImage = _data['siteImage'];
      this.projectName = _data['projectName'];
      this.totalDurationMonths = _data['totalDurationMonths'];
      this.elapsedDurationMonths = _data['elapsedDurationMonths'];
      this.remainingDurationInMonths = _data['remainingDurationInMonths'];
    }
  }

  static fromJS(data: any): TimelineSummaryVM {
    data = typeof data === 'object' ? data : {};
    let result = new TimelineSummaryVM();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['projectId'] = this.projectId;
    data['siteImage'] = this.siteImage;
    data['projectName'] = this.projectName;
    data['totalDurationMonths'] = this.totalDurationMonths;
    data['elapsedDurationMonths'] = this.elapsedDurationMonths;
    data['remainingDurationInMonths'] = this.remainingDurationInMonths;
    return data;
  }
}

export interface ITimelineSummaryVM {
  projectId?: string | undefined;
  siteImage?: string | undefined;
  projectName?: string | undefined;
  totalDurationMonths?: number;
  elapsedDurationMonths?: number;
  remainingDurationInMonths?: number;
}

export class DataSummaryView implements IDataSummaryView {
  projectsCount?: number;
  totalRequestsCount?: number;
  totalPrice?: number;

  constructor(data?: IDataSummaryView) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.projectsCount = _data['projectsCount'];
      this.totalRequestsCount = _data['totalRequestsCount'];
      this.totalPrice = _data['totalPrice'];
    }
  }

  static fromJS(data: any): DataSummaryView {
    data = typeof data === 'object' ? data : {};
    let result = new DataSummaryView();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['projectsCount'] = this.projectsCount;
    data['totalRequestsCount'] = this.totalRequestsCount;
    data['totalPrice'] = this.totalPrice;
    return data;
  }
}

export interface IDataSummaryView {
  projectsCount?: number;
  totalRequestsCount?: number;
  totalPrice?: number;
}

export class ExpensesVM implements IExpensesVM {
  year?: number;
  month?: number;
  totalPaid?: number;

  constructor(data?: IExpensesVM) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.year = _data['year'];
      this.month = _data['month'];
      this.totalPaid = _data['totalPaid'];
    }
  }

  static fromJS(data: any): ExpensesVM {
    data = typeof data === 'object' ? data : {};
    let result = new ExpensesVM();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['year'] = this.year;
    data['month'] = this.month;
    data['totalPaid'] = this.totalPaid;
    return data;
  }
}

export interface IExpensesVM {
  year?: number;
  month?: number;
  totalPaid?: number;
}

export class DelegationVm implements IDelegationVm {
  id?: string | undefined;
  documentNumber?: number;
  delegatedToName?: string | undefined;
  commerceChamberId?: string | undefined;
  notes?: string | undefined;
  files?: ContractFileVM[] | undefined;
  contractId?: string | undefined;
  lastStep?: number | undefined;
  stepNumber?: number;

  constructor(data?: IDelegationVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.documentNumber = _data['documentNumber'];
      this.delegatedToName = _data['delegatedToName'];
      this.commerceChamberId = _data['commerceChamberId'];
      this.notes = _data['notes'];
      if (Array.isArray(_data['files'])) {
        this.files = [] as any;
        for (let item of _data['files']) this.files!.push(ContractFileVM.fromJS(item));
      }
      this.contractId = _data['contractId'];
      this.lastStep = _data['lastStep'];
      this.stepNumber = _data['stepNumber'];
    }
  }

  static fromJS(data: any): DelegationVm {
    data = typeof data === 'object' ? data : {};
    let result = new DelegationVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['documentNumber'] = this.documentNumber;
    data['delegatedToName'] = this.delegatedToName;
    data['commerceChamberId'] = this.commerceChamberId;
    data['notes'] = this.notes;
    if (Array.isArray(this.files)) {
      data['files'] = [];
      for (let item of this.files) data['files'].push(item.toJSON());
    }
    data['contractId'] = this.contractId;
    data['lastStep'] = this.lastStep;
    data['stepNumber'] = this.stepNumber;
    return data;
  }
}

export interface IDelegationVm {
  id?: string | undefined;
  documentNumber?: number;
  delegatedToName?: string | undefined;
  commerceChamberId?: string | undefined;
  notes?: string | undefined;
  files?: ContractFileVM[] | undefined;
  contractId?: string | undefined;
  lastStep?: number | undefined;
  stepNumber?: number;
}

export class ExtractRequestDetailsVm implements IExtractRequestDetailsVm {
  id?: string | undefined;
  requestNumber?: number;
  description?: string | undefined;
  contractRefNumber?: string | undefined;
  measurementUnitId?: string | undefined;
  termId?: string | undefined;
  supplierId?: string | undefined;
  projectId?: string | undefined;
  quantity?: number;
  previousQuantity?: number;
  currentQuantity?: number;
  totalQuantity?: number;
  unitPrice?: number;
  vat?: number;
  isTaxFree?: boolean;
  total?: number;
  totalAfterDeductions?: number;
  vatAmount?: number;
  totalAfterDeductionsWithVat?: number;
  tenPercentDeduction?: number;
  totalPaidBefore?: number;
  extractValue?: number;
  notes?: string | undefined;
  extractDate?: Date;
  startDate?: Date;
  type?: ExtractRequestType;
  createdAt?: Date;
  createdBy?: string | undefined;
  attachments?: FileAttachmentDto[] | undefined;
  term?: ProjectQuantityMainDataVm | undefined;
  measurementUnit?: MeasurementUnitVm | undefined;
  status?: ExtractRequestStatusVm;
  phase?: ExtractRequestPhaseVm;
  creatorName?: string | undefined;
  history?: ExtractRequestStatusLogVm[] | undefined;
  supplier?: ExtractRequestSupplierVm | undefined;
  deductions?: ExtractRequestDeductionVm[] | undefined;
  transactionReqeusts?: ExtractRequestTransactionReqeustVm[] | undefined;

  constructor(data?: IExtractRequestDetailsVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.requestNumber = _data['requestNumber'];
      this.description = _data['description'];
      this.contractRefNumber = _data['contractRefNumber'];
      this.measurementUnitId = _data['measurementUnitId'];
      this.termId = _data['termId'];
      this.supplierId = _data['supplierId'];
      this.projectId = _data['projectId'];
      this.quantity = _data['quantity'];
      this.previousQuantity = _data['previousQuantity'];
      this.currentQuantity = _data['currentQuantity'];
      this.totalQuantity = _data['totalQuantity'];
      this.unitPrice = _data['unitPrice'];
      this.vat = _data['vat'];
      this.isTaxFree = _data['isTaxFree'];
      this.total = _data['total'];
      this.totalAfterDeductions = _data['totalAfterDeductions'];
      this.vatAmount = _data['vatAmount'];
      this.totalAfterDeductionsWithVat = _data['totalAfterDeductionsWithVat'];
      this.tenPercentDeduction = _data['tenPercentDeduction'];
      this.totalPaidBefore = _data['totalPaidBefore'];
      this.extractValue = _data['extractValue'];
      this.notes = _data['notes'];
      this.extractDate = _data['extractDate']
        ? new Date(_data['extractDate'].toString())
        : <any>undefined;
      this.startDate = _data['startDate']
        ? new Date(_data['startDate'].toString())
        : <any>undefined;
      this.type = _data['type'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : <any>undefined;
      this.createdBy = _data['createdBy'];
      if (Array.isArray(_data['attachments'])) {
        this.attachments = [] as any;
        for (let item of _data['attachments'])
          this.attachments!.push(FileAttachmentDto.fromJS(item));
      }
      this.term = _data['term']
        ? ProjectQuantityMainDataVm.fromJS(_data['term'])
        : <any>undefined;
      this.measurementUnit = _data['measurementUnit']
        ? MeasurementUnitVm.fromJS(_data['measurementUnit'])
        : <any>undefined;
      this.status = _data['status'];
      this.phase = _data['phase'];
      this.creatorName = _data['creatorName'];
      if (Array.isArray(_data['history'])) {
        this.history = [] as any;
        for (let item of _data['history'])
          this.history!.push(ExtractRequestStatusLogVm.fromJS(item));
      }
      this.supplier = _data['supplier']
        ? ExtractRequestSupplierVm.fromJS(_data['supplier'])
        : <any>undefined;
      if (Array.isArray(_data['deductions'])) {
        this.deductions = [] as any;
        for (let item of _data['deductions'])
          this.deductions!.push(ExtractRequestDeductionVm.fromJS(item));
      }
      if (Array.isArray(_data['transactionReqeusts'])) {
        this.transactionReqeusts = [] as any;
        for (let item of _data['transactionReqeusts'])
          this.transactionReqeusts!.push(ExtractRequestTransactionReqeustVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ExtractRequestDetailsVm {
    data = typeof data === 'object' ? data : {};
    let result = new ExtractRequestDetailsVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['requestNumber'] = this.requestNumber;
    data['description'] = this.description;
    data['contractRefNumber'] = this.contractRefNumber;
    data['measurementUnitId'] = this.measurementUnitId;
    data['termId'] = this.termId;
    data['supplierId'] = this.supplierId;
    data['projectId'] = this.projectId;
    data['quantity'] = this.quantity;
    data['previousQuantity'] = this.previousQuantity;
    data['currentQuantity'] = this.currentQuantity;
    data['totalQuantity'] = this.totalQuantity;
    data['unitPrice'] = this.unitPrice;
    data['vat'] = this.vat;
    data['isTaxFree'] = this.isTaxFree;
    data['total'] = this.total;
    data['totalAfterDeductions'] = this.totalAfterDeductions;
    data['vatAmount'] = this.vatAmount;
    data['totalAfterDeductionsWithVat'] = this.totalAfterDeductionsWithVat;
    data['tenPercentDeduction'] = this.tenPercentDeduction;
    data['totalPaidBefore'] = this.totalPaidBefore;
    data['extractValue'] = this.extractValue;
    data['notes'] = this.notes;
    data['extractDate'] = this.extractDate
      ? this.extractDate.toISOString()
      : <any>undefined;
    data['startDate'] = this.startDate ? this.startDate.toISOString() : <any>undefined;
    data['type'] = this.type;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
    data['createdBy'] = this.createdBy;
    if (Array.isArray(this.attachments)) {
      data['attachments'] = [];
      for (let item of this.attachments) data['attachments'].push(item.toJSON());
    }
    data['term'] = this.term ? this.term.toJSON() : <any>undefined;
    data['measurementUnit'] = this.measurementUnit
      ? this.measurementUnit.toJSON()
      : <any>undefined;
    data['status'] = this.status;
    data['phase'] = this.phase;
    data['creatorName'] = this.creatorName;
    if (Array.isArray(this.history)) {
      data['history'] = [];
      for (let item of this.history) data['history'].push(item.toJSON());
    }
    data['supplier'] = this.supplier ? this.supplier.toJSON() : <any>undefined;
    if (Array.isArray(this.deductions)) {
      data['deductions'] = [];
      for (let item of this.deductions) data['deductions'].push(item.toJSON());
    }
    if (Array.isArray(this.transactionReqeusts)) {
      data['transactionReqeusts'] = [];
      for (let item of this.transactionReqeusts)
        data['transactionReqeusts'].push(item.toJSON());
    }
    return data;
  }
}

export interface IExtractRequestDetailsVm {
  id?: string | undefined;
  requestNumber?: number;
  description?: string | undefined;
  contractRefNumber?: string | undefined;
  measurementUnitId?: string | undefined;
  termId?: string | undefined;
  supplierId?: string | undefined;
  projectId?: string | undefined;
  quantity?: number;
  previousQuantity?: number;
  currentQuantity?: number;
  totalQuantity?: number;
  unitPrice?: number;
  vat?: number;
  isTaxFree?: boolean;
  total?: number;
  totalAfterDeductions?: number;
  vatAmount?: number;
  totalAfterDeductionsWithVat?: number;
  tenPercentDeduction?: number;
  totalPaidBefore?: number;
  extractValue?: number;
  notes?: string | undefined;
  extractDate?: Date;
  startDate?: Date;
  type?: ExtractRequestType;
  createdAt?: Date;
  createdBy?: string | undefined;
  attachments?: FileAttachmentDto[] | undefined;
  term?: ProjectQuantityMainDataVm | undefined;
  measurementUnit?: MeasurementUnitVm | undefined;
  status?: ExtractRequestStatusVm;
  phase?: ExtractRequestPhaseVm;
  creatorName?: string | undefined;
  history?: ExtractRequestStatusLogVm[] | undefined;
  supplier?: ExtractRequestSupplierVm | undefined;
  deductions?: ExtractRequestDeductionVm[] | undefined;
  transactionReqeusts?: ExtractRequestTransactionReqeustVm[] | undefined;
}

export enum ExtractRequestType {
  InProgress = 0,
  Final = 1,
}

export enum ExtractRequestStatusVm {
  Pending = 0,
  Rejected = 1,
  Approved = 2,
  Draft = 3,
}

export enum ExtractRequestPhaseVm {
  SiteEngineer = 0,
  ProjectManagerReview = 1,
  TechnicalOfficeReview = 2,
  ProjectsManagerReview = 3,
  GeneralManagerReview = 4,
  Accountant = 5,
  TransferredPartial = 6,
  Completed = 7,
}

export class ExtractRequestStatusLogVm implements IExtractRequestStatusLogVm {
  id?: string | undefined;
  extractRequestId?: string | undefined;
  status?: ExtractRequestStatus;
  phase?: ExtractRequestPhase;
  actor?: ExtractRequestActor;
  notes?: string | undefined;
  createdAt?: Date;
  attachments?: FileAttachmentDto[] | undefined;

  constructor(data?: IExtractRequestStatusLogVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.extractRequestId = _data['extractRequestId'];
      this.status = _data['status'];
      this.phase = _data['phase'];
      this.actor = _data['actor'];
      this.notes = _data['notes'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : <any>undefined;
      if (Array.isArray(_data['attachments'])) {
        this.attachments = [] as any;
        for (let item of _data['attachments'])
          this.attachments!.push(FileAttachmentDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ExtractRequestStatusLogVm {
    data = typeof data === 'object' ? data : {};
    let result = new ExtractRequestStatusLogVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['extractRequestId'] = this.extractRequestId;
    data['status'] = this.status;
    data['phase'] = this.phase;
    data['actor'] = this.actor;
    data['notes'] = this.notes;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
    if (Array.isArray(this.attachments)) {
      data['attachments'] = [];
      for (let item of this.attachments) data['attachments'].push(item.toJSON());
    }
    return data;
  }
}

export interface IExtractRequestStatusLogVm {
  id?: string | undefined;
  extractRequestId?: string | undefined;
  status?: ExtractRequestStatus;
  phase?: ExtractRequestPhase;
  actor?: ExtractRequestActor;
  notes?: string | undefined;
  createdAt?: Date;
  attachments?: FileAttachmentDto[] | undefined;
}

export enum ExtractRequestStatus {
  Created = 0,
  Rejected = 1,
  Approved = 2,
  Transferred = 3,
  Completed = 4,
  Draft = 5,
  TransferredPartial = 6,
}

export enum ExtractRequestPhase {
  SiteEngineer = 0,
  ProjectManagerReview = 1,
  TechnicalOfficeReview = 2,
  ProjectsManagerReview = 3,
  GeneralManagerReview = 4,
  Accountant = 5,
  Completed = 6,
}

export enum ExtractRequestActor {
  SiteEngineer = 0,
  ProjectManager = 1,
  TechnicalOffice = 2,
  ProjectsManager = 3,
  Accountant = 4,
  GeneralManager = 5,
}

export class ExtractRequestSupplierVm implements IExtractRequestSupplierVm {
  id?: string | undefined;
  name?: string | undefined;

  constructor(data?: IExtractRequestSupplierVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
    }
  }

  static fromJS(data: any): ExtractRequestSupplierVm {
    data = typeof data === 'object' ? data : {};
    let result = new ExtractRequestSupplierVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    return data;
  }
}

export interface IExtractRequestSupplierVm {
  id?: string | undefined;
  name?: string | undefined;
}

export class ExtractRequestDeductionVm implements IExtractRequestDeductionVm {
  id?: string | undefined;
  extractRequestId?: string | undefined;
  description?: string | undefined;
  measurementUnitId?: string | undefined;
  measurementUnit?: MeasurementUnitVm | undefined;
  quantity?: number;
  previousQuantity?: number;
  currentQuantity?: number;
  totalQuantity?: number;
  unitPrice?: number;
  total?: number;
  order?: number;

  constructor(data?: IExtractRequestDeductionVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.extractRequestId = _data['extractRequestId'];
      this.description = _data['description'];
      this.measurementUnitId = _data['measurementUnitId'];
      this.measurementUnit = _data['measurementUnit']
        ? MeasurementUnitVm.fromJS(_data['measurementUnit'])
        : <any>undefined;
      this.quantity = _data['quantity'];
      this.previousQuantity = _data['previousQuantity'];
      this.currentQuantity = _data['currentQuantity'];
      this.totalQuantity = _data['totalQuantity'];
      this.unitPrice = _data['unitPrice'];
      this.total = _data['total'];
      this.order = _data['order'];
    }
  }

  static fromJS(data: any): ExtractRequestDeductionVm {
    data = typeof data === 'object' ? data : {};
    let result = new ExtractRequestDeductionVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['extractRequestId'] = this.extractRequestId;
    data['description'] = this.description;
    data['measurementUnitId'] = this.measurementUnitId;
    data['measurementUnit'] = this.measurementUnit
      ? this.measurementUnit.toJSON()
      : <any>undefined;
    data['quantity'] = this.quantity;
    data['previousQuantity'] = this.previousQuantity;
    data['currentQuantity'] = this.currentQuantity;
    data['totalQuantity'] = this.totalQuantity;
    data['unitPrice'] = this.unitPrice;
    data['total'] = this.total;
    data['order'] = this.order;
    return data;
  }
}

export interface IExtractRequestDeductionVm {
  id?: string | undefined;
  extractRequestId?: string | undefined;
  description?: string | undefined;
  measurementUnitId?: string | undefined;
  measurementUnit?: MeasurementUnitVm | undefined;
  quantity?: number;
  previousQuantity?: number;
  currentQuantity?: number;
  totalQuantity?: number;
  unitPrice?: number;
  total?: number;
  order?: number;
}

export class ExtractRequestTransactionReqeustVm
  implements IExtractRequestTransactionReqeustVm
{
  extractRequestId?: string | undefined;
  supplierId?: string | undefined;
  supplierName?: string | undefined;
  amount?: number;
  remaining?: number;
  date?: Date;
  order?: number;

  constructor(data?: IExtractRequestTransactionReqeustVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.extractRequestId = _data['extractRequestId'];
      this.supplierId = _data['supplierId'];
      this.supplierName = _data['supplierName'];
      this.amount = _data['amount'];
      this.remaining = _data['remaining'];
      this.date = _data['date'] ? new Date(_data['date'].toString()) : <any>undefined;
      this.order = _data['order'];
    }
  }

  static fromJS(data: any): ExtractRequestTransactionReqeustVm {
    data = typeof data === 'object' ? data : {};
    let result = new ExtractRequestTransactionReqeustVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['extractRequestId'] = this.extractRequestId;
    data['supplierId'] = this.supplierId;
    data['supplierName'] = this.supplierName;
    data['amount'] = this.amount;
    data['remaining'] = this.remaining;
    data['date'] = this.date ? this.date.toISOString() : <any>undefined;
    data['order'] = this.order;
    return data;
  }
}

export interface IExtractRequestTransactionReqeustVm {
  extractRequestId?: string | undefined;
  supplierId?: string | undefined;
  supplierName?: string | undefined;
  amount?: number;
  remaining?: number;
  date?: Date;
  order?: number;
}

export class PaginatedListOfExtractRequestDetailsVm
  implements IPaginatedListOfExtractRequestDetailsVm
{
  pageInfo?: PageInfo | undefined;
  items?: ExtractRequestDetailsVm[] | undefined;

  constructor(data?: IPaginatedListOfExtractRequestDetailsVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items'])
          this.items!.push(ExtractRequestDetailsVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfExtractRequestDetailsVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfExtractRequestDetailsVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfExtractRequestDetailsVm {
  pageInfo?: PageInfo | undefined;
  items?: ExtractRequestDetailsVm[] | undefined;
}

export class ExtractRequestDto implements IExtractRequestDto {
  projectId?: string | undefined;
  termId?: string | undefined;
  supplierId?: string | undefined;
  description?: string | undefined;
  measurementUnitId?: string | undefined;
  contractRefNumber?: string | undefined;
  quantity?: number;
  unitPrice?: number;
  notes?: string | undefined;
  extractDate?: Date;
  startDate?: Date;
  type?: ExtractRequestType;
  isTaxFree?: boolean;
  attachments?: UploadAttachmentDto[] | undefined;

  constructor(data?: IExtractRequestDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.projectId = _data['projectId'];
      this.termId = _data['termId'];
      this.supplierId = _data['supplierId'];
      this.description = _data['description'];
      this.measurementUnitId = _data['measurementUnitId'];
      this.contractRefNumber = _data['contractRefNumber'];
      this.quantity = _data['quantity'];
      this.unitPrice = _data['unitPrice'];
      this.notes = _data['notes'];
      this.extractDate = _data['extractDate']
        ? new Date(_data['extractDate'].toString())
        : <any>undefined;
      this.startDate = _data['startDate']
        ? new Date(_data['startDate'].toString())
        : <any>undefined;
      this.type = _data['type'];
      this.isTaxFree = _data['isTaxFree'];
      if (Array.isArray(_data['attachments'])) {
        this.attachments = [] as any;
        for (let item of _data['attachments'])
          this.attachments!.push(UploadAttachmentDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ExtractRequestDto {
    data = typeof data === 'object' ? data : {};
    let result = new ExtractRequestDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['projectId'] = this.projectId;
    data['termId'] = this.termId;
    data['supplierId'] = this.supplierId;
    data['description'] = this.description;
    data['measurementUnitId'] = this.measurementUnitId;
    data['contractRefNumber'] = this.contractRefNumber;
    data['quantity'] = this.quantity;
    data['unitPrice'] = this.unitPrice;
    data['notes'] = this.notes;
    data['extractDate'] = this.extractDate
      ? this.extractDate.toISOString()
      : <any>undefined;
    data['startDate'] = this.startDate ? this.startDate.toISOString() : <any>undefined;
    data['type'] = this.type;
    data['isTaxFree'] = this.isTaxFree;
    if (Array.isArray(this.attachments)) {
      data['attachments'] = [];
      for (let item of this.attachments) data['attachments'].push(item.toJSON());
    }
    return data;
  }
}

export interface IExtractRequestDto {
  projectId?: string | undefined;
  termId?: string | undefined;
  supplierId?: string | undefined;
  description?: string | undefined;
  measurementUnitId?: string | undefined;
  contractRefNumber?: string | undefined;
  quantity?: number;
  unitPrice?: number;
  notes?: string | undefined;
  extractDate?: Date;
  startDate?: Date;
  type?: ExtractRequestType;
  isTaxFree?: boolean;
  attachments?: UploadAttachmentDto[] | undefined;
}

export class ExtractRequestDetailsCalculateVm
  implements IExtractRequestDetailsCalculateVm
{
  id?: string | undefined;
  requestNumber?: number;
  description?: string | undefined;
  quantity?: number;
  previousQuantity?: number;
  currentQuantity?: number;
  totalQuantity?: number;
  unitPrice?: number;
  vat?: number;
  total?: number;
  totalAfterDeductions?: number;
  vatAmount?: number;
  totalAfterDeductionsWithVat?: number;
  tenPercentDeduction?: number;
  totalPaidBefore?: number;
  extractValue?: number;
  extractDate?: Date;
  startDate?: Date;
  type?: ExtractRequestType;
  deductions?: ExtractRequestDeductionCalculateVm[] | undefined;

  constructor(data?: IExtractRequestDetailsCalculateVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.requestNumber = _data['requestNumber'];
      this.description = _data['description'];
      this.quantity = _data['quantity'];
      this.previousQuantity = _data['previousQuantity'];
      this.currentQuantity = _data['currentQuantity'];
      this.totalQuantity = _data['totalQuantity'];
      this.unitPrice = _data['unitPrice'];
      this.vat = _data['vat'];
      this.total = _data['total'];
      this.totalAfterDeductions = _data['totalAfterDeductions'];
      this.vatAmount = _data['vatAmount'];
      this.totalAfterDeductionsWithVat = _data['totalAfterDeductionsWithVat'];
      this.tenPercentDeduction = _data['tenPercentDeduction'];
      this.totalPaidBefore = _data['totalPaidBefore'];
      this.extractValue = _data['extractValue'];
      this.extractDate = _data['extractDate']
        ? new Date(_data['extractDate'].toString())
        : <any>undefined;
      this.startDate = _data['startDate']
        ? new Date(_data['startDate'].toString())
        : <any>undefined;
      this.type = _data['type'];
      if (Array.isArray(_data['deductions'])) {
        this.deductions = [] as any;
        for (let item of _data['deductions'])
          this.deductions!.push(ExtractRequestDeductionCalculateVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ExtractRequestDetailsCalculateVm {
    data = typeof data === 'object' ? data : {};
    let result = new ExtractRequestDetailsCalculateVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['requestNumber'] = this.requestNumber;
    data['description'] = this.description;
    data['quantity'] = this.quantity;
    data['previousQuantity'] = this.previousQuantity;
    data['currentQuantity'] = this.currentQuantity;
    data['totalQuantity'] = this.totalQuantity;
    data['unitPrice'] = this.unitPrice;
    data['vat'] = this.vat;
    data['total'] = this.total;
    data['totalAfterDeductions'] = this.totalAfterDeductions;
    data['vatAmount'] = this.vatAmount;
    data['totalAfterDeductionsWithVat'] = this.totalAfterDeductionsWithVat;
    data['tenPercentDeduction'] = this.tenPercentDeduction;
    data['totalPaidBefore'] = this.totalPaidBefore;
    data['extractValue'] = this.extractValue;
    data['extractDate'] = this.extractDate
      ? this.extractDate.toISOString()
      : <any>undefined;
    data['startDate'] = this.startDate ? this.startDate.toISOString() : <any>undefined;
    data['type'] = this.type;
    if (Array.isArray(this.deductions)) {
      data['deductions'] = [];
      for (let item of this.deductions) data['deductions'].push(item.toJSON());
    }
    return data;
  }
}

export interface IExtractRequestDetailsCalculateVm {
  id?: string | undefined;
  requestNumber?: number;
  description?: string | undefined;
  quantity?: number;
  previousQuantity?: number;
  currentQuantity?: number;
  totalQuantity?: number;
  unitPrice?: number;
  vat?: number;
  total?: number;
  totalAfterDeductions?: number;
  vatAmount?: number;
  totalAfterDeductionsWithVat?: number;
  tenPercentDeduction?: number;
  totalPaidBefore?: number;
  extractValue?: number;
  extractDate?: Date;
  startDate?: Date;
  type?: ExtractRequestType;
  deductions?: ExtractRequestDeductionCalculateVm[] | undefined;
}

export class ExtractRequestDeductionCalculateVm
  implements IExtractRequestDeductionCalculateVm
{
  id?: string | undefined;
  extractRequestId?: string | undefined;
  description?: string | undefined;
  measurementUnitId?: string | undefined;
  quantity?: number;
  previousQuantity?: number;
  currentQuantity?: number;
  totalQuantity?: number;
  unitPrice?: number;
  total?: number;
  order?: number;

  constructor(data?: IExtractRequestDeductionCalculateVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.extractRequestId = _data['extractRequestId'];
      this.description = _data['description'];
      this.measurementUnitId = _data['measurementUnitId'];
      this.quantity = _data['quantity'];
      this.previousQuantity = _data['previousQuantity'];
      this.currentQuantity = _data['currentQuantity'];
      this.totalQuantity = _data['totalQuantity'];
      this.unitPrice = _data['unitPrice'];
      this.total = _data['total'];
      this.order = _data['order'];
    }
  }

  static fromJS(data: any): ExtractRequestDeductionCalculateVm {
    data = typeof data === 'object' ? data : {};
    let result = new ExtractRequestDeductionCalculateVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['extractRequestId'] = this.extractRequestId;
    data['description'] = this.description;
    data['measurementUnitId'] = this.measurementUnitId;
    data['quantity'] = this.quantity;
    data['previousQuantity'] = this.previousQuantity;
    data['currentQuantity'] = this.currentQuantity;
    data['totalQuantity'] = this.totalQuantity;
    data['unitPrice'] = this.unitPrice;
    data['total'] = this.total;
    data['order'] = this.order;
    return data;
  }
}

export interface IExtractRequestDeductionCalculateVm {
  id?: string | undefined;
  extractRequestId?: string | undefined;
  description?: string | undefined;
  measurementUnitId?: string | undefined;
  quantity?: number;
  previousQuantity?: number;
  currentQuantity?: number;
  totalQuantity?: number;
  unitPrice?: number;
  total?: number;
  order?: number;
}

export class ExtractRequestCalculateDto implements IExtractRequestCalculateDto {
  totalQuantity?: number;
  deductions?: ExtractRequestDeductionDto[] | undefined;

  constructor(data?: IExtractRequestCalculateDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalQuantity = _data['totalQuantity'];
      if (Array.isArray(_data['deductions'])) {
        this.deductions = [] as any;
        for (let item of _data['deductions'])
          this.deductions!.push(ExtractRequestDeductionDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ExtractRequestCalculateDto {
    data = typeof data === 'object' ? data : {};
    let result = new ExtractRequestCalculateDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalQuantity'] = this.totalQuantity;
    if (Array.isArray(this.deductions)) {
      data['deductions'] = [];
      for (let item of this.deductions) data['deductions'].push(item.toJSON());
    }
    return data;
  }
}

export interface IExtractRequestCalculateDto {
  totalQuantity?: number;
  deductions?: ExtractRequestDeductionDto[] | undefined;
}

export class ExtractRequestDeductionDto implements IExtractRequestDeductionDto {
  id?: string | undefined;
  description?: string | undefined;
  measurementUnitId?: string | undefined;
  totalQuantity?: number;
  unitPrice?: number;

  constructor(data?: IExtractRequestDeductionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.description = _data['description'];
      this.measurementUnitId = _data['measurementUnitId'];
      this.totalQuantity = _data['totalQuantity'];
      this.unitPrice = _data['unitPrice'];
    }
  }

  static fromJS(data: any): ExtractRequestDeductionDto {
    data = typeof data === 'object' ? data : {};
    let result = new ExtractRequestDeductionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['description'] = this.description;
    data['measurementUnitId'] = this.measurementUnitId;
    data['totalQuantity'] = this.totalQuantity;
    data['unitPrice'] = this.unitPrice;
    return data;
  }
}

export interface IExtractRequestDeductionDto {
  id?: string | undefined;
  description?: string | undefined;
  measurementUnitId?: string | undefined;
  totalQuantity?: number;
  unitPrice?: number;
}

export class ExtractRequestUpdateDto implements IExtractRequestUpdateDto {
  isSubmit?: boolean;
  totalQuantity?: number;
  deductions?: ExtractRequestDeductionDto[] | undefined;

  constructor(data?: IExtractRequestUpdateDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.isSubmit = _data['isSubmit'];
      this.totalQuantity = _data['totalQuantity'];
      if (Array.isArray(_data['deductions'])) {
        this.deductions = [] as any;
        for (let item of _data['deductions'])
          this.deductions!.push(ExtractRequestDeductionDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ExtractRequestUpdateDto {
    data = typeof data === 'object' ? data : {};
    let result = new ExtractRequestUpdateDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['isSubmit'] = this.isSubmit;
    data['totalQuantity'] = this.totalQuantity;
    if (Array.isArray(this.deductions)) {
      data['deductions'] = [];
      for (let item of this.deductions) data['deductions'].push(item.toJSON());
    }
    return data;
  }
}

export interface IExtractRequestUpdateDto {
  isSubmit?: boolean;
  totalQuantity?: number;
  deductions?: ExtractRequestDeductionDto[] | undefined;
}

export class ChangeExtractRequestStatusDto implements IChangeExtractRequestStatusDto {
  notes?: string | undefined;
  attachments?: UploadAttachmentDto[] | undefined;

  constructor(data?: IChangeExtractRequestStatusDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.notes = _data['notes'];
      if (Array.isArray(_data['attachments'])) {
        this.attachments = [] as any;
        for (let item of _data['attachments'])
          this.attachments!.push(UploadAttachmentDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ChangeExtractRequestStatusDto {
    data = typeof data === 'object' ? data : {};
    let result = new ChangeExtractRequestStatusDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['notes'] = this.notes;
    if (Array.isArray(this.attachments)) {
      data['attachments'] = [];
      for (let item of this.attachments) data['attachments'].push(item.toJSON());
    }
    return data;
  }
}

export interface IChangeExtractRequestStatusDto {
  notes?: string | undefined;
  attachments?: UploadAttachmentDto[] | undefined;
}

export class ExtractRequestTransactionReqeustsDto
  implements IExtractRequestTransactionReqeustsDto
{
  extractRequestId?: string | undefined;
  transactionRequests?: ExtractRequestTransactionRequestDto[] | undefined;

  constructor(data?: IExtractRequestTransactionReqeustsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.extractRequestId = _data['extractRequestId'];
      if (Array.isArray(_data['transactionRequests'])) {
        this.transactionRequests = [] as any;
        for (let item of _data['transactionRequests'])
          this.transactionRequests!.push(
            ExtractRequestTransactionRequestDto.fromJS(item)
          );
      }
    }
  }

  static fromJS(data: any): ExtractRequestTransactionReqeustsDto {
    data = typeof data === 'object' ? data : {};
    let result = new ExtractRequestTransactionReqeustsDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['extractRequestId'] = this.extractRequestId;
    if (Array.isArray(this.transactionRequests)) {
      data['transactionRequests'] = [];
      for (let item of this.transactionRequests)
        data['transactionRequests'].push(item.toJSON());
    }
    return data;
  }
}

export interface IExtractRequestTransactionReqeustsDto {
  extractRequestId?: string | undefined;
  transactionRequests?: ExtractRequestTransactionRequestDto[] | undefined;
}

export class ExtractRequestTransactionRequestDto
  implements IExtractRequestTransactionRequestDto
{
  date?: Date;
  amount?: number;

  constructor(data?: IExtractRequestTransactionRequestDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.date = _data['date'] ? new Date(_data['date'].toString()) : <any>undefined;
      this.amount = _data['amount'];
    }
  }

  static fromJS(data: any): ExtractRequestTransactionRequestDto {
    data = typeof data === 'object' ? data : {};
    let result = new ExtractRequestTransactionRequestDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['date'] = this.date ? this.date.toISOString() : <any>undefined;
    data['amount'] = this.amount;
    return data;
  }
}

export interface IExtractRequestTransactionRequestDto {
  date?: Date;
  amount?: number;
}

export class FileDetails implements IFileDetails {
  fileName?: string | undefined;
  displayFileName?: string | undefined;
  extension?: string | undefined;
  sizeInMb?: number;

  constructor(data?: IFileDetails) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.fileName = _data['fileName'];
      this.displayFileName = _data['displayFileName'];
      this.extension = _data['extension'];
      this.sizeInMb = _data['sizeInMb'];
    }
  }

  static fromJS(data: any): FileDetails {
    data = typeof data === 'object' ? data : {};
    let result = new FileDetails();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['fileName'] = this.fileName;
    data['displayFileName'] = this.displayFileName;
    data['extension'] = this.extension;
    data['sizeInMb'] = this.sizeInMb;
    return data;
  }
}

export interface IFileDetails {
  fileName?: string | undefined;
  displayFileName?: string | undefined;
  extension?: string | undefined;
  sizeInMb?: number;
}

export class ValueTupleOfStringAndString implements IValueTupleOfStringAndString {
  item1?: string | undefined;
  item2?: string | undefined;

  constructor(data?: IValueTupleOfStringAndString) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.item1 = _data['item1'];
      this.item2 = _data['item2'];
    }
  }

  static fromJS(data: any): ValueTupleOfStringAndString {
    data = typeof data === 'object' ? data : {};
    let result = new ValueTupleOfStringAndString();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['item1'] = this.item1;
    data['item2'] = this.item2;
    return data;
  }
}

export interface IValueTupleOfStringAndString {
  item1?: string | undefined;
  item2?: string | undefined;
}

export enum AttachmentType {
  Logos = 0,
  UserPicture = 1,
  Utilities = 2,
  ContractFiles = 3,
  ProjectFiles = 4,
  Other = 5,
}

export abstract class MarshalByRefObject implements IMarshalByRefObject {
  constructor(data?: IMarshalByRefObject) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {}

  static fromJS(data: any): MarshalByRefObject {
    data = typeof data === 'object' ? data : {};
    throw new Error("The abstract class 'MarshalByRefObject' cannot be instantiated.");
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    return data;
  }
}

export interface IMarshalByRefObject {}

export abstract class Stream extends MarshalByRefObject implements IStream {
  canTimeout?: boolean;
  readTimeout?: number;
  writeTimeout?: number;

  constructor(data?: IStream) {
    super(data);
  }

  override init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.canTimeout = _data['canTimeout'];
      this.readTimeout = _data['readTimeout'];
      this.writeTimeout = _data['writeTimeout'];
    }
  }

  static override fromJS(data: any): Stream {
    data = typeof data === 'object' ? data : {};
    throw new Error("The abstract class 'Stream' cannot be instantiated.");
  }

  override toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['canTimeout'] = this.canTimeout;
    data['readTimeout'] = this.readTimeout;
    data['writeTimeout'] = this.writeTimeout;
    super.toJSON(data);
    return data;
  }
}

export interface IStream extends IMarshalByRefObject {
  canTimeout?: boolean;
  readTimeout?: number;
  writeTimeout?: number;
}

export class AuthResponse implements IAuthResponse {
  email?: string | undefined;
  requires2FA?: boolean;
  token?: string | undefined;
  refreshToken?: string | undefined;

  constructor(data?: IAuthResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.email = _data['email'];
      this.requires2FA = _data['requires2FA'];
      this.token = _data['token'];
      this.refreshToken = _data['refreshToken'];
    }
  }

  static fromJS(data: any): AuthResponse {
    data = typeof data === 'object' ? data : {};
    let result = new AuthResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['email'] = this.email;
    data['requires2FA'] = this.requires2FA;
    data['token'] = this.token;
    data['refreshToken'] = this.refreshToken;
    return data;
  }
}

export interface IAuthResponse {
  email?: string | undefined;
  requires2FA?: boolean;
  token?: string | undefined;
  refreshToken?: string | undefined;
}

export class RefreshTokenCommand implements IRefreshTokenCommand {
  refreshToken?: string | undefined;

  constructor(data?: IRefreshTokenCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.refreshToken = _data['refreshToken'];
    }
  }

  static fromJS(data: any): RefreshTokenCommand {
    data = typeof data === 'object' ? data : {};
    let result = new RefreshTokenCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['refreshToken'] = this.refreshToken;
    return data;
  }
}

export interface IRefreshTokenCommand {
  refreshToken?: string | undefined;
}

export class LoginCommand implements ILoginCommand {
  email?: string | undefined;
  password?: string | undefined;

  constructor(data?: ILoginCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.email = _data['email'];
      this.password = _data['password'];
    }
  }

  static fromJS(data: any): LoginCommand {
    data = typeof data === 'object' ? data : {};
    let result = new LoginCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['email'] = this.email;
    data['password'] = this.password;
    return data;
  }
}

export interface ILoginCommand {
  email?: string | undefined;
  password?: string | undefined;
}

export class LoginTwoFactorAuthenticationCommand
  implements ILoginTwoFactorAuthenticationCommand
{
  otp?: string | undefined;
  email?: string | undefined;

  constructor(data?: ILoginTwoFactorAuthenticationCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.otp = _data['otp'];
      this.email = _data['email'];
    }
  }

  static fromJS(data: any): LoginTwoFactorAuthenticationCommand {
    data = typeof data === 'object' ? data : {};
    let result = new LoginTwoFactorAuthenticationCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['otp'] = this.otp;
    data['email'] = this.email;
    return data;
  }
}

export interface ILoginTwoFactorAuthenticationCommand {
  otp?: string | undefined;
  email?: string | undefined;
}

export class ExternalLoginCommand implements IExternalLoginCommand {
  provider?: string | undefined;
  token?: string | undefined;

  constructor(data?: IExternalLoginCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.provider = _data['provider'];
      this.token = _data['token'];
    }
  }

  static fromJS(data: any): ExternalLoginCommand {
    data = typeof data === 'object' ? data : {};
    let result = new ExternalLoginCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['provider'] = this.provider;
    data['token'] = this.token;
    return data;
  }
}

export interface IExternalLoginCommand {
  provider?: string | undefined;
  token?: string | undefined;
}

export class ResetPasswordCommand implements IResetPasswordCommand {
  email?: string | undefined;
  token?: string | undefined;
  password?: string | undefined;
  confirmPassword?: string | undefined;

  constructor(data?: IResetPasswordCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.email = _data['email'];
      this.token = _data['token'];
      this.password = _data['password'];
      this.confirmPassword = _data['confirmPassword'];
    }
  }

  static fromJS(data: any): ResetPasswordCommand {
    data = typeof data === 'object' ? data : {};
    let result = new ResetPasswordCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['email'] = this.email;
    data['token'] = this.token;
    data['password'] = this.password;
    data['confirmPassword'] = this.confirmPassword;
    return data;
  }
}

export interface IResetPasswordCommand {
  email?: string | undefined;
  token?: string | undefined;
  password?: string | undefined;
  confirmPassword?: string | undefined;
}

export class ForgetPasswordCommand implements IForgetPasswordCommand {
  email?: string | undefined;

  constructor(data?: IForgetPasswordCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.email = _data['email'];
    }
  }

  static fromJS(data: any): ForgetPasswordCommand {
    data = typeof data === 'object' ? data : {};
    let result = new ForgetPasswordCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['email'] = this.email;
    return data;
  }
}

export interface IForgetPasswordCommand {
  email?: string | undefined;
}

export class MaterialDto implements IMaterialDto {
  name?: LocalizedStringDto | undefined;
  description?: string | undefined;
  measurementUnitIds?: string[] | undefined;

  constructor(data?: IMaterialDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
      this.description = _data['description'];
      if (Array.isArray(_data['measurementUnitIds'])) {
        this.measurementUnitIds = [] as any;
        for (let item of _data['measurementUnitIds']) this.measurementUnitIds!.push(item);
      }
    }
  }

  static fromJS(data: any): MaterialDto {
    data = typeof data === 'object' ? data : {};
    let result = new MaterialDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    data['description'] = this.description;
    if (Array.isArray(this.measurementUnitIds)) {
      data['measurementUnitIds'] = [];
      for (let item of this.measurementUnitIds) data['measurementUnitIds'].push(item);
    }
    return data;
  }
}

export interface IMaterialDto {
  name?: LocalizedStringDto | undefined;
  description?: string | undefined;
  measurementUnitIds?: string[] | undefined;
}

export class MaterialVm implements IMaterialVm {
  id?: string | undefined;
  name?: LocalizedStringDto | undefined;
  description?: string | undefined;
  measurementUnitId?: string | undefined;
  measurementUnits?: MeasurementUnitVm[] | undefined;

  constructor(data?: IMaterialVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
      this.description = _data['description'];
      this.measurementUnitId = _data['measurementUnitId'];
      if (Array.isArray(_data['measurementUnits'])) {
        this.measurementUnits = [] as any;
        for (let item of _data['measurementUnits'])
          this.measurementUnits!.push(MeasurementUnitVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): MaterialVm {
    data = typeof data === 'object' ? data : {};
    let result = new MaterialVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    data['description'] = this.description;
    data['measurementUnitId'] = this.measurementUnitId;
    if (Array.isArray(this.measurementUnits)) {
      data['measurementUnits'] = [];
      for (let item of this.measurementUnits)
        data['measurementUnits'].push(item.toJSON());
    }
    return data;
  }
}

export interface IMaterialVm {
  id?: string | undefined;
  name?: LocalizedStringDto | undefined;
  description?: string | undefined;
  measurementUnitId?: string | undefined;
  measurementUnits?: MeasurementUnitVm[] | undefined;
}

export class PaginatedListOfMaterialVm implements IPaginatedListOfMaterialVm {
  pageInfo?: PageInfo | undefined;
  items?: MaterialVm[] | undefined;

  constructor(data?: IPaginatedListOfMaterialVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(MaterialVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfMaterialVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfMaterialVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfMaterialVm {
  pageInfo?: PageInfo | undefined;
  items?: MaterialVm[] | undefined;
}

export class PaginatedListOfMeasurementUnitVm
  implements IPaginatedListOfMeasurementUnitVm
{
  pageInfo?: PageInfo | undefined;
  items?: MeasurementUnitVm[] | undefined;

  constructor(data?: IPaginatedListOfMeasurementUnitVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(MeasurementUnitVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfMeasurementUnitVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfMeasurementUnitVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfMeasurementUnitVm {
  pageInfo?: PageInfo | undefined;
  items?: MeasurementUnitVm[] | undefined;
}

export class MeasurementUnitDto implements IMeasurementUnitDto {
  name?: LocalizedStringDto | undefined;
  abbreviation?: LocalizedStringDto | undefined;

  constructor(data?: IMeasurementUnitDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
      this.abbreviation = _data['abbreviation']
        ? LocalizedStringDto.fromJS(_data['abbreviation'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): MeasurementUnitDto {
    data = typeof data === 'object' ? data : {};
    let result = new MeasurementUnitDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    data['abbreviation'] = this.abbreviation
      ? this.abbreviation.toJSON()
      : <any>undefined;
    return data;
  }
}

export interface IMeasurementUnitDto {
  name?: LocalizedStringDto | undefined;
  abbreviation?: LocalizedStringDto | undefined;
}

export class PaginatedListOfNotificationVm implements IPaginatedListOfNotificationVm {
  pageInfo?: PageInfo | undefined;
  items?: NotificationVm[] | undefined;

  constructor(data?: IPaginatedListOfNotificationVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(NotificationVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfNotificationVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfNotificationVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfNotificationVm {
  pageInfo?: PageInfo | undefined;
  items?: NotificationVm[] | undefined;
}

export class NotificationVm implements INotificationVm {
  id?: string | undefined;
  title?: string | undefined;
  body?: string | undefined;
  type?: NotificationType;
  isRead?: boolean;
  createdAt?: Date;
  data?: { [key: string]: string } | undefined;

  constructor(data?: INotificationVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.title = _data['title'];
      this.body = _data['body'];
      this.type = _data['type'];
      this.isRead = _data['isRead'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : <any>undefined;
      if (_data['data']) {
        this.data = {} as any;
        for (let key in _data['data']) {
          if (_data['data'].hasOwnProperty(key))
            (<any>this.data)![key] = _data['data'][key];
        }
      }
    }
  }

  static fromJS(data: any): NotificationVm {
    data = typeof data === 'object' ? data : {};
    let result = new NotificationVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['title'] = this.title;
    data['body'] = this.body;
    data['type'] = this.type;
    data['isRead'] = this.isRead;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
    if (this.data) {
      data['data'] = {};
      for (let key in this.data) {
        if (this.data.hasOwnProperty(key))
          (<any>data['data'])[key] = (<any>this.data)[key];
      }
    }
    return data;
  }
}

export interface INotificationVm {
  id?: string | undefined;
  title?: string | undefined;
  body?: string | undefined;
  type?: NotificationType;
  isRead?: boolean;
  createdAt?: Date;
  data?: { [key: string]: string } | undefined;
}

export enum NotificationType {
  AuditLog = 0,
  SupplyRequest = 1,
  SupplierApprovalRequest = 2,
  WorkItems = 3,
  SupplyApprovalRequest = 4,
  CovenantRequest = 5,
  PriceApprovalRequest = 6,
  ExtractRequest = 7,
}

export class HttpResultOfInteger implements IHttpResultOfInteger {
  result?: number;

  constructor(data?: IHttpResultOfInteger) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.result = _data['result'];
    }
  }

  static fromJS(data: any): HttpResultOfInteger {
    data = typeof data === 'object' ? data : {};
    let result = new HttpResultOfInteger();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['result'] = this.result;
    return data;
  }
}

export interface IHttpResultOfInteger {
  result?: number;
}

export class PaginatedListOfPriceApprovalRequestVm
  implements IPaginatedListOfPriceApprovalRequestVm
{
  pageInfo?: PageInfo | undefined;
  items?: PriceApprovalRequestVm[] | undefined;

  constructor(data?: IPaginatedListOfPriceApprovalRequestVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items'])
          this.items!.push(PriceApprovalRequestVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfPriceApprovalRequestVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfPriceApprovalRequestVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfPriceApprovalRequestVm {
  pageInfo?: PageInfo | undefined;
  items?: PriceApprovalRequestVm[] | undefined;
}

export class PriceApprovalRequestVm implements IPriceApprovalRequestVm {
  id?: string | undefined;
  termId?: string | undefined;
  termTitle?: string | undefined;
  status?: PriceApprovalRequestStatus;

  constructor(data?: IPriceApprovalRequestVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.termId = _data['termId'];
      this.termTitle = _data['termTitle'];
      this.status = _data['status'];
    }
  }

  static fromJS(data: any): PriceApprovalRequestVm {
    data = typeof data === 'object' ? data : {};
    let result = new PriceApprovalRequestVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['termId'] = this.termId;
    data['termTitle'] = this.termTitle;
    data['status'] = this.status;
    return data;
  }
}

export interface IPriceApprovalRequestVm {
  id?: string | undefined;
  termId?: string | undefined;
  termTitle?: string | undefined;
  status?: PriceApprovalRequestStatus;
}

export enum PriceApprovalRequestStatus {
  Created = 0,
  Rejected = 1,
  Approved = 2,
  Completed = 3,
  WaitingNewSuppliers = 4,
}

export class PriceApprovalRequestDetailsVm implements IPriceApprovalRequestDetailsVm {
  id?: string | undefined;
  requestNumber?: number;
  description?: string | undefined;
  measurementUnitId?: string | undefined;
  termId?: string | undefined;
  quantity?: number;
  notes?: string | undefined;
  projectId?: string | undefined;
  createdAt?: Date;
  createdBy?: string | undefined;
  attachments?: FileAttachmentDto[] | undefined;
  term?: ProjectQuantityMainDataVm | undefined;
  measurementUnit?: MeasurementUnitVm | undefined;
  status?: PriceApprovalRequestStatusVm;
  phase?: PriceApprovalRequestPhaseVm;
  creatorName?: string | undefined;
  history?: PriceApprovalRequestStatusLogVm[] | undefined;
  suppliers?: PriceApprovalRequestSupplierVm[] | undefined;

  constructor(data?: IPriceApprovalRequestDetailsVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.requestNumber = _data['requestNumber'];
      this.description = _data['description'];
      this.measurementUnitId = _data['measurementUnitId'];
      this.termId = _data['termId'];
      this.quantity = _data['quantity'];
      this.notes = _data['notes'];
      this.projectId = _data['projectId'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : <any>undefined;
      this.createdBy = _data['createdBy'];
      if (Array.isArray(_data['attachments'])) {
        this.attachments = [] as any;
        for (let item of _data['attachments'])
          this.attachments!.push(FileAttachmentDto.fromJS(item));
      }
      this.term = _data['term']
        ? ProjectQuantityMainDataVm.fromJS(_data['term'])
        : <any>undefined;
      this.measurementUnit = _data['measurementUnit']
        ? MeasurementUnitVm.fromJS(_data['measurementUnit'])
        : <any>undefined;
      this.status = _data['status'];
      this.phase = _data['phase'];
      this.creatorName = _data['creatorName'];
      if (Array.isArray(_data['history'])) {
        this.history = [] as any;
        for (let item of _data['history'])
          this.history!.push(PriceApprovalRequestStatusLogVm.fromJS(item));
      }
      if (Array.isArray(_data['suppliers'])) {
        this.suppliers = [] as any;
        for (let item of _data['suppliers'])
          this.suppliers!.push(PriceApprovalRequestSupplierVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PriceApprovalRequestDetailsVm {
    data = typeof data === 'object' ? data : {};
    let result = new PriceApprovalRequestDetailsVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['requestNumber'] = this.requestNumber;
    data['description'] = this.description;
    data['measurementUnitId'] = this.measurementUnitId;
    data['termId'] = this.termId;
    data['quantity'] = this.quantity;
    data['notes'] = this.notes;
    data['projectId'] = this.projectId;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
    data['createdBy'] = this.createdBy;
    if (Array.isArray(this.attachments)) {
      data['attachments'] = [];
      for (let item of this.attachments) data['attachments'].push(item.toJSON());
    }
    data['term'] = this.term ? this.term.toJSON() : <any>undefined;
    data['measurementUnit'] = this.measurementUnit
      ? this.measurementUnit.toJSON()
      : <any>undefined;
    data['status'] = this.status;
    data['phase'] = this.phase;
    data['creatorName'] = this.creatorName;
    if (Array.isArray(this.history)) {
      data['history'] = [];
      for (let item of this.history) data['history'].push(item.toJSON());
    }
    if (Array.isArray(this.suppliers)) {
      data['suppliers'] = [];
      for (let item of this.suppliers) data['suppliers'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPriceApprovalRequestDetailsVm {
  id?: string | undefined;
  requestNumber?: number;
  description?: string | undefined;
  measurementUnitId?: string | undefined;
  termId?: string | undefined;
  quantity?: number;
  notes?: string | undefined;
  projectId?: string | undefined;
  createdAt?: Date;
  createdBy?: string | undefined;
  attachments?: FileAttachmentDto[] | undefined;
  term?: ProjectQuantityMainDataVm | undefined;
  measurementUnit?: MeasurementUnitVm | undefined;
  status?: PriceApprovalRequestStatusVm;
  phase?: PriceApprovalRequestPhaseVm;
  creatorName?: string | undefined;
  history?: PriceApprovalRequestStatusLogVm[] | undefined;
  suppliers?: PriceApprovalRequestSupplierVm[] | undefined;
}

export enum PriceApprovalRequestStatusVm {
  Pending = 0,
  Approved = 1,
  ClientReview = 2,
  ClientRejected = 3,
  Rejected = 4,
  WaitingNewSuppliers = 5,
}

export enum PriceApprovalRequestPhaseVm {
  ProjectManagerReview = 0,
  TechnicalOfficeReview = 1,
  SupplierSelection = 2,
  GeneralManagerReview = 3,
  ClientReview = 4,
  PurchaseReview = 5,
  Completed = 6,
}

export class PriceApprovalRequestStatusLogVm implements IPriceApprovalRequestStatusLogVm {
  id?: string | undefined;
  priceRequestId?: string | undefined;
  status?: PriceApprovalRequestStatus;
  notes?: string | undefined;
  createdAt?: Date;
  attachments?: FileAttachmentDto[] | undefined;
  actor?: PriceApprovalRequestActor;

  constructor(data?: IPriceApprovalRequestStatusLogVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.priceRequestId = _data['priceRequestId'];
      this.status = _data['status'];
      this.notes = _data['notes'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : <any>undefined;
      if (Array.isArray(_data['attachments'])) {
        this.attachments = [] as any;
        for (let item of _data['attachments'])
          this.attachments!.push(FileAttachmentDto.fromJS(item));
      }
      this.actor = _data['actor'];
    }
  }

  static fromJS(data: any): PriceApprovalRequestStatusLogVm {
    data = typeof data === 'object' ? data : {};
    let result = new PriceApprovalRequestStatusLogVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['priceRequestId'] = this.priceRequestId;
    data['status'] = this.status;
    data['notes'] = this.notes;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
    if (Array.isArray(this.attachments)) {
      data['attachments'] = [];
      for (let item of this.attachments) data['attachments'].push(item.toJSON());
    }
    data['actor'] = this.actor;
    return data;
  }
}

export interface IPriceApprovalRequestStatusLogVm {
  id?: string | undefined;
  priceRequestId?: string | undefined;
  status?: PriceApprovalRequestStatus;
  notes?: string | undefined;
  createdAt?: Date;
  attachments?: FileAttachmentDto[] | undefined;
  actor?: PriceApprovalRequestActor;
}

export enum PriceApprovalRequestActor {
  SiteEngineer = 0,
  ProjectManager = 1,
  TechnicalOffice = 2,
  ProjectsManager = 3,
  Purchase = 4,
  GeneralManager = 5,
}

export class PriceApprovalRequestSupplierVm implements IPriceApprovalRequestSupplierVm {
  supplierId?: string | undefined;
  supplierName?: string | undefined;
  selected?: boolean;
  attachments?: FileAttachmentDto[] | undefined;

  constructor(data?: IPriceApprovalRequestSupplierVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.supplierId = _data['supplierId'];
      this.supplierName = _data['supplierName'];
      this.selected = _data['selected'];
      if (Array.isArray(_data['attachments'])) {
        this.attachments = [] as any;
        for (let item of _data['attachments'])
          this.attachments!.push(FileAttachmentDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PriceApprovalRequestSupplierVm {
    data = typeof data === 'object' ? data : {};
    let result = new PriceApprovalRequestSupplierVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['supplierId'] = this.supplierId;
    data['supplierName'] = this.supplierName;
    data['selected'] = this.selected;
    if (Array.isArray(this.attachments)) {
      data['attachments'] = [];
      for (let item of this.attachments) data['attachments'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPriceApprovalRequestSupplierVm {
  supplierId?: string | undefined;
  supplierName?: string | undefined;
  selected?: boolean;
  attachments?: FileAttachmentDto[] | undefined;
}

export class PaginatedListOfPriceApprovalRequestDetailsVm
  implements IPaginatedListOfPriceApprovalRequestDetailsVm
{
  pageInfo?: PageInfo | undefined;
  items?: PriceApprovalRequestDetailsVm[] | undefined;

  constructor(data?: IPaginatedListOfPriceApprovalRequestDetailsVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items'])
          this.items!.push(PriceApprovalRequestDetailsVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfPriceApprovalRequestDetailsVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfPriceApprovalRequestDetailsVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfPriceApprovalRequestDetailsVm {
  pageInfo?: PageInfo | undefined;
  items?: PriceApprovalRequestDetailsVm[] | undefined;
}

export class PriceApprovalRequestDto implements IPriceApprovalRequestDto {
  projectId?: string | undefined;
  description?: string | undefined;
  measurementUnitId?: string | undefined;
  termId?: string | undefined;
  quantity?: number;
  notes?: string | undefined;
  attachments?: UploadAttachmentDto[] | undefined;

  constructor(data?: IPriceApprovalRequestDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.projectId = _data['projectId'];
      this.description = _data['description'];
      this.measurementUnitId = _data['measurementUnitId'];
      this.termId = _data['termId'];
      this.quantity = _data['quantity'];
      this.notes = _data['notes'];
      if (Array.isArray(_data['attachments'])) {
        this.attachments = [] as any;
        for (let item of _data['attachments'])
          this.attachments!.push(UploadAttachmentDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PriceApprovalRequestDto {
    data = typeof data === 'object' ? data : {};
    let result = new PriceApprovalRequestDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['projectId'] = this.projectId;
    data['description'] = this.description;
    data['measurementUnitId'] = this.measurementUnitId;
    data['termId'] = this.termId;
    data['quantity'] = this.quantity;
    data['notes'] = this.notes;
    if (Array.isArray(this.attachments)) {
      data['attachments'] = [];
      for (let item of this.attachments) data['attachments'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPriceApprovalRequestDto {
  projectId?: string | undefined;
  description?: string | undefined;
  measurementUnitId?: string | undefined;
  termId?: string | undefined;
  quantity?: number;
  notes?: string | undefined;
  attachments?: UploadAttachmentDto[] | undefined;
}

export class ChangePriceApprovalRequestStatusDto
  implements IChangePriceApprovalRequestStatusDto
{
  suppliers?: PriceApprovalRequestSupplierDto[] | undefined;
  notes?: string | undefined;
  phase?: PriceApprovalRequestPhase | undefined;
  status?: PriceApprovalRequestStatus | undefined;
  attachments?: UploadAttachmentDto[] | undefined;

  constructor(data?: IChangePriceApprovalRequestStatusDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['suppliers'])) {
        this.suppliers = [] as any;
        for (let item of _data['suppliers'])
          this.suppliers!.push(PriceApprovalRequestSupplierDto.fromJS(item));
      }
      this.notes = _data['notes'];
      this.phase = _data['phase'];
      this.status = _data['status'];
      if (Array.isArray(_data['attachments'])) {
        this.attachments = [] as any;
        for (let item of _data['attachments'])
          this.attachments!.push(UploadAttachmentDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ChangePriceApprovalRequestStatusDto {
    data = typeof data === 'object' ? data : {};
    let result = new ChangePriceApprovalRequestStatusDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.suppliers)) {
      data['suppliers'] = [];
      for (let item of this.suppliers) data['suppliers'].push(item.toJSON());
    }
    data['notes'] = this.notes;
    data['phase'] = this.phase;
    data['status'] = this.status;
    if (Array.isArray(this.attachments)) {
      data['attachments'] = [];
      for (let item of this.attachments) data['attachments'].push(item.toJSON());
    }
    return data;
  }
}

export interface IChangePriceApprovalRequestStatusDto {
  suppliers?: PriceApprovalRequestSupplierDto[] | undefined;
  notes?: string | undefined;
  phase?: PriceApprovalRequestPhase | undefined;
  status?: PriceApprovalRequestStatus | undefined;
  attachments?: UploadAttachmentDto[] | undefined;
}

export class PriceApprovalRequestSupplierDto implements IPriceApprovalRequestSupplierDto {
  supplierId?: string | undefined;
  selected?: boolean;
  attachments?: UploadAttachmentDto[] | undefined;

  constructor(data?: IPriceApprovalRequestSupplierDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.supplierId = _data['supplierId'];
      this.selected = _data['selected'];
      if (Array.isArray(_data['attachments'])) {
        this.attachments = [] as any;
        for (let item of _data['attachments'])
          this.attachments!.push(UploadAttachmentDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PriceApprovalRequestSupplierDto {
    data = typeof data === 'object' ? data : {};
    let result = new PriceApprovalRequestSupplierDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['supplierId'] = this.supplierId;
    data['selected'] = this.selected;
    if (Array.isArray(this.attachments)) {
      data['attachments'] = [];
      for (let item of this.attachments) data['attachments'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPriceApprovalRequestSupplierDto {
  supplierId?: string | undefined;
  selected?: boolean;
  attachments?: UploadAttachmentDto[] | undefined;
}

export enum PriceApprovalRequestPhase {
  ProjectManagerReview = 0,
  TechnicalOfficeReview = 1,
  SupplierSelection = 2,
  GeneralManagerReview = 3,
  ClientReview = 4,
  PurchaseReview = 5,
  Completed = 6,
}

export class AccountDetailsVm implements IAccountDetailsVm {
  name?: FullNameDto | undefined;
  email?: string | undefined;
  username?: string | undefined;
  phoneNumber?: string | undefined;
  pictureUrl?: string | undefined;
  twoFactorEnabled?: boolean;
  roles?: Role[] | undefined;
  modules?: string[] | undefined;
  permissions?: string[] | undefined;

  constructor(data?: IAccountDetailsVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'] ? FullNameDto.fromJS(_data['name']) : <any>undefined;
      this.email = _data['email'];
      this.username = _data['username'];
      this.phoneNumber = _data['phoneNumber'];
      this.pictureUrl = _data['pictureUrl'];
      this.twoFactorEnabled = _data['twoFactorEnabled'];
      if (Array.isArray(_data['roles'])) {
        this.roles = [] as any;
        for (let item of _data['roles']) this.roles!.push(item);
      }
      if (Array.isArray(_data['modules'])) {
        this.modules = [] as any;
        for (let item of _data['modules']) this.modules!.push(item);
      }
      if (Array.isArray(_data['permissions'])) {
        this.permissions = [] as any;
        for (let item of _data['permissions']) this.permissions!.push(item);
      }
    }
  }

  static fromJS(data: any): AccountDetailsVm {
    data = typeof data === 'object' ? data : {};
    let result = new AccountDetailsVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    data['email'] = this.email;
    data['username'] = this.username;
    data['phoneNumber'] = this.phoneNumber;
    data['pictureUrl'] = this.pictureUrl;
    data['twoFactorEnabled'] = this.twoFactorEnabled;
    if (Array.isArray(this.roles)) {
      data['roles'] = [];
      for (let item of this.roles) data['roles'].push(item);
    }
    if (Array.isArray(this.modules)) {
      data['modules'] = [];
      for (let item of this.modules) data['modules'].push(item);
    }
    if (Array.isArray(this.permissions)) {
      data['permissions'] = [];
      for (let item of this.permissions) data['permissions'].push(item);
    }
    return data;
  }
}

export interface IAccountDetailsVm {
  name?: FullNameDto | undefined;
  email?: string | undefined;
  username?: string | undefined;
  phoneNumber?: string | undefined;
  pictureUrl?: string | undefined;
  twoFactorEnabled?: boolean;
  roles?: Role[] | undefined;
  modules?: string[] | undefined;
  permissions?: string[] | undefined;
}

export class ChangeProfileCommand implements IChangeProfileCommand {
  fullName?: FullNameDto | undefined;
  phoneNumber?: string | undefined;

  constructor(data?: IChangeProfileCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.fullName = _data['fullName']
        ? FullNameDto.fromJS(_data['fullName'])
        : <any>undefined;
      this.phoneNumber = _data['phoneNumber'];
    }
  }

  static fromJS(data: any): ChangeProfileCommand {
    data = typeof data === 'object' ? data : {};
    let result = new ChangeProfileCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['fullName'] = this.fullName ? this.fullName.toJSON() : <any>undefined;
    data['phoneNumber'] = this.phoneNumber;
    return data;
  }
}

export interface IChangeProfileCommand {
  fullName?: FullNameDto | undefined;
  phoneNumber?: string | undefined;
}

export class ChangeEmailCommand implements IChangeEmailCommand {
  email?: string | undefined;
  currentPassword?: string | undefined;

  constructor(data?: IChangeEmailCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.email = _data['email'];
      this.currentPassword = _data['currentPassword'];
    }
  }

  static fromJS(data: any): ChangeEmailCommand {
    data = typeof data === 'object' ? data : {};
    let result = new ChangeEmailCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['email'] = this.email;
    data['currentPassword'] = this.currentPassword;
    return data;
  }
}

export interface IChangeEmailCommand {
  email?: string | undefined;
  currentPassword?: string | undefined;
}

export class ChangePasswordCommand implements IChangePasswordCommand {
  oldPassword?: string | undefined;
  newPassword?: string | undefined;
  confirmPassword?: string | undefined;

  constructor(data?: IChangePasswordCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.oldPassword = _data['oldPassword'];
      this.newPassword = _data['newPassword'];
      this.confirmPassword = _data['confirmPassword'];
    }
  }

  static fromJS(data: any): ChangePasswordCommand {
    data = typeof data === 'object' ? data : {};
    let result = new ChangePasswordCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['oldPassword'] = this.oldPassword;
    data['newPassword'] = this.newPassword;
    data['confirmPassword'] = this.confirmPassword;
    return data;
  }
}

export interface IChangePasswordCommand {
  oldPassword?: string | undefined;
  newPassword?: string | undefined;
  confirmPassword?: string | undefined;
}

export class ChangeLanguageCommand implements IChangeLanguageCommand {
  language?: Language;

  constructor(data?: IChangeLanguageCommand) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.language = _data['language'];
    }
  }

  static fromJS(data: any): ChangeLanguageCommand {
    data = typeof data === 'object' ? data : {};
    let result = new ChangeLanguageCommand();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['language'] = this.language;
    return data;
  }
}

export interface IChangeLanguageCommand {
  language?: Language;
}

export enum Language {
  En = 0,
  Ar = 1,
}

export class ContractProjectVm implements IContractProjectVm {
  id?: string | undefined;
  name?: string | undefined;
  userId?: string | undefined;
  siteReceiptDate?: Date;
  siteFinalReceiptDate?: Date;
  sitePrimaryReceiptDate?: Date;
  contractSigningDate?: Date;
  siteImage?: string | undefined;
  contractId?: string | undefined;
  stepNumber?: number;
  lastStep?: number | undefined;
  period?: PeriodDto | undefined;
  bankGuaranteeValidityTo?: Date | undefined;

  constructor(data?: IContractProjectVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.userId = _data['userId'];
      this.siteReceiptDate = _data['siteReceiptDate']
        ? new Date(_data['siteReceiptDate'].toString())
        : <any>undefined;
      this.siteFinalReceiptDate = _data['siteFinalReceiptDate']
        ? new Date(_data['siteFinalReceiptDate'].toString())
        : <any>undefined;
      this.sitePrimaryReceiptDate = _data['sitePrimaryReceiptDate']
        ? new Date(_data['sitePrimaryReceiptDate'].toString())
        : <any>undefined;
      this.contractSigningDate = _data['contractSigningDate']
        ? new Date(_data['contractSigningDate'].toString())
        : <any>undefined;
      this.siteImage = _data['siteImage'];
      this.contractId = _data['contractId'];
      this.stepNumber = _data['stepNumber'];
      this.lastStep = _data['lastStep'];
      this.period = _data['period'] ? PeriodDto.fromJS(_data['period']) : <any>undefined;
      this.bankGuaranteeValidityTo = _data['bankGuaranteeValidityTo']
        ? new Date(_data['bankGuaranteeValidityTo'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): ContractProjectVm {
    data = typeof data === 'object' ? data : {};
    let result = new ContractProjectVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['userId'] = this.userId;
    data['siteReceiptDate'] = this.siteReceiptDate
      ? this.siteReceiptDate.toISOString()
      : <any>undefined;
    data['siteFinalReceiptDate'] = this.siteFinalReceiptDate
      ? this.siteFinalReceiptDate.toISOString()
      : <any>undefined;
    data['sitePrimaryReceiptDate'] = this.sitePrimaryReceiptDate
      ? this.sitePrimaryReceiptDate.toISOString()
      : <any>undefined;
    data['contractSigningDate'] = this.contractSigningDate
      ? this.contractSigningDate.toISOString()
      : <any>undefined;
    data['siteImage'] = this.siteImage;
    data['contractId'] = this.contractId;
    data['stepNumber'] = this.stepNumber;
    data['lastStep'] = this.lastStep;
    data['period'] = this.period ? this.period.toJSON() : <any>undefined;
    data['bankGuaranteeValidityTo'] = this.bankGuaranteeValidityTo
      ? this.bankGuaranteeValidityTo.toISOString()
      : <any>undefined;
    return data;
  }
}

export interface IContractProjectVm {
  id?: string | undefined;
  name?: string | undefined;
  userId?: string | undefined;
  siteReceiptDate?: Date;
  siteFinalReceiptDate?: Date;
  sitePrimaryReceiptDate?: Date;
  contractSigningDate?: Date;
  siteImage?: string | undefined;
  contractId?: string | undefined;
  stepNumber?: number;
  lastStep?: number | undefined;
  period?: PeriodDto | undefined;
  bankGuaranteeValidityTo?: Date | undefined;
}

export class ProjectMainDataVm implements IProjectMainDataVm {
  id?: string | undefined;
  name?: string | undefined;
  totalPrice?: number;

  constructor(data?: IProjectMainDataVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.totalPrice = _data['totalPrice'];
    }
  }

  static fromJS(data: any): ProjectMainDataVm {
    data = typeof data === 'object' ? data : {};
    let result = new ProjectMainDataVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['totalPrice'] = this.totalPrice;
    return data;
  }
}

export interface IProjectMainDataVm {
  id?: string | undefined;
  name?: string | undefined;
  totalPrice?: number;
}

export class ProjectQuantityVm implements IProjectQuantityVm {
  id?: string | undefined;
  title?: string | undefined;
  itemNumber?: number;
  description?: string | undefined;
  specifications?: string | undefined;
  status?: ProjectQuantityStatus;
  businessType?: BusinessType;
  quantity?: number;
  unitPrice?: number;
  totalPrice?: number;
  totalPriceWithVat?: number;
  actualValue?: number;
  measurementUnitName?: WeakLocalizedString | undefined;
  projectId?: string | undefined;
  projectName?: string | undefined;
  measurementUnitId?: string | undefined;

  constructor(data?: IProjectQuantityVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.title = _data['title'];
      this.itemNumber = _data['itemNumber'];
      this.description = _data['description'];
      this.specifications = _data['specifications'];
      this.status = _data['status'];
      this.businessType = _data['businessType'];
      this.quantity = _data['quantity'];
      this.unitPrice = _data['unitPrice'];
      this.totalPrice = _data['totalPrice'];
      this.totalPriceWithVat = _data['totalPriceWithVat'];
      this.actualValue = _data['actualValue'];
      this.measurementUnitName = _data['measurementUnitName']
        ? WeakLocalizedString.fromJS(_data['measurementUnitName'])
        : <any>undefined;
      this.projectId = _data['projectId'];
      this.projectName = _data['projectName'];
      this.measurementUnitId = _data['measurementUnitId'];
    }
  }

  static fromJS(data: any): ProjectQuantityVm {
    data = typeof data === 'object' ? data : {};
    let result = new ProjectQuantityVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['title'] = this.title;
    data['itemNumber'] = this.itemNumber;
    data['description'] = this.description;
    data['specifications'] = this.specifications;
    data['status'] = this.status;
    data['businessType'] = this.businessType;
    data['quantity'] = this.quantity;
    data['unitPrice'] = this.unitPrice;
    data['totalPrice'] = this.totalPrice;
    data['totalPriceWithVat'] = this.totalPriceWithVat;
    data['actualValue'] = this.actualValue;
    data['measurementUnitName'] = this.measurementUnitName
      ? this.measurementUnitName.toJSON()
      : <any>undefined;
    data['projectId'] = this.projectId;
    data['projectName'] = this.projectName;
    data['measurementUnitId'] = this.measurementUnitId;
    return data;
  }
}

export interface IProjectQuantityVm {
  id?: string | undefined;
  title?: string | undefined;
  itemNumber?: number;
  description?: string | undefined;
  specifications?: string | undefined;
  status?: ProjectQuantityStatus;
  businessType?: BusinessType;
  quantity?: number;
  unitPrice?: number;
  totalPrice?: number;
  totalPriceWithVat?: number;
  actualValue?: number;
  measurementUnitName?: WeakLocalizedString | undefined;
  projectId?: string | undefined;
  projectName?: string | undefined;
  measurementUnitId?: string | undefined;
}

export enum ProjectQuantityStatus {
  NotStarted = 0,
  InProgress = 1,
  Completed = 2,
}

export enum BusinessType {
  Structural = 0,
  Architectural = 1,
  Electrical = 2,
  Mechanical = 3,
  Telecommunications = 4,
  Other = 5,
}

export class PaginatedListOfProjectQuantityVm
  implements IPaginatedListOfProjectQuantityVm
{
  pageInfo?: PageInfo | undefined;
  items?: ProjectQuantityVm[] | undefined;

  constructor(data?: IPaginatedListOfProjectQuantityVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(ProjectQuantityVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfProjectQuantityVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfProjectQuantityVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfProjectQuantityVm {
  pageInfo?: PageInfo | undefined;
  items?: ProjectQuantityVm[] | undefined;
}

export class ProjectDetailsVm implements IProjectDetailsVm {
  id?: string | undefined;
  contractRefNumber?: string | undefined;
  name?: string | undefined;
  description?: string | undefined;
  status?: ProjectStatus;
  startingDate?: Date | undefined;
  endingDate?: Date | undefined;
  contractSigningDate?: Date;
  constructionPeriod?: PeriodDto | undefined;
  remainingTime?: RemainingTimeDto | undefined;
  assignedUsers?: string[] | undefined;
  siteImage?: string | undefined;

  constructor(data?: IProjectDetailsVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.contractRefNumber = _data['contractRefNumber'];
      this.name = _data['name'];
      this.description = _data['description'];
      this.status = _data['status'];
      this.startingDate = _data['startingDate']
        ? new Date(_data['startingDate'].toString())
        : <any>undefined;
      this.endingDate = _data['endingDate']
        ? new Date(_data['endingDate'].toString())
        : <any>undefined;
      this.contractSigningDate = _data['contractSigningDate']
        ? new Date(_data['contractSigningDate'].toString())
        : <any>undefined;
      this.constructionPeriod = _data['constructionPeriod']
        ? PeriodDto.fromJS(_data['constructionPeriod'])
        : <any>undefined;
      this.remainingTime = _data['remainingTime']
        ? RemainingTimeDto.fromJS(_data['remainingTime'])
        : <any>undefined;
      if (Array.isArray(_data['assignedUsers'])) {
        this.assignedUsers = [] as any;
        for (let item of _data['assignedUsers']) this.assignedUsers!.push(item);
      }
      this.siteImage = _data['siteImage'];
    }
  }

  static fromJS(data: any): ProjectDetailsVm {
    data = typeof data === 'object' ? data : {};
    let result = new ProjectDetailsVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['contractRefNumber'] = this.contractRefNumber;
    data['name'] = this.name;
    data['description'] = this.description;
    data['status'] = this.status;
    data['startingDate'] = this.startingDate
      ? this.startingDate.toISOString()
      : <any>undefined;
    data['endingDate'] = this.endingDate ? this.endingDate.toISOString() : <any>undefined;
    data['contractSigningDate'] = this.contractSigningDate
      ? this.contractSigningDate.toISOString()
      : <any>undefined;
    data['constructionPeriod'] = this.constructionPeriod
      ? this.constructionPeriod.toJSON()
      : <any>undefined;
    data['remainingTime'] = this.remainingTime
      ? this.remainingTime.toJSON()
      : <any>undefined;
    if (Array.isArray(this.assignedUsers)) {
      data['assignedUsers'] = [];
      for (let item of this.assignedUsers) data['assignedUsers'].push(item);
    }
    data['siteImage'] = this.siteImage;
    return data;
  }
}

export interface IProjectDetailsVm {
  id?: string | undefined;
  contractRefNumber?: string | undefined;
  name?: string | undefined;
  description?: string | undefined;
  status?: ProjectStatus;
  startingDate?: Date | undefined;
  endingDate?: Date | undefined;
  contractSigningDate?: Date;
  constructionPeriod?: PeriodDto | undefined;
  remainingTime?: RemainingTimeDto | undefined;
  assignedUsers?: string[] | undefined;
  siteImage?: string | undefined;
}

export enum ProjectStatus {
  NotStarted = 0,
  InProgress = 1,
  Completed = 2,
  Canceled = 3,
}

export class RemainingTimeDto implements IRemainingTimeDto {
  remainingPeriod?: PeriodDto | undefined;
  percentage?: number;

  constructor(data?: IRemainingTimeDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.remainingPeriod = _data['remainingPeriod']
        ? PeriodDto.fromJS(_data['remainingPeriod'])
        : <any>undefined;
      this.percentage = _data['percentage'];
    }
  }

  static fromJS(data: any): RemainingTimeDto {
    data = typeof data === 'object' ? data : {};
    let result = new RemainingTimeDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['remainingPeriod'] = this.remainingPeriod
      ? this.remainingPeriod.toJSON()
      : <any>undefined;
    data['percentage'] = this.percentage;
    return data;
  }
}

export interface IRemainingTimeDto {
  remainingPeriod?: PeriodDto | undefined;
  percentage?: number;
}

export class ProjectVatVm implements IProjectVatVm {
  id?: string | undefined;
  vat?: number;

  constructor(data?: IProjectVatVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.vat = _data['vat'];
    }
  }

  static fromJS(data: any): ProjectVatVm {
    data = typeof data === 'object' ? data : {};
    let result = new ProjectVatVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['vat'] = this.vat;
    return data;
  }
}

export interface IProjectVatVm {
  id?: string | undefined;
  vat?: number;
}

export class PaginatedListOfProjectListingVm implements IPaginatedListOfProjectListingVm {
  pageInfo?: PageInfo | undefined;
  items?: ProjectListingVm[] | undefined;

  constructor(data?: IPaginatedListOfProjectListingVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(ProjectListingVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfProjectListingVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfProjectListingVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfProjectListingVm {
  pageInfo?: PageInfo | undefined;
  items?: ProjectListingVm[] | undefined;
}

export class ProjectListingVm implements IProjectListingVm {
  id?: string | undefined;
  name?: string | undefined;
  description?: string | undefined;
  status?: ProjectStatus;
  startingDate?: Date | undefined;
  endingDate?: Date | undefined;
  constructionPeriod?: PeriodDto | undefined;
  remainingTime?: RemainingTimeDto | undefined;
  assignedUsers?: string[] | undefined;
  totalPrice?: number;
  siteImage?: string | undefined;

  constructor(data?: IProjectListingVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.description = _data['description'];
      this.status = _data['status'];
      this.startingDate = _data['startingDate']
        ? new Date(_data['startingDate'].toString())
        : <any>undefined;
      this.endingDate = _data['endingDate']
        ? new Date(_data['endingDate'].toString())
        : <any>undefined;
      this.constructionPeriod = _data['constructionPeriod']
        ? PeriodDto.fromJS(_data['constructionPeriod'])
        : <any>undefined;
      this.remainingTime = _data['remainingTime']
        ? RemainingTimeDto.fromJS(_data['remainingTime'])
        : <any>undefined;
      if (Array.isArray(_data['assignedUsers'])) {
        this.assignedUsers = [] as any;
        for (let item of _data['assignedUsers']) this.assignedUsers!.push(item);
      }
      this.totalPrice = _data['totalPrice'];
      this.siteImage = _data['siteImage'];
    }
  }

  static fromJS(data: any): ProjectListingVm {
    data = typeof data === 'object' ? data : {};
    let result = new ProjectListingVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['description'] = this.description;
    data['status'] = this.status;
    data['startingDate'] = this.startingDate
      ? this.startingDate.toISOString()
      : <any>undefined;
    data['endingDate'] = this.endingDate ? this.endingDate.toISOString() : <any>undefined;
    data['constructionPeriod'] = this.constructionPeriod
      ? this.constructionPeriod.toJSON()
      : <any>undefined;
    data['remainingTime'] = this.remainingTime
      ? this.remainingTime.toJSON()
      : <any>undefined;
    if (Array.isArray(this.assignedUsers)) {
      data['assignedUsers'] = [];
      for (let item of this.assignedUsers) data['assignedUsers'].push(item);
    }
    data['totalPrice'] = this.totalPrice;
    data['siteImage'] = this.siteImage;
    return data;
  }
}

export interface IProjectListingVm {
  id?: string | undefined;
  name?: string | undefined;
  description?: string | undefined;
  status?: ProjectStatus;
  startingDate?: Date | undefined;
  endingDate?: Date | undefined;
  constructionPeriod?: PeriodDto | undefined;
  remainingTime?: RemainingTimeDto | undefined;
  assignedUsers?: string[] | undefined;
  totalPrice?: number;
  siteImage?: string | undefined;
}

export class ProjectDropdownVm implements IProjectDropdownVm {
  id?: string | undefined;
  name?: string | undefined;
  quantities?: ProjectQuantityDropdownVm[] | undefined;

  constructor(data?: IProjectDropdownVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      if (Array.isArray(_data['quantities'])) {
        this.quantities = [] as any;
        for (let item of _data['quantities'])
          this.quantities!.push(ProjectQuantityDropdownVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ProjectDropdownVm {
    data = typeof data === 'object' ? data : {};
    let result = new ProjectDropdownVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    if (Array.isArray(this.quantities)) {
      data['quantities'] = [];
      for (let item of this.quantities) data['quantities'].push(item.toJSON());
    }
    return data;
  }
}

export interface IProjectDropdownVm {
  id?: string | undefined;
  name?: string | undefined;
  quantities?: ProjectQuantityDropdownVm[] | undefined;
}

export class ProjectQuantityDropdownVm implements IProjectQuantityDropdownVm {
  id?: string | undefined;
  title?: string | undefined;
  measurementUnit?: string | undefined;

  constructor(data?: IProjectQuantityDropdownVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.title = _data['title'];
      this.measurementUnit = _data['measurementUnit'];
    }
  }

  static fromJS(data: any): ProjectQuantityDropdownVm {
    data = typeof data === 'object' ? data : {};
    let result = new ProjectQuantityDropdownVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['title'] = this.title;
    data['measurementUnit'] = this.measurementUnit;
    return data;
  }
}

export interface IProjectQuantityDropdownVm {
  id?: string | undefined;
  title?: string | undefined;
  measurementUnit?: string | undefined;
}

export class ProjectsStatusVm implements IProjectsStatusVm {
  totalCount?: number;
  hasContract?: number;
  noContract?: number;
  completed?: number;
  inProgress?: number;
  notStarted?: number;

  constructor(data?: IProjectsStatusVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.totalCount = _data['totalCount'];
      this.hasContract = _data['hasContract'];
      this.noContract = _data['noContract'];
      this.completed = _data['completed'];
      this.inProgress = _data['inProgress'];
      this.notStarted = _data['notStarted'];
    }
  }

  static fromJS(data: any): ProjectsStatusVm {
    data = typeof data === 'object' ? data : {};
    let result = new ProjectsStatusVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalCount'] = this.totalCount;
    data['hasContract'] = this.hasContract;
    data['noContract'] = this.noContract;
    data['completed'] = this.completed;
    data['inProgress'] = this.inProgress;
    data['notStarted'] = this.notStarted;
    return data;
  }
}

export interface IProjectsStatusVm {
  totalCount?: number;
  hasContract?: number;
  noContract?: number;
  completed?: number;
  inProgress?: number;
  notStarted?: number;
}

export class ProjectQuantityAutoCompleteVm implements IProjectQuantityAutoCompleteVm {
  id?: string | undefined;
  title?: string | undefined;

  constructor(data?: IProjectQuantityAutoCompleteVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.title = _data['title'];
    }
  }

  static fromJS(data: any): ProjectQuantityAutoCompleteVm {
    data = typeof data === 'object' ? data : {};
    let result = new ProjectQuantityAutoCompleteVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['title'] = this.title;
    return data;
  }
}

export interface IProjectQuantityAutoCompleteVm {
  id?: string | undefined;
  title?: string | undefined;
}

export class ProjectAssignees implements IProjectAssignees {
  groups?: { [key in keyof typeof BusinessType]?: ProjectAssigneeVm[] } | undefined;
  managers?: ProjectAssigneeVm[] | undefined;

  constructor(data?: IProjectAssignees) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (_data['groups']) {
        this.groups = {} as any;
        for (let key in _data['groups']) {
          if (_data['groups'].hasOwnProperty(key))
            (<any>this.groups)![key] = _data['groups'][key]
              ? _data['groups'][key].map((i: any) => ProjectAssigneeVm.fromJS(i))
              : [];
        }
      }
      if (Array.isArray(_data['managers'])) {
        this.managers = [] as any;
        for (let item of _data['managers'])
          this.managers!.push(ProjectAssigneeVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ProjectAssignees {
    data = typeof data === 'object' ? data : {};
    let result = new ProjectAssignees();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (this.groups) {
      data['groups'] = {};
      for (let key in this.groups) {
        if (this.groups.hasOwnProperty(key))
          (<any>data['groups'])[key] = (<any>this.groups)[key];
      }
    }
    if (Array.isArray(this.managers)) {
      data['managers'] = [];
      for (let item of this.managers) data['managers'].push(item.toJSON());
    }
    return data;
  }
}

export interface IProjectAssignees {
  groups?: { [key in keyof typeof BusinessType]?: ProjectAssigneeVm[] } | undefined;
  managers?: ProjectAssigneeVm[] | undefined;
}

export class ProjectAssigneeVm implements IProjectAssigneeVm {
  userId?: string | undefined;

  constructor(data?: IProjectAssigneeVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.userId = _data['userId'];
    }
  }

  static fromJS(data: any): ProjectAssigneeVm {
    data = typeof data === 'object' ? data : {};
    let result = new ProjectAssigneeVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['userId'] = this.userId;
    return data;
  }
}

export interface IProjectAssigneeVm {
  userId?: string | undefined;
}

export class ProjectAssigneeDetailsVm implements IProjectAssigneeDetailsVm {
  name?: string | undefined;
  picture?: string | undefined;
  type?: BusinessType;
  roles?: Role[] | undefined;

  constructor(data?: IProjectAssigneeDetailsVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.picture = _data['picture'];
      this.type = _data['type'];
      if (Array.isArray(_data['roles'])) {
        this.roles = [] as any;
        for (let item of _data['roles']) this.roles!.push(item);
      }
    }
  }

  static fromJS(data: any): ProjectAssigneeDetailsVm {
    data = typeof data === 'object' ? data : {};
    let result = new ProjectAssigneeDetailsVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['picture'] = this.picture;
    data['type'] = this.type;
    if (Array.isArray(this.roles)) {
      data['roles'] = [];
      for (let item of this.roles) data['roles'].push(item);
    }
    return data;
  }
}

export interface IProjectAssigneeDetailsVm {
  name?: string | undefined;
  picture?: string | undefined;
  type?: BusinessType;
  roles?: Role[] | undefined;
}

export class ProjectModifiedDataVm implements IProjectModifiedDataVm {
  id?: string | undefined;
  name?: string | undefined;
  siteImage?: string | undefined;
  description?: string | undefined;
  status?: ProjectStatus;

  constructor(data?: IProjectModifiedDataVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.siteImage = _data['siteImage'];
      this.description = _data['description'];
      this.status = _data['status'];
    }
  }

  static fromJS(data: any): ProjectModifiedDataVm {
    data = typeof data === 'object' ? data : {};
    let result = new ProjectModifiedDataVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['siteImage'] = this.siteImage;
    data['description'] = this.description;
    data['status'] = this.status;
    return data;
  }
}

export interface IProjectModifiedDataVm {
  id?: string | undefined;
  name?: string | undefined;
  siteImage?: string | undefined;
  description?: string | undefined;
  status?: ProjectStatus;
}

export class ProjectDto implements IProjectDto {
  name?: string | undefined;
  contractId?: string | undefined;
  userId?: string | undefined;
  siteReceiptDate?: Date;
  siteFinalReceiptDate?: Date;
  sitePrimaryReceiptDate?: Date;
  siteImage?: string | undefined;
  savingType?: SavingType;

  constructor(data?: IProjectDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.contractId = _data['contractId'];
      this.userId = _data['userId'];
      this.siteReceiptDate = _data['siteReceiptDate']
        ? new Date(_data['siteReceiptDate'].toString())
        : <any>undefined;
      this.siteFinalReceiptDate = _data['siteFinalReceiptDate']
        ? new Date(_data['siteFinalReceiptDate'].toString())
        : <any>undefined;
      this.sitePrimaryReceiptDate = _data['sitePrimaryReceiptDate']
        ? new Date(_data['sitePrimaryReceiptDate'].toString())
        : <any>undefined;
      this.siteImage = _data['siteImage'];
      this.savingType = _data['savingType'];
    }
  }

  static fromJS(data: any): ProjectDto {
    data = typeof data === 'object' ? data : {};
    let result = new ProjectDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['contractId'] = this.contractId;
    data['userId'] = this.userId;
    data['siteReceiptDate'] = this.siteReceiptDate
      ? this.siteReceiptDate.toISOString()
      : <any>undefined;
    data['siteFinalReceiptDate'] = this.siteFinalReceiptDate
      ? this.siteFinalReceiptDate.toISOString()
      : <any>undefined;
    data['sitePrimaryReceiptDate'] = this.sitePrimaryReceiptDate
      ? this.sitePrimaryReceiptDate.toISOString()
      : <any>undefined;
    data['siteImage'] = this.siteImage;
    data['savingType'] = this.savingType;
    return data;
  }
}

export interface IProjectDto {
  name?: string | undefined;
  contractId?: string | undefined;
  userId?: string | undefined;
  siteReceiptDate?: Date;
  siteFinalReceiptDate?: Date;
  sitePrimaryReceiptDate?: Date;
  siteImage?: string | undefined;
  savingType?: SavingType;
}

export class ProjectDetailsDto implements IProjectDetailsDto {
  name?: string | undefined;
  description?: string | undefined;
  siteImage?: string | undefined;
  status?: ProjectStatus;

  constructor(data?: IProjectDetailsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.description = _data['description'];
      this.siteImage = _data['siteImage'];
      this.status = _data['status'];
    }
  }

  static fromJS(data: any): ProjectDetailsDto {
    data = typeof data === 'object' ? data : {};
    let result = new ProjectDetailsDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['description'] = this.description;
    data['siteImage'] = this.siteImage;
    data['status'] = this.status;
    return data;
  }
}

export interface IProjectDetailsDto {
  name?: string | undefined;
  description?: string | undefined;
  siteImage?: string | undefined;
  status?: ProjectStatus;
}

export class ProjectQuantityDto implements IProjectQuantityDto {
  title?: string | undefined;
  itemNumber?: number;
  description?: string | undefined;
  specifications?: string | undefined;
  quantity?: number;
  unitPrice?: number;
  projectId?: string | undefined;
  measurementUnitId?: string | undefined;
  businessType?: BusinessType;
  savingType?: SavingType;

  constructor(data?: IProjectQuantityDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.title = _data['title'];
      this.itemNumber = _data['itemNumber'];
      this.description = _data['description'];
      this.specifications = _data['specifications'];
      this.quantity = _data['quantity'];
      this.unitPrice = _data['unitPrice'];
      this.projectId = _data['projectId'];
      this.measurementUnitId = _data['measurementUnitId'];
      this.businessType = _data['businessType'];
      this.savingType = _data['savingType'];
    }
  }

  static fromJS(data: any): ProjectQuantityDto {
    data = typeof data === 'object' ? data : {};
    let result = new ProjectQuantityDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['title'] = this.title;
    data['itemNumber'] = this.itemNumber;
    data['description'] = this.description;
    data['specifications'] = this.specifications;
    data['quantity'] = this.quantity;
    data['unitPrice'] = this.unitPrice;
    data['projectId'] = this.projectId;
    data['measurementUnitId'] = this.measurementUnitId;
    data['businessType'] = this.businessType;
    data['savingType'] = this.savingType;
    return data;
  }
}

export interface IProjectQuantityDto {
  title?: string | undefined;
  itemNumber?: number;
  description?: string | undefined;
  specifications?: string | undefined;
  quantity?: number;
  unitPrice?: number;
  projectId?: string | undefined;
  measurementUnitId?: string | undefined;
  businessType?: BusinessType;
  savingType?: SavingType;
}

export class AssignUserDto implements IAssignUserDto {
  type?: BusinessType;
  userId?: string | undefined;

  constructor(data?: IAssignUserDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.type = _data['type'];
      this.userId = _data['userId'];
    }
  }

  static fromJS(data: any): AssignUserDto {
    data = typeof data === 'object' ? data : {};
    let result = new AssignUserDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['type'] = this.type;
    data['userId'] = this.userId;
    return data;
  }
}

export interface IAssignUserDto {
  type?: BusinessType;
  userId?: string | undefined;
}

export class ProjectTasksSummaryVM implements IProjectTasksSummaryVM {
  projectId?: string | undefined;
  totalTasksCount?: number;
  notStartedTaskCount?: number;
  inProgressTasksCount?: number;
  completedTasksCount?: number;

  constructor(data?: IProjectTasksSummaryVM) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.projectId = _data['projectId'];
      this.totalTasksCount = _data['totalTasksCount'];
      this.notStartedTaskCount = _data['notStartedTaskCount'];
      this.inProgressTasksCount = _data['inProgressTasksCount'];
      this.completedTasksCount = _data['completedTasksCount'];
    }
  }

  static fromJS(data: any): ProjectTasksSummaryVM {
    data = typeof data === 'object' ? data : {};
    let result = new ProjectTasksSummaryVM();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['projectId'] = this.projectId;
    data['totalTasksCount'] = this.totalTasksCount;
    data['notStartedTaskCount'] = this.notStartedTaskCount;
    data['inProgressTasksCount'] = this.inProgressTasksCount;
    data['completedTasksCount'] = this.completedTasksCount;
    return data;
  }
}

export interface IProjectTasksSummaryVM {
  projectId?: string | undefined;
  totalTasksCount?: number;
  notStartedTaskCount?: number;
  inProgressTasksCount?: number;
  completedTasksCount?: number;
}

export class StorageFile implements IStorageFile {
  uniqueKey?: string | undefined;
  displayName?: string | undefined;
  file?: string | undefined;

  constructor(data?: IStorageFile) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.uniqueKey = _data['uniqueKey'];
      this.displayName = _data['displayName'];
      this.file = _data['file'];
    }
  }

  static fromJS(data: any): StorageFile {
    data = typeof data === 'object' ? data : {};
    let result = new StorageFile();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['uniqueKey'] = this.uniqueKey;
    data['displayName'] = this.displayName;
    data['file'] = this.file;
    return data;
  }
}

export interface IStorageFile {
  uniqueKey?: string | undefined;
  displayName?: string | undefined;
  file?: string | undefined;
}

export class StorageFileDto implements IStorageFileDto {
  files?: StorageFile[] | undefined;
  attachmentType?: AttachmentType;
  entityId?: string | undefined;

  constructor(data?: IStorageFileDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['files'])) {
        this.files = [] as any;
        for (let item of _data['files']) this.files!.push(StorageFile.fromJS(item));
      }
      this.attachmentType = _data['attachmentType'];
      this.entityId = _data['entityId'];
    }
  }

  static fromJS(data: any): StorageFileDto {
    data = typeof data === 'object' ? data : {};
    let result = new StorageFileDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.files)) {
      data['files'] = [];
      for (let item of this.files) data['files'].push(item.toJSON());
    }
    data['attachmentType'] = this.attachmentType;
    data['entityId'] = this.entityId;
    return data;
  }
}

export interface IStorageFileDto {
  files?: StorageFile[] | undefined;
  attachmentType?: AttachmentType;
  entityId?: string | undefined;
}

export class PaginatedListOfSupplierApprovalRequestVm
  implements IPaginatedListOfSupplierApprovalRequestVm
{
  pageInfo?: PageInfo | undefined;
  items?: SupplierApprovalRequestVm[] | undefined;

  constructor(data?: IPaginatedListOfSupplierApprovalRequestVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items'])
          this.items!.push(SupplierApprovalRequestVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfSupplierApprovalRequestVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfSupplierApprovalRequestVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfSupplierApprovalRequestVm {
  pageInfo?: PageInfo | undefined;
  items?: SupplierApprovalRequestVm[] | undefined;
}

export class SupplierApprovalRequestVm implements ISupplierApprovalRequestVm {
  id?: string | undefined;
  code?: string | undefined;
  createdBy?: string | undefined;
  projectId?: string | undefined;
  projectName?: string | undefined;
  termId?: string | undefined;
  termName?: string | undefined;
  measurementUnitId?: string | undefined;
  measurementUnitName?: string | undefined;
  phase?: SupplierApprovalRequestPhase;
  quantity?: number;
  status?: SupplierApprovalRequestStatusVm;
  notes?: string | undefined;

  constructor(data?: ISupplierApprovalRequestVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.code = _data['code'];
      this.createdBy = _data['createdBy'];
      this.projectId = _data['projectId'];
      this.projectName = _data['projectName'];
      this.termId = _data['termId'];
      this.termName = _data['termName'];
      this.measurementUnitId = _data['measurementUnitId'];
      this.measurementUnitName = _data['measurementUnitName'];
      this.phase = _data['phase'];
      this.quantity = _data['quantity'];
      this.status = _data['status'];
      this.notes = _data['notes'];
    }
  }

  static fromJS(data: any): SupplierApprovalRequestVm {
    data = typeof data === 'object' ? data : {};
    let result = new SupplierApprovalRequestVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['code'] = this.code;
    data['createdBy'] = this.createdBy;
    data['projectId'] = this.projectId;
    data['projectName'] = this.projectName;
    data['termId'] = this.termId;
    data['termName'] = this.termName;
    data['measurementUnitId'] = this.measurementUnitId;
    data['measurementUnitName'] = this.measurementUnitName;
    data['phase'] = this.phase;
    data['quantity'] = this.quantity;
    data['status'] = this.status;
    data['notes'] = this.notes;
    return data;
  }
}

export interface ISupplierApprovalRequestVm {
  id?: string | undefined;
  code?: string | undefined;
  createdBy?: string | undefined;
  projectId?: string | undefined;
  projectName?: string | undefined;
  termId?: string | undefined;
  termName?: string | undefined;
  measurementUnitId?: string | undefined;
  measurementUnitName?: string | undefined;
  phase?: SupplierApprovalRequestPhase;
  quantity?: number;
  status?: SupplierApprovalRequestStatusVm;
  notes?: string | undefined;
}

export enum SupplierApprovalRequestPhase {
  ProjectManagerReview = 0,
  TechnicalOfficeReview = 1,
  SupplierSelection = 2,
  ClientReview = 3,
  Completed = 4,
}

export enum SupplierApprovalRequestStatusVm {
  Pending = 0,
  Approved = 1,
  ClientReview = 2,
  ClientRejected = 3,
  Rejected = 4,
}

export class SupplierApprovalRequestDetailsVm
  implements ISupplierApprovalRequestDetailsVm
{
  id?: string | undefined;
  projectId?: string | undefined;
  termId?: string | undefined;
  measurementUnitId?: string | undefined;
  createdBy?: string | undefined;
  phase?: SupplierApprovalRequestPhase;
  quantity?: number;
  notes?: string | undefined;
  suppliers?: SupplierApprovalRequestSupplierVm[] | undefined;
  rejectionHistory?: SupplierApprovalRequestStatusLogVm[] | undefined;

  constructor(data?: ISupplierApprovalRequestDetailsVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.projectId = _data['projectId'];
      this.termId = _data['termId'];
      this.measurementUnitId = _data['measurementUnitId'];
      this.createdBy = _data['createdBy'];
      this.phase = _data['phase'];
      this.quantity = _data['quantity'];
      this.notes = _data['notes'];
      if (Array.isArray(_data['suppliers'])) {
        this.suppliers = [] as any;
        for (let item of _data['suppliers'])
          this.suppliers!.push(SupplierApprovalRequestSupplierVm.fromJS(item));
      }
      if (Array.isArray(_data['rejectionHistory'])) {
        this.rejectionHistory = [] as any;
        for (let item of _data['rejectionHistory'])
          this.rejectionHistory!.push(SupplierApprovalRequestStatusLogVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): SupplierApprovalRequestDetailsVm {
    data = typeof data === 'object' ? data : {};
    let result = new SupplierApprovalRequestDetailsVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['projectId'] = this.projectId;
    data['termId'] = this.termId;
    data['measurementUnitId'] = this.measurementUnitId;
    data['createdBy'] = this.createdBy;
    data['phase'] = this.phase;
    data['quantity'] = this.quantity;
    data['notes'] = this.notes;
    if (Array.isArray(this.suppliers)) {
      data['suppliers'] = [];
      for (let item of this.suppliers) data['suppliers'].push(item.toJSON());
    }
    if (Array.isArray(this.rejectionHistory)) {
      data['rejectionHistory'] = [];
      for (let item of this.rejectionHistory)
        data['rejectionHistory'].push(item.toJSON());
    }
    return data;
  }
}

export interface ISupplierApprovalRequestDetailsVm {
  id?: string | undefined;
  projectId?: string | undefined;
  termId?: string | undefined;
  measurementUnitId?: string | undefined;
  createdBy?: string | undefined;
  phase?: SupplierApprovalRequestPhase;
  quantity?: number;
  notes?: string | undefined;
  suppliers?: SupplierApprovalRequestSupplierVm[] | undefined;
  rejectionHistory?: SupplierApprovalRequestStatusLogVm[] | undefined;
}

export class SupplierApprovalRequestSupplierVm
  implements ISupplierApprovalRequestSupplierVm
{
  supplierId?: string | undefined;
  supplierName?: string | undefined;
  price?: number;
  selected?: boolean;
  attachments?: FileAttachmentDto[] | undefined;

  constructor(data?: ISupplierApprovalRequestSupplierVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.supplierId = _data['supplierId'];
      this.supplierName = _data['supplierName'];
      this.price = _data['price'];
      this.selected = _data['selected'];
      if (Array.isArray(_data['attachments'])) {
        this.attachments = [] as any;
        for (let item of _data['attachments'])
          this.attachments!.push(FileAttachmentDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): SupplierApprovalRequestSupplierVm {
    data = typeof data === 'object' ? data : {};
    let result = new SupplierApprovalRequestSupplierVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['supplierId'] = this.supplierId;
    data['supplierName'] = this.supplierName;
    data['price'] = this.price;
    data['selected'] = this.selected;
    if (Array.isArray(this.attachments)) {
      data['attachments'] = [];
      for (let item of this.attachments) data['attachments'].push(item.toJSON());
    }
    return data;
  }
}

export interface ISupplierApprovalRequestSupplierVm {
  supplierId?: string | undefined;
  supplierName?: string | undefined;
  price?: number;
  selected?: boolean;
  attachments?: FileAttachmentDto[] | undefined;
}

export class SupplierApprovalRequestStatusLogVm
  implements ISupplierApprovalRequestStatusLogVm
{
  rejectionReason?: string | undefined;
  createdAt?: Date;
  rejectedBy?: string | undefined;

  constructor(data?: ISupplierApprovalRequestStatusLogVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.rejectionReason = _data['rejectionReason'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : <any>undefined;
      this.rejectedBy = _data['rejectedBy'];
    }
  }

  static fromJS(data: any): SupplierApprovalRequestStatusLogVm {
    data = typeof data === 'object' ? data : {};
    let result = new SupplierApprovalRequestStatusLogVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['rejectionReason'] = this.rejectionReason;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
    data['rejectedBy'] = this.rejectedBy;
    return data;
  }
}

export interface ISupplierApprovalRequestStatusLogVm {
  rejectionReason?: string | undefined;
  createdAt?: Date;
  rejectedBy?: string | undefined;
}

export class SupplierApprovalRequestDto implements ISupplierApprovalRequestDto {
  projectId?: string | undefined;
  termId?: string | undefined;
  quantity?: number;
  notes?: string | undefined;

  constructor(data?: ISupplierApprovalRequestDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.projectId = _data['projectId'];
      this.termId = _data['termId'];
      this.quantity = _data['quantity'];
      this.notes = _data['notes'];
    }
  }

  static fromJS(data: any): SupplierApprovalRequestDto {
    data = typeof data === 'object' ? data : {};
    let result = new SupplierApprovalRequestDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['projectId'] = this.projectId;
    data['termId'] = this.termId;
    data['quantity'] = this.quantity;
    data['notes'] = this.notes;
    return data;
  }
}

export interface ISupplierApprovalRequestDto {
  projectId?: string | undefined;
  termId?: string | undefined;
  quantity?: number;
  notes?: string | undefined;
}

export class ChangeSupplierApprovalRequestStatusDto
  implements IChangeSupplierApprovalRequestStatusDto
{
  suppliers?: SupplierApprovalRequestSupplierDto[] | undefined;
  notes?: string | undefined;

  constructor(data?: IChangeSupplierApprovalRequestStatusDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data['suppliers'])) {
        this.suppliers = [] as any;
        for (let item of _data['suppliers'])
          this.suppliers!.push(SupplierApprovalRequestSupplierDto.fromJS(item));
      }
      this.notes = _data['notes'];
    }
  }

  static fromJS(data: any): ChangeSupplierApprovalRequestStatusDto {
    data = typeof data === 'object' ? data : {};
    let result = new ChangeSupplierApprovalRequestStatusDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.suppliers)) {
      data['suppliers'] = [];
      for (let item of this.suppliers) data['suppliers'].push(item.toJSON());
    }
    data['notes'] = this.notes;
    return data;
  }
}

export interface IChangeSupplierApprovalRequestStatusDto {
  suppliers?: SupplierApprovalRequestSupplierDto[] | undefined;
  notes?: string | undefined;
}

export class SupplierApprovalRequestSupplierDto
  implements ISupplierApprovalRequestSupplierDto
{
  supplierId?: string | undefined;
  price?: number;
  selected?: boolean;
  attachments?: UploadAttachmentDto[] | undefined;

  constructor(data?: ISupplierApprovalRequestSupplierDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.supplierId = _data['supplierId'];
      this.price = _data['price'];
      this.selected = _data['selected'];
      if (Array.isArray(_data['attachments'])) {
        this.attachments = [] as any;
        for (let item of _data['attachments'])
          this.attachments!.push(UploadAttachmentDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): SupplierApprovalRequestSupplierDto {
    data = typeof data === 'object' ? data : {};
    let result = new SupplierApprovalRequestSupplierDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['supplierId'] = this.supplierId;
    data['price'] = this.price;
    data['selected'] = this.selected;
    if (Array.isArray(this.attachments)) {
      data['attachments'] = [];
      for (let item of this.attachments) data['attachments'].push(item.toJSON());
    }
    return data;
  }
}

export interface ISupplierApprovalRequestSupplierDto {
  supplierId?: string | undefined;
  price?: number;
  selected?: boolean;
  attachments?: UploadAttachmentDto[] | undefined;
}

export class PaginatedListOfSupplierPageVm implements IPaginatedListOfSupplierPageVm {
  pageInfo?: PageInfo | undefined;
  items?: SupplierPageVm[] | undefined;

  constructor(data?: IPaginatedListOfSupplierPageVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(SupplierPageVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfSupplierPageVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfSupplierPageVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfSupplierPageVm {
  pageInfo?: PageInfo | undefined;
  items?: SupplierPageVm[] | undefined;
}

export class SupplierPageVm implements ISupplierPageVm {
  id?: string | undefined;
  name?: string | undefined;
  bankId?: string | undefined;
  bankName?: string | undefined;
  serviceType?: ServiceType;
  supplierType?: SupplierType;
  paymentOption?: PaymentOption;
  identifierNumber?: string | undefined;
  iban?: string | undefined;
  isActive?: boolean;
  phone1?: string | undefined;
  phone2?: string | undefined;

  constructor(data?: ISupplierPageVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.bankId = _data['bankId'];
      this.bankName = _data['bankName'];
      this.serviceType = _data['serviceType'];
      this.supplierType = _data['supplierType'];
      this.paymentOption = _data['paymentOption'];
      this.identifierNumber = _data['identifierNumber'];
      this.iban = _data['iban'];
      this.isActive = _data['isActive'];
      this.phone1 = _data['phone1'];
      this.phone2 = _data['phone2'];
    }
  }

  static fromJS(data: any): SupplierPageVm {
    data = typeof data === 'object' ? data : {};
    let result = new SupplierPageVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['bankId'] = this.bankId;
    data['bankName'] = this.bankName;
    data['serviceType'] = this.serviceType;
    data['supplierType'] = this.supplierType;
    data['paymentOption'] = this.paymentOption;
    data['identifierNumber'] = this.identifierNumber;
    data['iban'] = this.iban;
    data['isActive'] = this.isActive;
    data['phone1'] = this.phone1;
    data['phone2'] = this.phone2;
    return data;
  }
}

export interface ISupplierPageVm {
  id?: string | undefined;
  name?: string | undefined;
  bankId?: string | undefined;
  bankName?: string | undefined;
  serviceType?: ServiceType;
  supplierType?: SupplierType;
  paymentOption?: PaymentOption;
  identifierNumber?: string | undefined;
  iban?: string | undefined;
  isActive?: boolean;
  phone1?: string | undefined;
  phone2?: string | undefined;
}

export enum ServiceType {
  Supply = 0,
  Installation = 1,
  InstallationAndSupply = 2,
}

export enum SupplierType {
  Individual = 0,
  Company = 1,
}

export enum PaymentOption {
  BankTransfer = 0,
  Cash = 1,
}

export class SupplierDetailsVm implements ISupplierDetailsVm {
  id?: string | undefined;
  name?: string | undefined;
  address?: string | undefined;
  supplierType?: SupplierType;
  serviceType?: ServiceType;
  businessType?: BusinessType;
  paymentOption?: PaymentOption;
  identifierNumber?: string | undefined;
  phone1?: string | undefined;
  phone2?: string | undefined;
  mail?: string | undefined;
  iban?: string | undefined;
  bankId?: string | undefined;
  bankName?: string | undefined;
  isActive?: boolean;

  constructor(data?: ISupplierDetailsVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.name = _data['name'];
      this.address = _data['address'];
      this.supplierType = _data['supplierType'];
      this.serviceType = _data['serviceType'];
      this.businessType = _data['businessType'];
      this.paymentOption = _data['paymentOption'];
      this.identifierNumber = _data['identifierNumber'];
      this.phone1 = _data['phone1'];
      this.phone2 = _data['phone2'];
      this.mail = _data['mail'];
      this.iban = _data['iban'];
      this.bankId = _data['bankId'];
      this.bankName = _data['bankName'];
      this.isActive = _data['isActive'];
    }
  }

  static fromJS(data: any): SupplierDetailsVm {
    data = typeof data === 'object' ? data : {};
    let result = new SupplierDetailsVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['name'] = this.name;
    data['address'] = this.address;
    data['supplierType'] = this.supplierType;
    data['serviceType'] = this.serviceType;
    data['businessType'] = this.businessType;
    data['paymentOption'] = this.paymentOption;
    data['identifierNumber'] = this.identifierNumber;
    data['phone1'] = this.phone1;
    data['phone2'] = this.phone2;
    data['mail'] = this.mail;
    data['iban'] = this.iban;
    data['bankId'] = this.bankId;
    data['bankName'] = this.bankName;
    data['isActive'] = this.isActive;
    return data;
  }
}

export interface ISupplierDetailsVm {
  id?: string | undefined;
  name?: string | undefined;
  address?: string | undefined;
  supplierType?: SupplierType;
  serviceType?: ServiceType;
  businessType?: BusinessType;
  paymentOption?: PaymentOption;
  identifierNumber?: string | undefined;
  phone1?: string | undefined;
  phone2?: string | undefined;
  mail?: string | undefined;
  iban?: string | undefined;
  bankId?: string | undefined;
  bankName?: string | undefined;
  isActive?: boolean;
}

export class SupplierDto implements ISupplierDto {
  name?: string | undefined;
  address?: string | undefined;
  supplierType?: SupplierType;
  serviceType?: ServiceType;
  businessType?: BusinessType;
  paymentOption?: PaymentOption;
  identifierNumber?: string | undefined;
  phone1?: string | undefined;
  phone2?: string | undefined;
  mail?: string | undefined;
  iban?: string | undefined;
  bankId?: string | undefined;
  isActive?: boolean | undefined;

  constructor(data?: ISupplierDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.address = _data['address'];
      this.supplierType = _data['supplierType'];
      this.serviceType = _data['serviceType'];
      this.businessType = _data['businessType'];
      this.paymentOption = _data['paymentOption'];
      this.identifierNumber = _data['identifierNumber'];
      this.phone1 = _data['phone1'];
      this.phone2 = _data['phone2'];
      this.mail = _data['mail'];
      this.iban = _data['iban'];
      this.bankId = _data['bankId'];
      this.isActive = _data['isActive'];
    }
  }

  static fromJS(data: any): SupplierDto {
    data = typeof data === 'object' ? data : {};
    let result = new SupplierDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['address'] = this.address;
    data['supplierType'] = this.supplierType;
    data['serviceType'] = this.serviceType;
    data['businessType'] = this.businessType;
    data['paymentOption'] = this.paymentOption;
    data['identifierNumber'] = this.identifierNumber;
    data['phone1'] = this.phone1;
    data['phone2'] = this.phone2;
    data['mail'] = this.mail;
    data['iban'] = this.iban;
    data['bankId'] = this.bankId;
    data['isActive'] = this.isActive;
    return data;
  }
}

export interface ISupplierDto {
  name?: string | undefined;
  address?: string | undefined;
  supplierType?: SupplierType;
  serviceType?: ServiceType;
  businessType?: BusinessType;
  paymentOption?: PaymentOption;
  identifierNumber?: string | undefined;
  phone1?: string | undefined;
  phone2?: string | undefined;
  mail?: string | undefined;
  iban?: string | undefined;
  bankId?: string | undefined;
  isActive?: boolean | undefined;
}

export class PaginatedListOfSupplyApprovalRequestVm
  implements IPaginatedListOfSupplyApprovalRequestVm
{
  pageInfo?: PageInfo | undefined;
  items?: SupplyApprovalRequestVm[] | undefined;

  constructor(data?: IPaginatedListOfSupplyApprovalRequestVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items'])
          this.items!.push(SupplyApprovalRequestVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfSupplyApprovalRequestVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfSupplyApprovalRequestVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfSupplyApprovalRequestVm {
  pageInfo?: PageInfo | undefined;
  items?: SupplyApprovalRequestVm[] | undefined;
}

export class SupplyApprovalRequestVm implements ISupplyApprovalRequestVm {
  id?: string | undefined;
  termId?: string | undefined;
  termTitle?: string | undefined;
  status?: SupplyApprovalRequestStatus;

  constructor(data?: ISupplyApprovalRequestVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.termId = _data['termId'];
      this.termTitle = _data['termTitle'];
      this.status = _data['status'];
    }
  }

  static fromJS(data: any): SupplyApprovalRequestVm {
    data = typeof data === 'object' ? data : {};
    let result = new SupplyApprovalRequestVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['termId'] = this.termId;
    data['termTitle'] = this.termTitle;
    data['status'] = this.status;
    return data;
  }
}

export interface ISupplyApprovalRequestVm {
  id?: string | undefined;
  termId?: string | undefined;
  termTitle?: string | undefined;
  status?: SupplyApprovalRequestStatus;
}

export enum SupplyApprovalRequestStatus {
  Created = 0,
  Rejected = 1,
  Approved = 2,
  Transferred = 3,
  Completed = 4,
}

export class SupplyApprovalRequestDetailsVm implements ISupplyApprovalRequestDetailsVm {
  id?: string | undefined;
  requestNumber?: number;
  description?: string | undefined;
  measurementUnitId?: string | undefined;
  termId?: string | undefined;
  quantity?: number;
  unitPrice?: number;
  vat?: number;
  total?: number;
  totalWithVat?: number;
  notes?: string | undefined;
  projectId?: string | undefined;
  createdAt?: Date;
  createdBy?: string | undefined;
  attachments?: FileAttachmentDto[] | undefined;
  term?: ProjectQuantityMainDataVm | undefined;
  measurementUnit?: MeasurementUnitVm | undefined;
  status?: SupplyApprovalRequestStatusVm;
  phase?: SupplyApprovalRequestPhaseVm;
  creatorName?: string | undefined;
  history?: SupplyApprovalRequestStatusLogVm[] | undefined;
  suppliers?: SupplyApprovalRequestSupplierVm[] | undefined;
  transactionReqeusts?: SupplyApprovalRequestTransactionReqeustVm[] | undefined;

  constructor(data?: ISupplyApprovalRequestDetailsVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.requestNumber = _data['requestNumber'];
      this.description = _data['description'];
      this.measurementUnitId = _data['measurementUnitId'];
      this.termId = _data['termId'];
      this.quantity = _data['quantity'];
      this.unitPrice = _data['unitPrice'];
      this.vat = _data['vat'];
      this.total = _data['total'];
      this.totalWithVat = _data['totalWithVat'];
      this.notes = _data['notes'];
      this.projectId = _data['projectId'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : <any>undefined;
      this.createdBy = _data['createdBy'];
      if (Array.isArray(_data['attachments'])) {
        this.attachments = [] as any;
        for (let item of _data['attachments'])
          this.attachments!.push(FileAttachmentDto.fromJS(item));
      }
      this.term = _data['term']
        ? ProjectQuantityMainDataVm.fromJS(_data['term'])
        : <any>undefined;
      this.measurementUnit = _data['measurementUnit']
        ? MeasurementUnitVm.fromJS(_data['measurementUnit'])
        : <any>undefined;
      this.status = _data['status'];
      this.phase = _data['phase'];
      this.creatorName = _data['creatorName'];
      if (Array.isArray(_data['history'])) {
        this.history = [] as any;
        for (let item of _data['history'])
          this.history!.push(SupplyApprovalRequestStatusLogVm.fromJS(item));
      }
      if (Array.isArray(_data['suppliers'])) {
        this.suppliers = [] as any;
        for (let item of _data['suppliers'])
          this.suppliers!.push(SupplyApprovalRequestSupplierVm.fromJS(item));
      }
      if (Array.isArray(_data['transactionReqeusts'])) {
        this.transactionReqeusts = [] as any;
        for (let item of _data['transactionReqeusts'])
          this.transactionReqeusts!.push(
            SupplyApprovalRequestTransactionReqeustVm.fromJS(item)
          );
      }
    }
  }

  static fromJS(data: any): SupplyApprovalRequestDetailsVm {
    data = typeof data === 'object' ? data : {};
    let result = new SupplyApprovalRequestDetailsVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['requestNumber'] = this.requestNumber;
    data['description'] = this.description;
    data['measurementUnitId'] = this.measurementUnitId;
    data['termId'] = this.termId;
    data['quantity'] = this.quantity;
    data['unitPrice'] = this.unitPrice;
    data['vat'] = this.vat;
    data['total'] = this.total;
    data['totalWithVat'] = this.totalWithVat;
    data['notes'] = this.notes;
    data['projectId'] = this.projectId;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
    data['createdBy'] = this.createdBy;
    if (Array.isArray(this.attachments)) {
      data['attachments'] = [];
      for (let item of this.attachments) data['attachments'].push(item.toJSON());
    }
    data['term'] = this.term ? this.term.toJSON() : <any>undefined;
    data['measurementUnit'] = this.measurementUnit
      ? this.measurementUnit.toJSON()
      : <any>undefined;
    data['status'] = this.status;
    data['phase'] = this.phase;
    data['creatorName'] = this.creatorName;
    if (Array.isArray(this.history)) {
      data['history'] = [];
      for (let item of this.history) data['history'].push(item.toJSON());
    }
    if (Array.isArray(this.suppliers)) {
      data['suppliers'] = [];
      for (let item of this.suppliers) data['suppliers'].push(item.toJSON());
    }
    if (Array.isArray(this.transactionReqeusts)) {
      data['transactionReqeusts'] = [];
      for (let item of this.transactionReqeusts)
        data['transactionReqeusts'].push(item.toJSON());
    }
    return data;
  }
}

export interface ISupplyApprovalRequestDetailsVm {
  id?: string | undefined;
  requestNumber?: number;
  description?: string | undefined;
  measurementUnitId?: string | undefined;
  termId?: string | undefined;
  quantity?: number;
  unitPrice?: number;
  vat?: number;
  total?: number;
  totalWithVat?: number;
  notes?: string | undefined;
  projectId?: string | undefined;
  createdAt?: Date;
  createdBy?: string | undefined;
  attachments?: FileAttachmentDto[] | undefined;
  term?: ProjectQuantityMainDataVm | undefined;
  measurementUnit?: MeasurementUnitVm | undefined;
  status?: SupplyApprovalRequestStatusVm;
  phase?: SupplyApprovalRequestPhaseVm;
  creatorName?: string | undefined;
  history?: SupplyApprovalRequestStatusLogVm[] | undefined;
  suppliers?: SupplyApprovalRequestSupplierVm[] | undefined;
  transactionReqeusts?: SupplyApprovalRequestTransactionReqeustVm[] | undefined;
}

export enum SupplyApprovalRequestStatusVm {
  Pending = 0,
  Rejected = 1,
  Approved = 2,
}

export enum SupplyApprovalRequestPhaseVm {
  ProjectManagerReview = 0,
  TechnicalOfficeReview = 1,
  ProjectsManagerReview = 2,
  GeneralManagerReview = 3,
  Accountant = 4,
  Completed = 5,
}

export class SupplyApprovalRequestStatusLogVm
  implements ISupplyApprovalRequestStatusLogVm
{
  id?: string | undefined;
  supplyRequestId?: string | undefined;
  status?: SupplyApprovalRequestStatus;
  phase?: SupplyApprovalRequestPhase;
  actor?: SupplyApprovalRequestActor;
  notes?: string | undefined;
  createdAt?: Date;
  attachments?: FileAttachmentDto[] | undefined;

  constructor(data?: ISupplyApprovalRequestStatusLogVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.supplyRequestId = _data['supplyRequestId'];
      this.status = _data['status'];
      this.phase = _data['phase'];
      this.actor = _data['actor'];
      this.notes = _data['notes'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : <any>undefined;
      if (Array.isArray(_data['attachments'])) {
        this.attachments = [] as any;
        for (let item of _data['attachments'])
          this.attachments!.push(FileAttachmentDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): SupplyApprovalRequestStatusLogVm {
    data = typeof data === 'object' ? data : {};
    let result = new SupplyApprovalRequestStatusLogVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['supplyRequestId'] = this.supplyRequestId;
    data['status'] = this.status;
    data['phase'] = this.phase;
    data['actor'] = this.actor;
    data['notes'] = this.notes;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
    if (Array.isArray(this.attachments)) {
      data['attachments'] = [];
      for (let item of this.attachments) data['attachments'].push(item.toJSON());
    }
    return data;
  }
}

export interface ISupplyApprovalRequestStatusLogVm {
  id?: string | undefined;
  supplyRequestId?: string | undefined;
  status?: SupplyApprovalRequestStatus;
  phase?: SupplyApprovalRequestPhase;
  actor?: SupplyApprovalRequestActor;
  notes?: string | undefined;
  createdAt?: Date;
  attachments?: FileAttachmentDto[] | undefined;
}

export enum SupplyApprovalRequestPhase {
  ProjectManagerReview = 0,
  TechnicalOfficeReview = 1,
  ProjectsManagerReview = 2,
  GeneralManagerReview = 3,
  Accountant = 4,
  Completed = 5,
}

export enum SupplyApprovalRequestActor {
  SiteEngineer = 0,
  ProjectManager = 1,
  TechnicalOffice = 2,
  ProjectsManager = 3,
  Accountant = 4,
  GeneralManager = 5,
}

export class SupplyApprovalRequestSupplierVm implements ISupplyApprovalRequestSupplierVm {
  supplierId?: string | undefined;
  supplierName?: string | undefined;
  selected?: boolean;
  attachments?: FileAttachmentDto[] | undefined;

  constructor(data?: ISupplyApprovalRequestSupplierVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.supplierId = _data['supplierId'];
      this.supplierName = _data['supplierName'];
      this.selected = _data['selected'];
      if (Array.isArray(_data['attachments'])) {
        this.attachments = [] as any;
        for (let item of _data['attachments'])
          this.attachments!.push(FileAttachmentDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): SupplyApprovalRequestSupplierVm {
    data = typeof data === 'object' ? data : {};
    let result = new SupplyApprovalRequestSupplierVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['supplierId'] = this.supplierId;
    data['supplierName'] = this.supplierName;
    data['selected'] = this.selected;
    if (Array.isArray(this.attachments)) {
      data['attachments'] = [];
      for (let item of this.attachments) data['attachments'].push(item.toJSON());
    }
    return data;
  }
}

export interface ISupplyApprovalRequestSupplierVm {
  supplierId?: string | undefined;
  supplierName?: string | undefined;
  selected?: boolean;
  attachments?: FileAttachmentDto[] | undefined;
}

export class SupplyApprovalRequestTransactionReqeustVm
  implements ISupplyApprovalRequestTransactionReqeustVm
{
  supplyApprovalRequestId?: string | undefined;
  supplierId?: string | undefined;
  supplierName?: string | undefined;
  amount?: number;
  remaining?: number;
  date?: Date;
  order?: number;

  constructor(data?: ISupplyApprovalRequestTransactionReqeustVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.supplyApprovalRequestId = _data['supplyApprovalRequestId'];
      this.supplierId = _data['supplierId'];
      this.supplierName = _data['supplierName'];
      this.amount = _data['amount'];
      this.remaining = _data['remaining'];
      this.date = _data['date'] ? new Date(_data['date'].toString()) : <any>undefined;
      this.order = _data['order'];
    }
  }

  static fromJS(data: any): SupplyApprovalRequestTransactionReqeustVm {
    data = typeof data === 'object' ? data : {};
    let result = new SupplyApprovalRequestTransactionReqeustVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['supplyApprovalRequestId'] = this.supplyApprovalRequestId;
    data['supplierId'] = this.supplierId;
    data['supplierName'] = this.supplierName;
    data['amount'] = this.amount;
    data['remaining'] = this.remaining;
    data['date'] = this.date ? this.date.toISOString() : <any>undefined;
    data['order'] = this.order;
    return data;
  }
}

export interface ISupplyApprovalRequestTransactionReqeustVm {
  supplyApprovalRequestId?: string | undefined;
  supplierId?: string | undefined;
  supplierName?: string | undefined;
  amount?: number;
  remaining?: number;
  date?: Date;
  order?: number;
}

export class PaginatedListOfSupplyApprovalRequestDetailsVm
  implements IPaginatedListOfSupplyApprovalRequestDetailsVm
{
  pageInfo?: PageInfo | undefined;
  items?: SupplyApprovalRequestDetailsVm[] | undefined;

  constructor(data?: IPaginatedListOfSupplyApprovalRequestDetailsVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items'])
          this.items!.push(SupplyApprovalRequestDetailsVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfSupplyApprovalRequestDetailsVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfSupplyApprovalRequestDetailsVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfSupplyApprovalRequestDetailsVm {
  pageInfo?: PageInfo | undefined;
  items?: SupplyApprovalRequestDetailsVm[] | undefined;
}

export class SupplyApprovalRequestDto implements ISupplyApprovalRequestDto {
  projectId?: string | undefined;
  termId?: string | undefined;
  supplierId?: string | undefined;
  description?: string | undefined;
  measurementUnitId?: string | undefined;
  quantity?: number;
  unitPrice?: number;
  vat?: number;
  notes?: string | undefined;
  attachments?: UploadAttachmentDto[] | undefined;

  constructor(data?: ISupplyApprovalRequestDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.projectId = _data['projectId'];
      this.termId = _data['termId'];
      this.supplierId = _data['supplierId'];
      this.description = _data['description'];
      this.measurementUnitId = _data['measurementUnitId'];
      this.quantity = _data['quantity'];
      this.unitPrice = _data['unitPrice'];
      this.vat = _data['vat'];
      this.notes = _data['notes'];
      if (Array.isArray(_data['attachments'])) {
        this.attachments = [] as any;
        for (let item of _data['attachments'])
          this.attachments!.push(UploadAttachmentDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): SupplyApprovalRequestDto {
    data = typeof data === 'object' ? data : {};
    let result = new SupplyApprovalRequestDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['projectId'] = this.projectId;
    data['termId'] = this.termId;
    data['supplierId'] = this.supplierId;
    data['description'] = this.description;
    data['measurementUnitId'] = this.measurementUnitId;
    data['quantity'] = this.quantity;
    data['unitPrice'] = this.unitPrice;
    data['vat'] = this.vat;
    data['notes'] = this.notes;
    if (Array.isArray(this.attachments)) {
      data['attachments'] = [];
      for (let item of this.attachments) data['attachments'].push(item.toJSON());
    }
    return data;
  }
}

export interface ISupplyApprovalRequestDto {
  projectId?: string | undefined;
  termId?: string | undefined;
  supplierId?: string | undefined;
  description?: string | undefined;
  measurementUnitId?: string | undefined;
  quantity?: number;
  unitPrice?: number;
  vat?: number;
  notes?: string | undefined;
  attachments?: UploadAttachmentDto[] | undefined;
}

export class ChangeSupplyApprovalRequestStatusDto
  implements IChangeSupplyApprovalRequestStatusDto
{
  notes?: string | undefined;
  attachments?: UploadAttachmentDto[] | undefined;

  constructor(data?: IChangeSupplyApprovalRequestStatusDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.notes = _data['notes'];
      if (Array.isArray(_data['attachments'])) {
        this.attachments = [] as any;
        for (let item of _data['attachments'])
          this.attachments!.push(UploadAttachmentDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): ChangeSupplyApprovalRequestStatusDto {
    data = typeof data === 'object' ? data : {};
    let result = new ChangeSupplyApprovalRequestStatusDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['notes'] = this.notes;
    if (Array.isArray(this.attachments)) {
      data['attachments'] = [];
      for (let item of this.attachments) data['attachments'].push(item.toJSON());
    }
    return data;
  }
}

export interface IChangeSupplyApprovalRequestStatusDto {
  notes?: string | undefined;
  attachments?: UploadAttachmentDto[] | undefined;
}

export class SupplyApprovalRequestTransactionReqeustsDto
  implements ISupplyApprovalRequestTransactionReqeustsDto
{
  supplyApprovalRequestId?: string | undefined;
  transactionRequests?: SupplyApprovalRequestTransactionRequestDto[] | undefined;

  constructor(data?: ISupplyApprovalRequestTransactionReqeustsDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.supplyApprovalRequestId = _data['supplyApprovalRequestId'];
      if (Array.isArray(_data['transactionRequests'])) {
        this.transactionRequests = [] as any;
        for (let item of _data['transactionRequests'])
          this.transactionRequests!.push(
            SupplyApprovalRequestTransactionRequestDto.fromJS(item)
          );
      }
    }
  }

  static fromJS(data: any): SupplyApprovalRequestTransactionReqeustsDto {
    data = typeof data === 'object' ? data : {};
    let result = new SupplyApprovalRequestTransactionReqeustsDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['supplyApprovalRequestId'] = this.supplyApprovalRequestId;
    if (Array.isArray(this.transactionRequests)) {
      data['transactionRequests'] = [];
      for (let item of this.transactionRequests)
        data['transactionRequests'].push(item.toJSON());
    }
    return data;
  }
}

export interface ISupplyApprovalRequestTransactionReqeustsDto {
  supplyApprovalRequestId?: string | undefined;
  transactionRequests?: SupplyApprovalRequestTransactionRequestDto[] | undefined;
}

export class SupplyApprovalRequestTransactionRequestDto
  implements ISupplyApprovalRequestTransactionRequestDto
{
  supplierId?: string | undefined;
  date?: Date;
  amount?: number;

  constructor(data?: ISupplyApprovalRequestTransactionRequestDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.supplierId = _data['supplierId'];
      this.date = _data['date'] ? new Date(_data['date'].toString()) : <any>undefined;
      this.amount = _data['amount'];
    }
  }

  static fromJS(data: any): SupplyApprovalRequestTransactionRequestDto {
    data = typeof data === 'object' ? data : {};
    let result = new SupplyApprovalRequestTransactionRequestDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['supplierId'] = this.supplierId;
    data['date'] = this.date ? this.date.toISOString() : <any>undefined;
    data['amount'] = this.amount;
    return data;
  }
}

export interface ISupplyApprovalRequestTransactionRequestDto {
  supplierId?: string | undefined;
  date?: Date;
  amount?: number;
}

export class PaginatedListOfSupplyRequestVm implements IPaginatedListOfSupplyRequestVm {
  pageInfo?: PageInfo | undefined;
  items?: SupplyRequestVm[] | undefined;

  constructor(data?: IPaginatedListOfSupplyRequestVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(SupplyRequestVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfSupplyRequestVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfSupplyRequestVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfSupplyRequestVm {
  pageInfo?: PageInfo | undefined;
  items?: SupplyRequestVm[] | undefined;
}

export class SupplyRequestVm implements ISupplyRequestVm {
  id?: string | undefined;
  serialNumber?: number;
  name?: string | undefined;
  project?: string | undefined;
  status?: SupplyRequestStatus;
  phase?: SupplyRequestPhase;
  createdBy?: string | undefined;
  createdAt?: Date;
  lastModifiedBy?: string | undefined;
  lastModifiedAt?: Date | undefined;

  constructor(data?: ISupplyRequestVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.serialNumber = _data['serialNumber'];
      this.name = _data['name'];
      this.project = _data['project'];
      this.status = _data['status'];
      this.phase = _data['phase'];
      this.createdBy = _data['createdBy'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : <any>undefined;
      this.lastModifiedBy = _data['lastModifiedBy'];
      this.lastModifiedAt = _data['lastModifiedAt']
        ? new Date(_data['lastModifiedAt'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): SupplyRequestVm {
    data = typeof data === 'object' ? data : {};
    let result = new SupplyRequestVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['serialNumber'] = this.serialNumber;
    data['name'] = this.name;
    data['project'] = this.project;
    data['status'] = this.status;
    data['phase'] = this.phase;
    data['createdBy'] = this.createdBy;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
    data['lastModifiedBy'] = this.lastModifiedBy;
    data['lastModifiedAt'] = this.lastModifiedAt
      ? this.lastModifiedAt.toISOString()
      : <any>undefined;
    return data;
  }
}

export interface ISupplyRequestVm {
  id?: string | undefined;
  serialNumber?: number;
  name?: string | undefined;
  project?: string | undefined;
  status?: SupplyRequestStatus;
  phase?: SupplyRequestPhase;
  createdBy?: string | undefined;
  createdAt?: Date;
  lastModifiedBy?: string | undefined;
  lastModifiedAt?: Date | undefined;
}

export enum SupplyRequestStatus {
  Created = 0,
  Updated = 1,
  Rejected = 2,
  Accepted = 3,
}

export enum SupplyRequestPhase {
  Creation = 0,
  Purchasing = 1,
  Completed = 2,
}

export class SupplyRequestDetailsVm
  extends SupplyRequestVm
  implements ISupplyRequestDetailsVm
{
  totalPrice?: number;
  items?: SupplyRequestItemVm[] | undefined;
  suppliers?: string[] | undefined;
  history?: SupplyRequestStatusLogVm[] | undefined;

  constructor(data?: ISupplyRequestDetailsVm) {
    super(data);
  }

  override init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.totalPrice = _data['totalPrice'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items'])
          this.items!.push(SupplyRequestItemVm.fromJS(item));
      }
      if (Array.isArray(_data['suppliers'])) {
        this.suppliers = [] as any;
        for (let item of _data['suppliers']) this.suppliers!.push(item);
      }
      if (Array.isArray(_data['history'])) {
        this.history = [] as any;
        for (let item of _data['history'])
          this.history!.push(SupplyRequestStatusLogVm.fromJS(item));
      }
    }
  }

  static override fromJS(data: any): SupplyRequestDetailsVm {
    data = typeof data === 'object' ? data : {};
    let result = new SupplyRequestDetailsVm();
    result.init(data);
    return result;
  }

  override toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['totalPrice'] = this.totalPrice;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    if (Array.isArray(this.suppliers)) {
      data['suppliers'] = [];
      for (let item of this.suppliers) data['suppliers'].push(item);
    }
    if (Array.isArray(this.history)) {
      data['history'] = [];
      for (let item of this.history) data['history'].push(item.toJSON());
    }
    super.toJSON(data);
    return data;
  }
}

export interface ISupplyRequestDetailsVm extends ISupplyRequestVm {
  totalPrice?: number;
  items?: SupplyRequestItemVm[] | undefined;
  suppliers?: string[] | undefined;
  history?: SupplyRequestStatusLogVm[] | undefined;
}

export class SupplyRequestItemVm implements ISupplyRequestItemVm {
  id?: string | undefined;
  termName?: string | undefined;
  measurementUnitId?: string | undefined;
  quantity?: number;
  unitPrice?: number;
  totalPrice?: number;
  notes?: string | undefined;

  constructor(data?: ISupplyRequestItemVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.termName = _data['termName'];
      this.measurementUnitId = _data['measurementUnitId'];
      this.quantity = _data['quantity'];
      this.unitPrice = _data['unitPrice'];
      this.totalPrice = _data['totalPrice'];
      this.notes = _data['notes'];
    }
  }

  static fromJS(data: any): SupplyRequestItemVm {
    data = typeof data === 'object' ? data : {};
    let result = new SupplyRequestItemVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['termName'] = this.termName;
    data['measurementUnitId'] = this.measurementUnitId;
    data['quantity'] = this.quantity;
    data['unitPrice'] = this.unitPrice;
    data['totalPrice'] = this.totalPrice;
    data['notes'] = this.notes;
    return data;
  }
}

export interface ISupplyRequestItemVm {
  id?: string | undefined;
  termName?: string | undefined;
  measurementUnitId?: string | undefined;
  quantity?: number;
  unitPrice?: number;
  totalPrice?: number;
  notes?: string | undefined;
}

export class SupplyRequestStatusLogVm implements ISupplyRequestStatusLogVm {
  id?: string | undefined;
  status?: SupplyRequestStatus;
  phase?: SupplyRequestPhase;
  notes?: string | undefined;
  attachment?: string | undefined;

  constructor(data?: ISupplyRequestStatusLogVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.status = _data['status'];
      this.phase = _data['phase'];
      this.notes = _data['notes'];
      this.attachment = _data['attachment'];
    }
  }

  static fromJS(data: any): SupplyRequestStatusLogVm {
    data = typeof data === 'object' ? data : {};
    let result = new SupplyRequestStatusLogVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['status'] = this.status;
    data['phase'] = this.phase;
    data['notes'] = this.notes;
    data['attachment'] = this.attachment;
    return data;
  }
}

export interface ISupplyRequestStatusLogVm {
  id?: string | undefined;
  status?: SupplyRequestStatus;
  phase?: SupplyRequestPhase;
  notes?: string | undefined;
  attachment?: string | undefined;
}

export class SupplyRequestDto implements ISupplyRequestDto {
  name?: string | undefined;
  projectId?: string | undefined;
  items?: SupplyRequestItemDto[] | undefined;

  constructor(data?: ISupplyRequestDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.projectId = _data['projectId'];
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items'])
          this.items!.push(SupplyRequestItemDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): SupplyRequestDto {
    data = typeof data === 'object' ? data : {};
    let result = new SupplyRequestDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['projectId'] = this.projectId;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface ISupplyRequestDto {
  name?: string | undefined;
  projectId?: string | undefined;
  items?: SupplyRequestItemDto[] | undefined;
}

export class SupplyRequestItemDto implements ISupplyRequestItemDto {
  id?: string | undefined;
  termName?: string | undefined;
  measurementUnitId?: string | undefined;
  quantity?: number;
  unitPrice?: number;
  notes?: string | undefined;

  constructor(data?: ISupplyRequestItemDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.termName = _data['termName'];
      this.measurementUnitId = _data['measurementUnitId'];
      this.quantity = _data['quantity'];
      this.unitPrice = _data['unitPrice'];
      this.notes = _data['notes'];
    }
  }

  static fromJS(data: any): SupplyRequestItemDto {
    data = typeof data === 'object' ? data : {};
    let result = new SupplyRequestItemDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['termName'] = this.termName;
    data['measurementUnitId'] = this.measurementUnitId;
    data['quantity'] = this.quantity;
    data['unitPrice'] = this.unitPrice;
    data['notes'] = this.notes;
    return data;
  }
}

export interface ISupplyRequestItemDto {
  id?: string | undefined;
  termName?: string | undefined;
  measurementUnitId?: string | undefined;
  quantity?: number;
  unitPrice?: number;
  notes?: string | undefined;
}

export class ChangeSupplyRequestStatusDto implements IChangeSupplyRequestStatusDto {
  attachment?: string | undefined;
  suppliers?: string[] | undefined;
  notes?: string | undefined;

  constructor(data?: IChangeSupplyRequestStatusDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.attachment = _data['attachment'];
      if (Array.isArray(_data['suppliers'])) {
        this.suppliers = [] as any;
        for (let item of _data['suppliers']) this.suppliers!.push(item);
      }
      this.notes = _data['notes'];
    }
  }

  static fromJS(data: any): ChangeSupplyRequestStatusDto {
    data = typeof data === 'object' ? data : {};
    let result = new ChangeSupplyRequestStatusDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['attachment'] = this.attachment;
    if (Array.isArray(this.suppliers)) {
      data['suppliers'] = [];
      for (let item of this.suppliers) data['suppliers'].push(item);
    }
    data['notes'] = this.notes;
    return data;
  }
}

export interface IChangeSupplyRequestStatusDto {
  attachment?: string | undefined;
  suppliers?: string[] | undefined;
  notes?: string | undefined;
}

export class PaginatedListOfTenantDashboardVm
  implements IPaginatedListOfTenantDashboardVm
{
  pageInfo?: PageInfo | undefined;
  items?: TenantDashboardVm[] | undefined;

  constructor(data?: IPaginatedListOfTenantDashboardVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(TenantDashboardVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfTenantDashboardVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfTenantDashboardVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfTenantDashboardVm {
  pageInfo?: PageInfo | undefined;
  items?: TenantDashboardVm[] | undefined;
}

export class TenantDashboardVm implements ITenantDashboardVm {
  id?: string | undefined;
  identifier?: string | undefined;
  name?: string | undefined;
  logoUrl?: string | undefined;
  adminEmail?: string | undefined;
  status?: TenantStatus;
  validTo?: Date;

  constructor(data?: ITenantDashboardVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.identifier = _data['identifier'];
      this.name = _data['name'];
      this.logoUrl = _data['logoUrl'];
      this.adminEmail = _data['adminEmail'];
      this.status = _data['status'];
      this.validTo = _data['validTo']
        ? new Date(_data['validTo'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): TenantDashboardVm {
    data = typeof data === 'object' ? data : {};
    let result = new TenantDashboardVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['identifier'] = this.identifier;
    data['name'] = this.name;
    data['logoUrl'] = this.logoUrl;
    data['adminEmail'] = this.adminEmail;
    data['status'] = this.status;
    data['validTo'] = this.validTo ? this.validTo.toISOString() : <any>undefined;
    return data;
  }
}

export interface ITenantDashboardVm {
  id?: string | undefined;
  identifier?: string | undefined;
  name?: string | undefined;
  logoUrl?: string | undefined;
  adminEmail?: string | undefined;
  status?: TenantStatus;
  validTo?: Date;
}

export enum TenantStatus {
  Pending = 0,
  Ready = 1,
  Active = 2,
  Inactive = 3,
  Suspended = 4,
}

export class TenantDetailsVm implements ITenantDetailsVm {
  id?: string | undefined;
  identifier?: string | undefined;
  name?: LocalizedStringDto | undefined;
  connectionString?: string | undefined;
  mongoConnectionString?: string | undefined;
  adminEmail?: string | undefined;

  constructor(data?: ITenantDetailsVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.identifier = _data['identifier'];
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
      this.connectionString = _data['connectionString'];
      this.mongoConnectionString = _data['mongoConnectionString'];
      this.adminEmail = _data['adminEmail'];
    }
  }

  static fromJS(data: any): TenantDetailsVm {
    data = typeof data === 'object' ? data : {};
    let result = new TenantDetailsVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['identifier'] = this.identifier;
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    data['connectionString'] = this.connectionString;
    data['mongoConnectionString'] = this.mongoConnectionString;
    data['adminEmail'] = this.adminEmail;
    return data;
  }
}

export interface ITenantDetailsVm {
  id?: string | undefined;
  identifier?: string | undefined;
  name?: LocalizedStringDto | undefined;
  connectionString?: string | undefined;
  mongoConnectionString?: string | undefined;
  adminEmail?: string | undefined;
}

export class TestConnectionRequest implements ITestConnectionRequest {
  connectionString?: string | undefined;

  constructor(data?: ITestConnectionRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.connectionString = _data['connectionString'];
    }
  }

  static fromJS(data: any): TestConnectionRequest {
    data = typeof data === 'object' ? data : {};
    let result = new TestConnectionRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['connectionString'] = this.connectionString;
    return data;
  }
}

export interface ITestConnectionRequest {
  connectionString?: string | undefined;
}

export class TenantCreatedResponse implements ITenantCreatedResponse {
  tenantId?: string | undefined;
  identifier?: string | undefined;
  superAdminEmail?: string | undefined;
  superAdminPassword?: string | undefined;
  validTo?: Date;

  constructor(data?: ITenantCreatedResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenantId = _data['tenantId'];
      this.identifier = _data['identifier'];
      this.superAdminEmail = _data['superAdminEmail'];
      this.superAdminPassword = _data['superAdminPassword'];
      this.validTo = _data['validTo']
        ? new Date(_data['validTo'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): TenantCreatedResponse {
    data = typeof data === 'object' ? data : {};
    let result = new TenantCreatedResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tenantId'] = this.tenantId;
    data['identifier'] = this.identifier;
    data['superAdminEmail'] = this.superAdminEmail;
    data['superAdminPassword'] = this.superAdminPassword;
    data['validTo'] = this.validTo ? this.validTo.toISOString() : <any>undefined;
    return data;
  }
}

export interface ITenantCreatedResponse {
  tenantId?: string | undefined;
  identifier?: string | undefined;
  superAdminEmail?: string | undefined;
  superAdminPassword?: string | undefined;
  validTo?: Date;
}

export class TenantDto implements ITenantDto {
  name?: LocalizedStringDto | undefined;
  connectionString?: string | undefined;
  mongoConnectionString?: string | undefined;
  adminEmail?: string | undefined;

  constructor(data?: ITenantDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name']
        ? LocalizedStringDto.fromJS(_data['name'])
        : <any>undefined;
      this.connectionString = _data['connectionString'];
      this.mongoConnectionString = _data['mongoConnectionString'];
      this.adminEmail = _data['adminEmail'];
    }
  }

  static fromJS(data: any): TenantDto {
    data = typeof data === 'object' ? data : {};
    let result = new TenantDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name ? this.name.toJSON() : <any>undefined;
    data['connectionString'] = this.connectionString;
    data['mongoConnectionString'] = this.mongoConnectionString;
    data['adminEmail'] = this.adminEmail;
    return data;
  }
}

export interface ITenantDto {
  name?: LocalizedStringDto | undefined;
  connectionString?: string | undefined;
  mongoConnectionString?: string | undefined;
  adminEmail?: string | undefined;
}

export class TenantExtendSubscriptionDto implements ITenantExtendSubscriptionDto {
  tenantId?: string | undefined;
  months?: number;

  constructor(data?: ITenantExtendSubscriptionDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenantId = _data['tenantId'];
      this.months = _data['months'];
    }
  }

  static fromJS(data: any): TenantExtendSubscriptionDto {
    data = typeof data === 'object' ? data : {};
    let result = new TenantExtendSubscriptionDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tenantId'] = this.tenantId;
    data['months'] = this.months;
    return data;
  }
}

export interface ITenantExtendSubscriptionDto {
  tenantId?: string | undefined;
  months?: number;
}

export class PaginatedListOfTenderVm implements IPaginatedListOfTenderVm {
  pageInfo?: PageInfo | undefined;
  items?: TenderVm[] | undefined;

  constructor(data?: IPaginatedListOfTenderVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(TenderVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfTenderVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfTenderVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfTenderVm {
  pageInfo?: PageInfo | undefined;
  items?: TenderVm[] | undefined;
}

export class TenderVm implements ITenderVm {
  id?: string | undefined;
  referenceNumber?: string | undefined;
  name?: string | undefined;
  type?: string | undefined;
  typeId?: number;
  status?: string | undefined;
  purpose?: string | undefined;
  description?: string | undefined;
  agencyName?: string | undefined;
  bookletPrice?: number;
  lastEnquiriesDate?: Date | undefined;
  createDate?: Date;
  invitationCost?: number;
  awardingExpectedDate?: Date | undefined;
  startingBusinessDate?: Date | undefined;
  startingSendingEnquiriesDate?: Date | undefined;
  maxAnswerQuestionsTime?: number;
  remainingDays?: number;
  agreementType?: string | undefined;
  offers?: TenderOfferVm | undefined;
  cities?: TenderCityVm[] | undefined;
  areas?: TenderAreaVm[] | undefined;
  activities?: TenderActivityVm[] | undefined;
  applicants?: ApplicantDetailsVm[] | undefined;
  acceptedApplicants?: ApplicantDetailsVm[] | undefined;
  isInsideKsa?: boolean;
  isContainTawreedTables?: boolean;
  isIncludingInvitation?: boolean;

  constructor(data?: ITenderVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.referenceNumber = _data['referenceNumber'];
      this.name = _data['name'];
      this.type = _data['type'];
      this.typeId = _data['typeId'];
      this.status = _data['status'];
      this.purpose = _data['purpose'];
      this.description = _data['description'];
      this.agencyName = _data['agencyName'];
      this.bookletPrice = _data['bookletPrice'];
      this.lastEnquiriesDate = _data['lastEnquiriesDate']
        ? new Date(_data['lastEnquiriesDate'].toString())
        : <any>undefined;
      this.createDate = _data['createDate']
        ? new Date(_data['createDate'].toString())
        : <any>undefined;
      this.invitationCost = _data['invitationCost'];
      this.awardingExpectedDate = _data['awardingExpectedDate']
        ? new Date(_data['awardingExpectedDate'].toString())
        : <any>undefined;
      this.startingBusinessDate = _data['startingBusinessDate']
        ? new Date(_data['startingBusinessDate'].toString())
        : <any>undefined;
      this.startingSendingEnquiriesDate = _data['startingSendingEnquiriesDate']
        ? new Date(_data['startingSendingEnquiriesDate'].toString())
        : <any>undefined;
      this.maxAnswerQuestionsTime = _data['maxAnswerQuestionsTime'];
      this.remainingDays = _data['remainingDays'];
      this.agreementType = _data['agreementType'];
      this.offers = _data['offers']
        ? TenderOfferVm.fromJS(_data['offers'])
        : <any>undefined;
      if (Array.isArray(_data['cities'])) {
        this.cities = [] as any;
        for (let item of _data['cities']) this.cities!.push(TenderCityVm.fromJS(item));
      }
      if (Array.isArray(_data['areas'])) {
        this.areas = [] as any;
        for (let item of _data['areas']) this.areas!.push(TenderAreaVm.fromJS(item));
      }
      if (Array.isArray(_data['activities'])) {
        this.activities = [] as any;
        for (let item of _data['activities'])
          this.activities!.push(TenderActivityVm.fromJS(item));
      }
      if (Array.isArray(_data['applicants'])) {
        this.applicants = [] as any;
        for (let item of _data['applicants'])
          this.applicants!.push(ApplicantDetailsVm.fromJS(item));
      }
      if (Array.isArray(_data['acceptedApplicants'])) {
        this.acceptedApplicants = [] as any;
        for (let item of _data['acceptedApplicants'])
          this.acceptedApplicants!.push(ApplicantDetailsVm.fromJS(item));
      }
      this.isInsideKsa = _data['isInsideKsa'];
      this.isContainTawreedTables = _data['isContainTawreedTables'];
      this.isIncludingInvitation = _data['isIncludingInvitation'];
    }
  }

  static fromJS(data: any): TenderVm {
    data = typeof data === 'object' ? data : {};
    let result = new TenderVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['referenceNumber'] = this.referenceNumber;
    data['name'] = this.name;
    data['type'] = this.type;
    data['typeId'] = this.typeId;
    data['status'] = this.status;
    data['purpose'] = this.purpose;
    data['description'] = this.description;
    data['agencyName'] = this.agencyName;
    data['bookletPrice'] = this.bookletPrice;
    data['lastEnquiriesDate'] = this.lastEnquiriesDate
      ? this.lastEnquiriesDate.toISOString()
      : <any>undefined;
    data['createDate'] = this.createDate ? this.createDate.toISOString() : <any>undefined;
    data['invitationCost'] = this.invitationCost;
    data['awardingExpectedDate'] = this.awardingExpectedDate
      ? this.awardingExpectedDate.toISOString()
      : <any>undefined;
    data['startingBusinessDate'] = this.startingBusinessDate
      ? this.startingBusinessDate.toISOString()
      : <any>undefined;
    data['startingSendingEnquiriesDate'] = this.startingSendingEnquiriesDate
      ? this.startingSendingEnquiriesDate.toISOString()
      : <any>undefined;
    data['maxAnswerQuestionsTime'] = this.maxAnswerQuestionsTime;
    data['remainingDays'] = this.remainingDays;
    data['agreementType'] = this.agreementType;
    data['offers'] = this.offers ? this.offers.toJSON() : <any>undefined;
    if (Array.isArray(this.cities)) {
      data['cities'] = [];
      for (let item of this.cities) data['cities'].push(item.toJSON());
    }
    if (Array.isArray(this.areas)) {
      data['areas'] = [];
      for (let item of this.areas) data['areas'].push(item.toJSON());
    }
    if (Array.isArray(this.activities)) {
      data['activities'] = [];
      for (let item of this.activities) data['activities'].push(item.toJSON());
    }
    if (Array.isArray(this.applicants)) {
      data['applicants'] = [];
      for (let item of this.applicants) data['applicants'].push(item.toJSON());
    }
    if (Array.isArray(this.acceptedApplicants)) {
      data['acceptedApplicants'] = [];
      for (let item of this.acceptedApplicants)
        data['acceptedApplicants'].push(item.toJSON());
    }
    data['isInsideKsa'] = this.isInsideKsa;
    data['isContainTawreedTables'] = this.isContainTawreedTables;
    data['isIncludingInvitation'] = this.isIncludingInvitation;
    return data;
  }
}

export interface ITenderVm {
  id?: string | undefined;
  referenceNumber?: string | undefined;
  name?: string | undefined;
  type?: string | undefined;
  typeId?: number;
  status?: string | undefined;
  purpose?: string | undefined;
  description?: string | undefined;
  agencyName?: string | undefined;
  bookletPrice?: number;
  lastEnquiriesDate?: Date | undefined;
  createDate?: Date;
  invitationCost?: number;
  awardingExpectedDate?: Date | undefined;
  startingBusinessDate?: Date | undefined;
  startingSendingEnquiriesDate?: Date | undefined;
  maxAnswerQuestionsTime?: number;
  remainingDays?: number;
  agreementType?: string | undefined;
  offers?: TenderOfferVm | undefined;
  cities?: TenderCityVm[] | undefined;
  areas?: TenderAreaVm[] | undefined;
  activities?: TenderActivityVm[] | undefined;
  applicants?: ApplicantDetailsVm[] | undefined;
  acceptedApplicants?: ApplicantDetailsVm[] | undefined;
  isInsideKsa?: boolean;
  isContainTawreedTables?: boolean;
  isIncludingInvitation?: boolean;
}

export class TenderOfferVm implements ITenderOfferVm {
  lastOfferPresentationDate?: Date | undefined;
  offerPresentationWay?: string | undefined;
  offersCheckingDate?: Date | undefined;
  offersOpeningDate?: Date | undefined;
  offersOpeningAddress?: string | undefined;

  constructor(data?: ITenderOfferVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.lastOfferPresentationDate = _data['lastOfferPresentationDate']
        ? new Date(_data['lastOfferPresentationDate'].toString())
        : <any>undefined;
      this.offerPresentationWay = _data['offerPresentationWay'];
      this.offersCheckingDate = _data['offersCheckingDate']
        ? new Date(_data['offersCheckingDate'].toString())
        : <any>undefined;
      this.offersOpeningDate = _data['offersOpeningDate']
        ? new Date(_data['offersOpeningDate'].toString())
        : <any>undefined;
      this.offersOpeningAddress = _data['offersOpeningAddress'];
    }
  }

  static fromJS(data: any): TenderOfferVm {
    data = typeof data === 'object' ? data : {};
    let result = new TenderOfferVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['lastOfferPresentationDate'] = this.lastOfferPresentationDate
      ? this.lastOfferPresentationDate.toISOString()
      : <any>undefined;
    data['offerPresentationWay'] = this.offerPresentationWay;
    data['offersCheckingDate'] = this.offersCheckingDate
      ? this.offersCheckingDate.toISOString()
      : <any>undefined;
    data['offersOpeningDate'] = this.offersOpeningDate
      ? this.offersOpeningDate.toISOString()
      : <any>undefined;
    data['offersOpeningAddress'] = this.offersOpeningAddress;
    return data;
  }
}

export interface ITenderOfferVm {
  lastOfferPresentationDate?: Date | undefined;
  offerPresentationWay?: string | undefined;
  offersCheckingDate?: Date | undefined;
  offersOpeningDate?: Date | undefined;
  offersOpeningAddress?: string | undefined;
}

export class TenderCityVm implements ITenderCityVm {
  name?: string | undefined;

  constructor(data?: ITenderCityVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
    }
  }

  static fromJS(data: any): TenderCityVm {
    data = typeof data === 'object' ? data : {};
    let result = new TenderCityVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    return data;
  }
}

export interface ITenderCityVm {
  name?: string | undefined;
}

export class TenderAreaVm implements ITenderAreaVm {
  name?: string | undefined;

  constructor(data?: ITenderAreaVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
    }
  }

  static fromJS(data: any): TenderAreaVm {
    data = typeof data === 'object' ? data : {};
    let result = new TenderAreaVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    return data;
  }
}

export interface ITenderAreaVm {
  name?: string | undefined;
}

export class TenderActivityVm implements ITenderActivityVm {
  name?: string | undefined;

  constructor(data?: ITenderActivityVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
    }
  }

  static fromJS(data: any): TenderActivityVm {
    data = typeof data === 'object' ? data : {};
    let result = new TenderActivityVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    return data;
  }
}

export interface ITenderActivityVm {
  name?: string | undefined;
}

export class ApplicantDetailsVm implements IApplicantDetailsVm {
  name?: string | undefined;
  offerValue?: number;
  applicable?: string | undefined;
  acceptedValue?: number;

  constructor(data?: IApplicantDetailsVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.offerValue = _data['offerValue'];
      this.applicable = _data['applicable'];
      this.acceptedValue = _data['acceptedValue'];
    }
  }

  static fromJS(data: any): ApplicantDetailsVm {
    data = typeof data === 'object' ? data : {};
    let result = new ApplicantDetailsVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['offerValue'] = this.offerValue;
    data['applicable'] = this.applicable;
    data['acceptedValue'] = this.acceptedValue;
    return data;
  }
}

export interface IApplicantDetailsVm {
  name?: string | undefined;
  offerValue?: number;
  applicable?: string | undefined;
  acceptedValue?: number;
}

export class TenderCardInfo implements ITenderCardInfo {
  tenderId?: number;
  tenderIdString?: string | undefined;
  referenceNumber?: string | undefined;
  name?: string | undefined;
  type?: string | undefined;
  typeID?: number;
  agencyName?: string | undefined;
  activityName?: string | undefined;
  tenderActivityName?: string | undefined;
  lastOfferPresentationDate?: Date | undefined;
  bookletPrice?: number;
  createDate?: Date;
  submissionDate?: Date;
  invitationCost?: number;
  buyingCost?: number;
  isIncludingInvitation?: boolean;
  branchName?: string | undefined;
  branchId?: number;
  tenderStatusId?: number;
  offersOpeningDate?: Date | undefined;
  lastEnqueriesDateHijri?: string | undefined;
  offersOpeningDateHijri?: string | undefined;
  lastOfferPresentationDateHijri?: string | undefined;
  insideKsa?: any | undefined;
  tenderActivityId?: number;
  financialFees?: number;
  tenderNumber?: string | undefined;

  constructor(data?: ITenderCardInfo) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.tenderId = _data['tenderId'];
      this.tenderIdString = _data['tenderIdString'];
      this.referenceNumber = _data['referenceNumber'];
      this.name = _data['name'];
      this.type = _data['type'];
      this.typeID = _data['typeID'];
      this.agencyName = _data['agencyName'];
      this.activityName = _data['activityName'];
      this.tenderActivityName = _data['tenderActivityName'];
      this.lastOfferPresentationDate = _data['lastOfferPresentationDate']
        ? new Date(_data['lastOfferPresentationDate'].toString())
        : <any>undefined;
      this.bookletPrice = _data['bookletPrice'];
      this.createDate = _data['createDate']
        ? new Date(_data['createDate'].toString())
        : <any>undefined;
      this.submissionDate = _data['submissionDate']
        ? new Date(_data['submissionDate'].toString())
        : <any>undefined;
      this.invitationCost = _data['invitationCost'];
      this.buyingCost = _data['buyingCost'];
      this.isIncludingInvitation = _data['isIncludingInvitation'];
      this.branchName = _data['branchName'];
      this.branchId = _data['branchId'];
      this.tenderStatusId = _data['tenderStatusId'];
      this.offersOpeningDate = _data['offersOpeningDate']
        ? new Date(_data['offersOpeningDate'].toString())
        : <any>undefined;
      this.lastEnqueriesDateHijri = _data['lastEnqueriesDateHijri'];
      this.offersOpeningDateHijri = _data['offersOpeningDateHijri'];
      this.lastOfferPresentationDateHijri = _data['lastOfferPresentationDateHijri'];
      this.insideKsa = _data['insideKsa'];
      this.tenderActivityId = _data['tenderActivityId'];
      this.financialFees = _data['financialFees'];
      this.tenderNumber = _data['tenderNumber'];
    }
  }

  static fromJS(data: any): TenderCardInfo {
    data = typeof data === 'object' ? data : {};
    let result = new TenderCardInfo();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['tenderId'] = this.tenderId;
    data['tenderIdString'] = this.tenderIdString;
    data['referenceNumber'] = this.referenceNumber;
    data['name'] = this.name;
    data['type'] = this.type;
    data['typeID'] = this.typeID;
    data['agencyName'] = this.agencyName;
    data['activityName'] = this.activityName;
    data['tenderActivityName'] = this.tenderActivityName;
    data['lastOfferPresentationDate'] = this.lastOfferPresentationDate
      ? this.lastOfferPresentationDate.toISOString()
      : <any>undefined;
    data['bookletPrice'] = this.bookletPrice;
    data['createDate'] = this.createDate ? this.createDate.toISOString() : <any>undefined;
    data['submissionDate'] = this.submissionDate
      ? this.submissionDate.toISOString()
      : <any>undefined;
    data['invitationCost'] = this.invitationCost;
    data['buyingCost'] = this.buyingCost;
    data['isIncludingInvitation'] = this.isIncludingInvitation;
    data['branchName'] = this.branchName;
    data['branchId'] = this.branchId;
    data['tenderStatusId'] = this.tenderStatusId;
    data['offersOpeningDate'] = this.offersOpeningDate
      ? this.offersOpeningDate.toISOString()
      : <any>undefined;
    data['lastEnqueriesDateHijri'] = this.lastEnqueriesDateHijri;
    data['offersOpeningDateHijri'] = this.offersOpeningDateHijri;
    data['lastOfferPresentationDateHijri'] = this.lastOfferPresentationDateHijri;
    data['insideKsa'] = this.insideKsa;
    data['tenderActivityId'] = this.tenderActivityId;
    data['financialFees'] = this.financialFees;
    data['tenderNumber'] = this.tenderNumber;
    return data;
  }
}

export interface ITenderCardInfo {
  tenderId?: number;
  tenderIdString?: string | undefined;
  referenceNumber?: string | undefined;
  name?: string | undefined;
  type?: string | undefined;
  typeID?: number;
  agencyName?: string | undefined;
  activityName?: string | undefined;
  tenderActivityName?: string | undefined;
  lastOfferPresentationDate?: Date | undefined;
  bookletPrice?: number;
  createDate?: Date;
  submissionDate?: Date;
  invitationCost?: number;
  buyingCost?: number;
  isIncludingInvitation?: boolean;
  branchName?: string | undefined;
  branchId?: number;
  tenderStatusId?: number;
  offersOpeningDate?: Date | undefined;
  lastEnqueriesDateHijri?: string | undefined;
  offersOpeningDateHijri?: string | undefined;
  lastOfferPresentationDateHijri?: string | undefined;
  insideKsa?: any | undefined;
  tenderActivityId?: number;
  financialFees?: number;
  tenderNumber?: string | undefined;
}

export class TenderInfo implements ITenderInfo {
  referenceNumber?: string | undefined;
  name?: string | undefined;
  type?: string | undefined;
  typeID?: number;
  status?: string | undefined;
  purpose?: string | undefined;
  description?: string | undefined;
  agencyName?: string | undefined;
  bookletPrice?: number;
  lastEnqueriesDate?: Date | undefined;
  createDate?: Date;
  invitationCost?: number;
  awardingExpectedDate?: Date | undefined;
  awardingStoppingPeriod?: number;
  startingBusinessDate?: Date | undefined;
  startingSendingEnquiriesDate?: Date | undefined;
  maxAnswerQuestionsTime?: number;
  finalGuaranteePercentage?: number;
  intialGuaranteeAddress?: string | undefined;
  remainingDays?: number;
  agreementType?: string | undefined;
  offers?: Offers | undefined;
  cities?: CityInfo[] | undefined;
  areas?: AreaInfo[] | undefined;
  activities?: ActivityInfo[] | undefined;
  applicants?: ApplicantInfo[] | undefined;
  acceptedApplicants?: ApplicantInfo[] | undefined;
  isInsideKSA?: boolean;
  isContainTawreedTables?: boolean;
  isIncludingInvitation?: boolean;
  additionalProperties?: { [key: string]: string } | undefined;
  offersOpeningDate?: Date | undefined;
  tenderNumber?: string | undefined;
  primaryGuarantee?: string | undefined;

  constructor(data?: ITenderInfo) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.referenceNumber = _data['referenceNumber'];
      this.name = _data['name'];
      this.type = _data['type'];
      this.typeID = _data['typeID'];
      this.status = _data['status'];
      this.purpose = _data['purpose'];
      this.description = _data['description'];
      this.agencyName = _data['agencyName'];
      this.bookletPrice = _data['bookletPrice'];
      this.lastEnqueriesDate = _data['lastEnqueriesDate']
        ? new Date(_data['lastEnqueriesDate'].toString())
        : <any>undefined;
      this.createDate = _data['createDate']
        ? new Date(_data['createDate'].toString())
        : <any>undefined;
      this.invitationCost = _data['invitationCost'];
      this.awardingExpectedDate = _data['awardingExpectedDate']
        ? new Date(_data['awardingExpectedDate'].toString())
        : <any>undefined;
      this.awardingStoppingPeriod = _data['awardingStoppingPeriod'];
      this.startingBusinessDate = _data['startingBusinessDate']
        ? new Date(_data['startingBusinessDate'].toString())
        : <any>undefined;
      this.startingSendingEnquiriesDate = _data['startingSendingEnquiriesDate']
        ? new Date(_data['startingSendingEnquiriesDate'].toString())
        : <any>undefined;
      this.maxAnswerQuestionsTime = _data['maxAnswerQuestionsTime'];
      this.finalGuaranteePercentage = _data['finalGuaranteePercentage'];
      this.intialGuaranteeAddress = _data['intialGuaranteeAddress'];
      this.remainingDays = _data['remainingDays'];
      this.agreementType = _data['agreementType'];
      this.offers = _data['offers'] ? Offers.fromJS(_data['offers']) : <any>undefined;
      if (Array.isArray(_data['cities'])) {
        this.cities = [] as any;
        for (let item of _data['cities']) this.cities!.push(CityInfo.fromJS(item));
      }
      if (Array.isArray(_data['areas'])) {
        this.areas = [] as any;
        for (let item of _data['areas']) this.areas!.push(AreaInfo.fromJS(item));
      }
      if (Array.isArray(_data['activities'])) {
        this.activities = [] as any;
        for (let item of _data['activities'])
          this.activities!.push(ActivityInfo.fromJS(item));
      }
      if (Array.isArray(_data['applicants'])) {
        this.applicants = [] as any;
        for (let item of _data['applicants'])
          this.applicants!.push(ApplicantInfo.fromJS(item));
      }
      if (Array.isArray(_data['acceptedApplicants'])) {
        this.acceptedApplicants = [] as any;
        for (let item of _data['acceptedApplicants'])
          this.acceptedApplicants!.push(ApplicantInfo.fromJS(item));
      }
      this.isInsideKSA = _data['isInsideKSA'];
      this.isContainTawreedTables = _data['isContainTawreedTables'];
      this.isIncludingInvitation = _data['isIncludingInvitation'];
      if (_data['additionalProperties']) {
        this.additionalProperties = {} as any;
        for (let key in _data['additionalProperties']) {
          if (_data['additionalProperties'].hasOwnProperty(key))
            (<any>this.additionalProperties)![key] = _data['additionalProperties'][key];
        }
      }
      this.offersOpeningDate = _data['offersOpeningDate']
        ? new Date(_data['offersOpeningDate'].toString())
        : <any>undefined;
      this.tenderNumber = _data['tenderNumber'];
      this.primaryGuarantee = _data['primaryGuarantee'];
    }
  }

  static fromJS(data: any): TenderInfo {
    data = typeof data === 'object' ? data : {};
    let result = new TenderInfo();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['referenceNumber'] = this.referenceNumber;
    data['name'] = this.name;
    data['type'] = this.type;
    data['typeID'] = this.typeID;
    data['status'] = this.status;
    data['purpose'] = this.purpose;
    data['description'] = this.description;
    data['agencyName'] = this.agencyName;
    data['bookletPrice'] = this.bookletPrice;
    data['lastEnqueriesDate'] = this.lastEnqueriesDate
      ? this.lastEnqueriesDate.toISOString()
      : <any>undefined;
    data['createDate'] = this.createDate ? this.createDate.toISOString() : <any>undefined;
    data['invitationCost'] = this.invitationCost;
    data['awardingExpectedDate'] = this.awardingExpectedDate
      ? this.awardingExpectedDate.toISOString()
      : <any>undefined;
    data['awardingStoppingPeriod'] = this.awardingStoppingPeriod;
    data['startingBusinessDate'] = this.startingBusinessDate
      ? this.startingBusinessDate.toISOString()
      : <any>undefined;
    data['startingSendingEnquiriesDate'] = this.startingSendingEnquiriesDate
      ? this.startingSendingEnquiriesDate.toISOString()
      : <any>undefined;
    data['maxAnswerQuestionsTime'] = this.maxAnswerQuestionsTime;
    data['finalGuaranteePercentage'] = this.finalGuaranteePercentage;
    data['intialGuaranteeAddress'] = this.intialGuaranteeAddress;
    data['remainingDays'] = this.remainingDays;
    data['agreementType'] = this.agreementType;
    data['offers'] = this.offers ? this.offers.toJSON() : <any>undefined;
    if (Array.isArray(this.cities)) {
      data['cities'] = [];
      for (let item of this.cities) data['cities'].push(item.toJSON());
    }
    if (Array.isArray(this.areas)) {
      data['areas'] = [];
      for (let item of this.areas) data['areas'].push(item.toJSON());
    }
    if (Array.isArray(this.activities)) {
      data['activities'] = [];
      for (let item of this.activities) data['activities'].push(item.toJSON());
    }
    if (Array.isArray(this.applicants)) {
      data['applicants'] = [];
      for (let item of this.applicants) data['applicants'].push(item.toJSON());
    }
    if (Array.isArray(this.acceptedApplicants)) {
      data['acceptedApplicants'] = [];
      for (let item of this.acceptedApplicants)
        data['acceptedApplicants'].push(item.toJSON());
    }
    data['isInsideKSA'] = this.isInsideKSA;
    data['isContainTawreedTables'] = this.isContainTawreedTables;
    data['isIncludingInvitation'] = this.isIncludingInvitation;
    if (this.additionalProperties) {
      data['additionalProperties'] = {};
      for (let key in this.additionalProperties) {
        if (this.additionalProperties.hasOwnProperty(key))
          (<any>data['additionalProperties'])[key] = (<any>this.additionalProperties)[
            key
          ];
      }
    }
    data['offersOpeningDate'] = this.offersOpeningDate
      ? this.offersOpeningDate.toISOString()
      : <any>undefined;
    data['tenderNumber'] = this.tenderNumber;
    data['primaryGuarantee'] = this.primaryGuarantee;
    return data;
  }
}

export interface ITenderInfo {
  referenceNumber?: string | undefined;
  name?: string | undefined;
  type?: string | undefined;
  typeID?: number;
  status?: string | undefined;
  purpose?: string | undefined;
  description?: string | undefined;
  agencyName?: string | undefined;
  bookletPrice?: number;
  lastEnqueriesDate?: Date | undefined;
  createDate?: Date;
  invitationCost?: number;
  awardingExpectedDate?: Date | undefined;
  awardingStoppingPeriod?: number;
  startingBusinessDate?: Date | undefined;
  startingSendingEnquiriesDate?: Date | undefined;
  maxAnswerQuestionsTime?: number;
  finalGuaranteePercentage?: number;
  intialGuaranteeAddress?: string | undefined;
  remainingDays?: number;
  agreementType?: string | undefined;
  offers?: Offers | undefined;
  cities?: CityInfo[] | undefined;
  areas?: AreaInfo[] | undefined;
  activities?: ActivityInfo[] | undefined;
  applicants?: ApplicantInfo[] | undefined;
  acceptedApplicants?: ApplicantInfo[] | undefined;
  isInsideKSA?: boolean;
  isContainTawreedTables?: boolean;
  isIncludingInvitation?: boolean;
  additionalProperties?: { [key: string]: string } | undefined;
  offersOpeningDate?: Date | undefined;
  tenderNumber?: string | undefined;
  primaryGuarantee?: string | undefined;
}

export class Offers implements IOffers {
  lastOfferPresentationDate?: Date | undefined;
  offerPresentationWay?: string | undefined;
  offersCheckingDate?: Date | undefined;
  offersOpeningDate?: Date | undefined;
  offersOpeningAddress?: string | undefined;

  constructor(data?: IOffers) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.lastOfferPresentationDate = _data['lastOfferPresentationDate']
        ? new Date(_data['lastOfferPresentationDate'].toString())
        : <any>undefined;
      this.offerPresentationWay = _data['offerPresentationWay'];
      this.offersCheckingDate = _data['offersCheckingDate']
        ? new Date(_data['offersCheckingDate'].toString())
        : <any>undefined;
      this.offersOpeningDate = _data['offersOpeningDate']
        ? new Date(_data['offersOpeningDate'].toString())
        : <any>undefined;
      this.offersOpeningAddress = _data['offersOpeningAddress'];
    }
  }

  static fromJS(data: any): Offers {
    data = typeof data === 'object' ? data : {};
    let result = new Offers();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['lastOfferPresentationDate'] = this.lastOfferPresentationDate
      ? this.lastOfferPresentationDate.toISOString()
      : <any>undefined;
    data['offerPresentationWay'] = this.offerPresentationWay;
    data['offersCheckingDate'] = this.offersCheckingDate
      ? this.offersCheckingDate.toISOString()
      : <any>undefined;
    data['offersOpeningDate'] = this.offersOpeningDate
      ? this.offersOpeningDate.toISOString()
      : <any>undefined;
    data['offersOpeningAddress'] = this.offersOpeningAddress;
    return data;
  }
}

export interface IOffers {
  lastOfferPresentationDate?: Date | undefined;
  offerPresentationWay?: string | undefined;
  offersCheckingDate?: Date | undefined;
  offersOpeningDate?: Date | undefined;
  offersOpeningAddress?: string | undefined;
}

export class CityInfo implements ICityInfo {
  name?: string | undefined;

  constructor(data?: ICityInfo) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
    }
  }

  static fromJS(data: any): CityInfo {
    data = typeof data === 'object' ? data : {};
    let result = new CityInfo();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    return data;
  }
}

export interface ICityInfo {
  name?: string | undefined;
}

export class AreaInfo implements IAreaInfo {
  name?: string | undefined;

  constructor(data?: IAreaInfo) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
    }
  }

  static fromJS(data: any): AreaInfo {
    data = typeof data === 'object' ? data : {};
    let result = new AreaInfo();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    return data;
  }
}

export interface IAreaInfo {
  name?: string | undefined;
}

export class ActivityInfo implements IActivityInfo {
  name?: string | undefined;

  constructor(data?: IActivityInfo) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
    }
  }

  static fromJS(data: any): ActivityInfo {
    data = typeof data === 'object' ? data : {};
    let result = new ActivityInfo();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    return data;
  }
}

export interface IActivityInfo {
  name?: string | undefined;
}

export class ApplicantInfo implements IApplicantInfo {
  name?: string | undefined;
  offerValue?: number;
  applicable?: string | undefined;
  acceptedValue?: number;

  constructor(data?: IApplicantInfo) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.offerValue = _data['offerValue'];
      this.applicable = _data['applicable'];
      this.acceptedValue = _data['acceptedValue'];
    }
  }

  static fromJS(data: any): ApplicantInfo {
    data = typeof data === 'object' ? data : {};
    let result = new ApplicantInfo();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['offerValue'] = this.offerValue;
    data['applicable'] = this.applicable;
    data['acceptedValue'] = this.acceptedValue;
    return data;
  }
}

export interface IApplicantInfo {
  name?: string | undefined;
  offerValue?: number;
  applicable?: string | undefined;
  acceptedValue?: number;
}

export class RateLimitingResult implements IRateLimitingResult {
  failedAfter?: number;

  constructor(data?: IRateLimitingResult) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.failedAfter = _data['failedAfter'];
    }
  }

  static fromJS(data: any): RateLimitingResult {
    data = typeof data === 'object' ? data : {};
    let result = new RateLimitingResult();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['failedAfter'] = this.failedAfter;
    return data;
  }
}

export interface IRateLimitingResult {
  failedAfter?: number;
}

export class WorkItemListingVm implements IWorkItemListingVm {
  notStarted?: PaginatedListOfWorkItemVm | undefined;
  inProgress?: PaginatedListOfWorkItemVm | undefined;
  completed?: PaginatedListOfWorkItemVm | undefined;

  constructor(data?: IWorkItemListingVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.notStarted = _data['notStarted']
        ? PaginatedListOfWorkItemVm.fromJS(_data['notStarted'])
        : <any>undefined;
      this.inProgress = _data['inProgress']
        ? PaginatedListOfWorkItemVm.fromJS(_data['inProgress'])
        : <any>undefined;
      this.completed = _data['completed']
        ? PaginatedListOfWorkItemVm.fromJS(_data['completed'])
        : <any>undefined;
    }
  }

  static fromJS(data: any): WorkItemListingVm {
    data = typeof data === 'object' ? data : {};
    let result = new WorkItemListingVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['notStarted'] = this.notStarted ? this.notStarted.toJSON() : <any>undefined;
    data['inProgress'] = this.inProgress ? this.inProgress.toJSON() : <any>undefined;
    data['completed'] = this.completed ? this.completed.toJSON() : <any>undefined;
    return data;
  }
}

export interface IWorkItemListingVm {
  notStarted?: PaginatedListOfWorkItemVm | undefined;
  inProgress?: PaginatedListOfWorkItemVm | undefined;
  completed?: PaginatedListOfWorkItemVm | undefined;
}

export class PaginatedListOfWorkItemVm implements IPaginatedListOfWorkItemVm {
  pageInfo?: PageInfo | undefined;
  items?: WorkItemVm[] | undefined;

  constructor(data?: IPaginatedListOfWorkItemVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items']) this.items!.push(WorkItemVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfWorkItemVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfWorkItemVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfWorkItemVm {
  pageInfo?: PageInfo | undefined;
  items?: WorkItemVm[] | undefined;
}

export class WorkItemVm implements IWorkItemVm {
  id?: string | undefined;
  termId?: string | undefined;
  name?: string | undefined;
  description?: string | undefined;
  priority?: WorkItemPriority;
  startingDate?: Date;
  period?: PeriodDto | undefined;
  remainingTime?: RemainingTimeDto | undefined;
  attachments?: FileAttachmentDto[] | undefined;
  comments?: number;
  assignees?: string[] | undefined;
  tags?: string[] | undefined;

  constructor(data?: IWorkItemVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.termId = _data['termId'];
      this.name = _data['name'];
      this.description = _data['description'];
      this.priority = _data['priority'];
      this.startingDate = _data['startingDate']
        ? new Date(_data['startingDate'].toString())
        : <any>undefined;
      this.period = _data['period'] ? PeriodDto.fromJS(_data['period']) : <any>undefined;
      this.remainingTime = _data['remainingTime']
        ? RemainingTimeDto.fromJS(_data['remainingTime'])
        : <any>undefined;
      if (Array.isArray(_data['attachments'])) {
        this.attachments = [] as any;
        for (let item of _data['attachments'])
          this.attachments!.push(FileAttachmentDto.fromJS(item));
      }
      this.comments = _data['comments'];
      if (Array.isArray(_data['assignees'])) {
        this.assignees = [] as any;
        for (let item of _data['assignees']) this.assignees!.push(item);
      }
      if (Array.isArray(_data['tags'])) {
        this.tags = [] as any;
        for (let item of _data['tags']) this.tags!.push(item);
      }
    }
  }

  static fromJS(data: any): WorkItemVm {
    data = typeof data === 'object' ? data : {};
    let result = new WorkItemVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['termId'] = this.termId;
    data['name'] = this.name;
    data['description'] = this.description;
    data['priority'] = this.priority;
    data['startingDate'] = this.startingDate
      ? this.startingDate.toISOString()
      : <any>undefined;
    data['period'] = this.period ? this.period.toJSON() : <any>undefined;
    data['remainingTime'] = this.remainingTime
      ? this.remainingTime.toJSON()
      : <any>undefined;
    if (Array.isArray(this.attachments)) {
      data['attachments'] = [];
      for (let item of this.attachments) data['attachments'].push(item.toJSON());
    }
    data['comments'] = this.comments;
    if (Array.isArray(this.assignees)) {
      data['assignees'] = [];
      for (let item of this.assignees) data['assignees'].push(item);
    }
    if (Array.isArray(this.tags)) {
      data['tags'] = [];
      for (let item of this.tags) data['tags'].push(item);
    }
    return data;
  }
}

export interface IWorkItemVm {
  id?: string | undefined;
  termId?: string | undefined;
  name?: string | undefined;
  description?: string | undefined;
  priority?: WorkItemPriority;
  startingDate?: Date;
  period?: PeriodDto | undefined;
  remainingTime?: RemainingTimeDto | undefined;
  attachments?: FileAttachmentDto[] | undefined;
  comments?: number;
  assignees?: string[] | undefined;
  tags?: string[] | undefined;
}

export enum WorkItemPriority {
  Low = 0,
  Medium = 1,
  High = 2,
}

export class WorkItemCommentVm implements IWorkItemCommentVm {
  id?: string | undefined;
  userId?: string | undefined;
  content?: string | undefined;
  createdAt?: Date;
  modifiedAt?: Date | undefined;

  constructor(data?: IWorkItemCommentVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data['id'];
      this.userId = _data['userId'];
      this.content = _data['content'];
      this.createdAt = _data['createdAt']
        ? new Date(_data['createdAt'].toString())
        : <any>undefined;
      this.modifiedAt = _data['modifiedAt']
        ? new Date(_data['modifiedAt'].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): WorkItemCommentVm {
    data = typeof data === 'object' ? data : {};
    let result = new WorkItemCommentVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['id'] = this.id;
    data['userId'] = this.userId;
    data['content'] = this.content;
    data['createdAt'] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
    data['modifiedAt'] = this.modifiedAt ? this.modifiedAt.toISOString() : <any>undefined;
    return data;
  }
}

export interface IWorkItemCommentVm {
  id?: string | undefined;
  userId?: string | undefined;
  content?: string | undefined;
  createdAt?: Date;
  modifiedAt?: Date | undefined;
}

export class WorkItemDto implements IWorkItemDto {
  termId?: string | undefined;
  name?: string | undefined;
  description?: string | undefined;
  priority?: WorkItemPriority;
  startingDate?: Date;
  period?: PeriodDto | undefined;
  assignees?: string[] | undefined;
  tags?: string[] | undefined;
  attachments?: UploadAttachmentDto[] | undefined;

  constructor(data?: IWorkItemDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.termId = _data['termId'];
      this.name = _data['name'];
      this.description = _data['description'];
      this.priority = _data['priority'];
      this.startingDate = _data['startingDate']
        ? new Date(_data['startingDate'].toString())
        : <any>undefined;
      this.period = _data['period'] ? PeriodDto.fromJS(_data['period']) : <any>undefined;
      if (Array.isArray(_data['assignees'])) {
        this.assignees = [] as any;
        for (let item of _data['assignees']) this.assignees!.push(item);
      }
      if (Array.isArray(_data['tags'])) {
        this.tags = [] as any;
        for (let item of _data['tags']) this.tags!.push(item);
      }
      if (Array.isArray(_data['attachments'])) {
        this.attachments = [] as any;
        for (let item of _data['attachments'])
          this.attachments!.push(UploadAttachmentDto.fromJS(item));
      }
    }
  }

  static fromJS(data: any): WorkItemDto {
    data = typeof data === 'object' ? data : {};
    let result = new WorkItemDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['termId'] = this.termId;
    data['name'] = this.name;
    data['description'] = this.description;
    data['priority'] = this.priority;
    data['startingDate'] = this.startingDate
      ? this.startingDate.toISOString()
      : <any>undefined;
    data['period'] = this.period ? this.period.toJSON() : <any>undefined;
    if (Array.isArray(this.assignees)) {
      data['assignees'] = [];
      for (let item of this.assignees) data['assignees'].push(item);
    }
    if (Array.isArray(this.tags)) {
      data['tags'] = [];
      for (let item of this.tags) data['tags'].push(item);
    }
    if (Array.isArray(this.attachments)) {
      data['attachments'] = [];
      for (let item of this.attachments) data['attachments'].push(item.toJSON());
    }
    return data;
  }
}

export interface IWorkItemDto {
  termId?: string | undefined;
  name?: string | undefined;
  description?: string | undefined;
  priority?: WorkItemPriority;
  startingDate?: Date;
  period?: PeriodDto | undefined;
  assignees?: string[] | undefined;
  tags?: string[] | undefined;
  attachments?: UploadAttachmentDto[] | undefined;
}

export class WorkItemCommentDto implements IWorkItemCommentDto {
  content?: string | undefined;

  constructor(data?: IWorkItemCommentDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.content = _data['content'];
    }
  }

  static fromJS(data: any): WorkItemCommentDto {
    data = typeof data === 'object' ? data : {};
    let result = new WorkItemCommentDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['content'] = this.content;
    return data;
  }
}

export interface IWorkItemCommentDto {
  content?: string | undefined;
}

export class WorkItemChangeStatusDto implements IWorkItemChangeStatusDto {
  oldValue?: WorkItemStatus;
  newValue?: WorkItemStatus;

  constructor(data?: IWorkItemChangeStatusDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.oldValue = _data['oldValue'];
      this.newValue = _data['newValue'];
    }
  }

  static fromJS(data: any): WorkItemChangeStatusDto {
    data = typeof data === 'object' ? data : {};
    let result = new WorkItemChangeStatusDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['oldValue'] = this.oldValue;
    data['newValue'] = this.newValue;
    return data;
  }
}

export interface IWorkItemChangeStatusDto {
  oldValue?: WorkItemStatus;
  newValue?: WorkItemStatus;
}

export enum WorkItemStatus {
  Created = 0,
  InProgress = 1,
  Completed = 2,
  Archived = 3,
}

export class PaginatedListOfWorkItemListingSummaryVm
  implements IPaginatedListOfWorkItemListingSummaryVm
{
  pageInfo?: PageInfo | undefined;
  items?: WorkItemListingSummaryVm[] | undefined;

  constructor(data?: IPaginatedListOfWorkItemListingSummaryVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.pageInfo = _data['pageInfo']
        ? PageInfo.fromJS(_data['pageInfo'])
        : <any>undefined;
      if (Array.isArray(_data['items'])) {
        this.items = [] as any;
        for (let item of _data['items'])
          this.items!.push(WorkItemListingSummaryVm.fromJS(item));
      }
    }
  }

  static fromJS(data: any): PaginatedListOfWorkItemListingSummaryVm {
    data = typeof data === 'object' ? data : {};
    let result = new PaginatedListOfWorkItemListingSummaryVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['pageInfo'] = this.pageInfo ? this.pageInfo.toJSON() : <any>undefined;
    if (Array.isArray(this.items)) {
      data['items'] = [];
      for (let item of this.items) data['items'].push(item.toJSON());
    }
    return data;
  }
}

export interface IPaginatedListOfWorkItemListingSummaryVm {
  pageInfo?: PageInfo | undefined;
  items?: WorkItemListingSummaryVm[] | undefined;
}

export class WorkItemListingSummaryVm implements IWorkItemListingSummaryVm {
  name?: string | undefined;
  termId?: string | undefined;
  status?: WorkItemStatus;
  assignees?: string[] | undefined;
  businessType?: BusinessType;

  constructor(data?: IWorkItemListingSummaryVm) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.name = _data['name'];
      this.termId = _data['termId'];
      this.status = _data['status'];
      if (Array.isArray(_data['assignees'])) {
        this.assignees = [] as any;
        for (let item of _data['assignees']) this.assignees!.push(item);
      }
      this.businessType = _data['businessType'];
    }
  }

  static fromJS(data: any): WorkItemListingSummaryVm {
    data = typeof data === 'object' ? data : {};
    let result = new WorkItemListingSummaryVm();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data['name'] = this.name;
    data['termId'] = this.termId;
    data['status'] = this.status;
    if (Array.isArray(this.assignees)) {
      data['assignees'] = [];
      for (let item of this.assignees) data['assignees'].push(item);
    }
    data['businessType'] = this.businessType;
    return data;
  }
}

export interface IWorkItemListingSummaryVm {
  name?: string | undefined;
  termId?: string | undefined;
  status?: WorkItemStatus;
  assignees?: string[] | undefined;
  businessType?: BusinessType;
}

export interface FileParameter {
  data: any;
  fileName: string;
}

export interface FileResponse {
  data: Blob;
  status: number;
  fileName?: string;
  headers?: { [name: string]: any };
}

export class ApiException extends Error {
  override message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any
): Observable<any> {
  if (result !== null && result !== undefined) return _observableThrow(result);
  else
    return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next('');
      observer.complete();
    } else {
      let reader = new FileReader();
      reader.onload = (event) => {
        observer.next((event.target as any).result);
        observer.complete();
      };
      reader.readAsText(blob);
    }
  });
}
